{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev A clone instance deployment failed.\n     */\n    error ERC1167FailedCreateClone();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IPoolWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../types/PoolWrapperTypes.sol\";\n\ninterface IPoolWrapper {\n    function createPool(\n        PoolWrapperTypes.CreatePoolMsg calldata createPoolMsg\n    ) external returns (PoolWrapperTypes.CreatedPoolInfo memory);\n\n    function getPoolInfo(address stream) external view returns (PoolWrapperTypes.CreatedPoolInfo memory);\n}\n"
    },
    "contracts/interfaces/IPositionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../types/PositionTypes.sol\";\nimport \"../lib/math/DecimalMath.sol\";\n\ninterface IPositionStorage {\n    function getPosition(address _owner) external view returns (PositionTypes.Position memory);\n\n    function createPosition(address owner, uint256 inBalance, uint256 shares, Decimal memory index) external;\n\n    function updatePosition(address owner, PositionTypes.Position memory position) external;\n\n    function setExitDate(address owner, uint256 exitDate) external;\n}\n"
    },
    "contracts/interfaces/IStream.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../types/StreamTypes.sol\";\nimport \"../types/PositionTypes.sol\";\n\ninterface IStream {\n    function initialize(\n        StreamTypes.createStreamMessage memory createStreamMessage,\n        address positionStorageAddress\n    ) external;\n\n    function withdraw(uint256 cap) external;\n\n    function subscribe(uint256 amountIn) external payable;\n\n    function exitStream() external;\n\n    function finalizeStream() external;\n\n    function syncStreamExternal() external;\n\n    function syncPosition(address user) external;\n\n    function cancelStream() external;\n\n    function cancelWithAdmin() external;\n\n    // View functions\n    function getStreamStatus() external view returns (StreamTypes.Status);\n\n    function getStreamState() external view returns (StreamTypes.StreamState memory);\n\n    function getPosition(address user) external view returns (PositionTypes.Position memory);\n\n    // State variables getters (since they're public)\n    function creator() external view returns (address);\n\n    function positionStorageAddress() external view returns (address);\n\n    function streamFactoryAddress() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IStreamErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IStreamErrors {\n    // Stream errors\n    error InsufficientTokenPayment(uint256 requiredTokenAmount, uint256 tokenBalance);\n    error InvalidOutSupplyToken();\n    error InvalidInSupplyToken();\n    error PaymentFailed();\n    error OperationNotAllowed();\n    error Unauthorized();\n    error InvalidWithdrawAmount();\n    error WithdrawAmountExceedsBalance(uint256 cap);\n    error InsufficientOutAmount();\n    error InvalidPosition();\n    error InvalidExitCondition();\n    error InvalidVestingDuration();\n    error InvalidVestingCliffDuration();\n    error InvalidAmount();\n    error StreamFactoryAddressAlreadySet();\n    error InvalidStreamFactoryAddress();\n    error InvalidImplementationAddress();\n}\n"
    },
    "contracts/interfaces/IStreamEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../types/StreamTypes.sol\";\nimport \"../lib/math/DecimalMath.sol\";\n\ninterface IStreamEvents {\n    event StreamCreated(\n        address indexed streamOutToken,\n        address indexed streamInToken,\n        address indexed streamFactoryAddress,\n        uint256 streamOutAmount,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 threshold,\n        string streamName,\n        string tosVersion,\n        address streamAddress,\n        uint16 streamId\n    );\n\n    event StreamSynced(address indexed streamAddress, StreamTypes.Status mainStatus, uint256 lastUpdated);\n\n    event Subscribed(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 amountIn,\n        uint256 newShares,\n        uint256 totalSharesAfter,\n        uint256 totalInSupplyAfter\n    );\n\n    event StreamSynced(\n        address indexed streamAddress,\n        uint256 lastUpdated,\n        uint8 newStatus,\n        Decimal distIndex,\n        uint256 outRemaining,\n        uint256 inSupply,\n        uint256 spentIn,\n        Decimal currentStreamedPrice\n    );\n\n    event PositionSynced(address indexed streamAddress, address indexed subscriber, uint256 inBalance, uint256 shares);\n\n    event Withdrawn(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 remainingInBalance,\n        uint256 remainingShares,\n        uint256 totalInSupply,\n        uint256 totalShares\n    );\n\n    event ExitRefunded(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 refundedAmount,\n        uint256 exitTimestamp\n    );\n    event ExitStreamed(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 purchased,\n        uint256 spentIn,\n        uint256 exitTimestamp\n    );\n\n    event FinalizedStreamed(\n        address indexed streamAddress,\n        address indexed creator,\n        uint256 creatorRevenue,\n        uint256 exitFeeAmount,\n        uint256 refundedOutAmount,\n        StreamTypes.Status status\n    );\n\n    event FinalizedRefunded(\n        address indexed streamAddress,\n        address indexed creator,\n        uint256 refundedOutAmount,\n        StreamTypes.Status status\n    );\n\n    event ParamsUpdated(\n        address indexed factory,\n        uint256 streamCreationFee,\n        uint256 exitFeeRatio,\n        uint256 minWaitingDuration,\n        uint256 minBootstrappingDuration,\n        uint256 minStreamDuration,\n        string tosVersion\n    );\n\n    event FeeCollectorUpdated(address indexed factory, address newFeeCollector);\n\n    event ProtocolAdminUpdated(address indexed factory, address newProtocolAdmin);\n\n    event FrozenStateUpdated(address indexed factory, bool frozen);\n\n    event AcceptedTokensUpdated(address indexed factory, address[] tokensAdded, address[] tokensRemoved);\n\n    event StreamCancelled(address indexed streamAddress, address creator, uint256 outSupply, StreamTypes.Status status);\n\n    event VestingContractDeployed(address indexed factoryAddress, address vestingContract);\n\n    event PoolWrapperUpdated(address indexed factoryAddress, address poolWrapper);\n}\n"
    },
    "contracts/interfaces/IStreamFactoryErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// StreamFactory errors\ninterface IStreamFactoryErrors {\n    // StreamFactory errors\n    error InvalidBootstrappingStartTime();\n    error InvalidStreamStartTime();\n    error InvalidStreamEndTime();\n    error StreamDurationTooShort();\n    error BootstrappingDurationTooShort();\n    error WaitingDurationTooShort();\n    error ContractFrozen();\n    error InvalidExitFeeRatio();\n    error ZeroOutSupplyNotAllowed();\n    error StreamInputTokenNotAccepted();\n    error InvalidBootstrappingTime();\n    error StreamStartMustBeAfterBootstrapping();\n    error StreamEndMustBeAfterStart();\n    error InvalidToSVersion();\n    error InsufficientNativeToken();\n    error FeeTransferFailed();\n    error TokenTransferFailed();\n    error StreamAddressPredictionFailed();\n    error InvalidFeeCollector();\n    error InvalidProtocolAdmin();\n    error NotAdmin();\n    error InvalidPoolWrapper();\n    error InvalidImplementationAddress();\n}\n"
    },
    "contracts/interfaces/IUniswapV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IUniswapV2Router02 {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n}\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function totalSupply() external view returns (uint);\n}\n"
    },
    "contracts/interfaces/IVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title IVesting\n * @dev Interface for the Vesting contract that manages token vesting schedules\n */\ninterface IVesting {\n    /**\n     * @dev Struct representing a vesting schedule for a beneficiary\n     */\n    struct VestingSchedule {\n        uint256 cliffTime; // Timestamp when cliff period ends\n        uint256 endTime; // Timestamp when vesting period ends\n        uint256 totalAmount; // Total amount to be vested\n        uint256 releasedAmount; // Amount already released to beneficiary\n    }\n\n    /**\n     * @dev Stakes funds for vesting to a beneficiary\n     * @param beneficiary Address that will receive the vested tokens\n     * @param tokenAddress Address of the token being vested\n     * @param cliffTime Timestamp after which the first tokens can be withdrawn\n     * @param endTime Timestamp when all tokens will be vested\n     * @param totalAmount Total amount of tokens to vest\n     */\n    function stakeFunds(\n        address beneficiary,\n        address tokenAddress,\n        uint256 cliffTime,\n        uint256 endTime,\n        uint256 totalAmount\n    ) external;\n\n    /**\n     * @dev Withdraws available vested funds for the caller\n     * @param tokenAddress Address of the token to withdraw\n     * @param scheduleIndex Index of the vesting schedule to withdraw from\n     */\n    function withdrawFunds(address tokenAddress, uint256 scheduleIndex) external;\n\n    /**\n     * @dev Retrieves all vesting schedules for a beneficiary for a specific token\n     * @param beneficiary Address of the beneficiary\n     * @param tokenAddress Address of the token\n     * @return Array of vesting schedules\n     */\n    function getStakesForBeneficiary(\n        address beneficiary,\n        address tokenAddress\n    ) external view returns (VestingSchedule[] memory);\n\n    /**\n     * @dev Calculates the amount available for withdrawal from a vesting schedule\n     * @param vestingSchedule The vesting schedule to check\n     * @return The withdrawable amount\n     */\n    function calculateWithdrawableAmount(VestingSchedule memory vestingSchedule) external view returns (uint256);\n}\n"
    },
    "contracts/lib/helpers/TokenHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IStreamErrors.sol\";\n\nlibrary TokenHelpers {\n    /**\n     * @dev Checks if an address is a valid ERC20 token\n     * @param tokenAddress The token address to validate\n     * @param testAccount The account to use for testing the token interface\n     * @return isValid True if the address implements the ERC20 interface\n     */\n    function isValidERC20(address tokenAddress, address testAccount) internal view returns (bool isValid) {\n        if (tokenAddress == address(0)) {\n            return false;\n        }\n\n        try IERC20(tokenAddress).balanceOf(testAccount) returns (uint256) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Checks if an account has sufficient token balance\n     * @param tokenAddress The ERC20 token address\n     * @param account The account to check balance for\n     * @param requiredAmount The minimum required balance\n     * @return hasEnoughBalance True if the account has sufficient balance\n     */\n    function hasEnoughBalance(\n        address tokenAddress,\n        address account,\n        uint256 requiredAmount\n    ) internal view returns (bool) {\n        try IERC20(tokenAddress).balanceOf(account) returns (uint256 balance) {\n            return balance >= requiredAmount;\n        } catch Error(string memory) {\n            return false;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Safely transfers tokens from the contract to a recipient\n     * @param tokenAddress Address of the token to transfer\n     * @param recipient Address of the recipient\n     * @param amount Amount of tokens to transfer\n     * @return bool True if the transfer was successful\n     */\n    function safeTokenTransfer(address tokenAddress, address recipient, uint256 amount) internal returns (bool) {\n        if (amount == 0 || recipient == address(0)) {\n            return true;\n        }\n\n        IERC20 token = IERC20(tokenAddress);\n        bool success = token.transfer(recipient, amount);\n        if (!success) {\n            revert IStreamErrors.PaymentFailed();\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/lib/math/DecimalMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title Decimal type and math operations\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\n\n// Define the Decimal struct at the top level for easier imports\nstruct Decimal {\n    uint256 value; // Value scaled by DECIMAL_PRECISION\n}\n\n/**\n * @title DecimalMath\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\nlibrary DecimalMath {\n    // We'll use 6 decimal places for precision\n    uint256 public constant DECIMAL_PRECISION = 1e6;\n\n    // Convert a regular number to a Decimal\n    function fromNumber(uint256 value) internal pure returns (Decimal memory) {\n        return Decimal({ value: value * DECIMAL_PRECISION });\n    }\n\n    // Convert a Decimal to a regular number while keeping the remainder\n    function toNumber(Decimal memory d) internal pure returns (uint256, Decimal memory) {\n        return (d.value / DECIMAL_PRECISION, Decimal({ value: d.value % DECIMAL_PRECISION }));\n    }\n\n    // Floor division for Decimal\n    function floor(Decimal memory d) internal pure returns (uint256) {\n        return d.value / DECIMAL_PRECISION;\n    }\n\n    // Ceiling division for Decimal\n    function ceil(Decimal memory d) internal pure returns (uint256) {\n        return (d.value + DECIMAL_PRECISION - 1) / DECIMAL_PRECISION;\n    }\n\n    // Multiply two Decimals\n    function mul(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: (a.value * b.value) / DECIMAL_PRECISION });\n    }\n\n    // Multiply Decimal by a scalar\n    function mulScalar(Decimal memory a, uint256 scalar) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value * scalar });\n    }\n\n    // Divide two Decimals\n    function div(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: (a.value * DECIMAL_PRECISION) / b.value });\n    }\n\n    // Divide Decimal by a scalar\n    function divScalar(Decimal memory a, uint256 scalar) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value / scalar });\n    }\n\n    // Add two Decimals\n    function add(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value + b.value });\n    }\n\n    // Subtract two Decimals\n    function sub(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value - b.value });\n    }\n\n    // From ratio to Decimal\n    function fromRatio(uint256 num, uint256 denom) internal pure returns (Decimal memory) {\n        return Decimal({ value: (num * DECIMAL_PRECISION) / denom });\n    }\n\n    // > operator for Decimals\n    function gt(Decimal memory a, Decimal memory b) internal pure returns (bool) {\n        return a.value > b.value;\n    }\n\n    // < operator for Decimals\n    function lt(Decimal memory a, Decimal memory b) internal pure returns (bool) {\n        return a.value < b.value;\n    }\n}\n"
    },
    "contracts/lib/math/StreamMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../types/StreamTypes.sol\";\nimport \"./DecimalMath.sol\";\nimport \"../../types/PositionTypes.sol\";\n\nimport \"hardhat/console.sol\";\n\nlibrary StreamMathLib {\n    /**\n     * @dev Calculates the time difference ratio between current time and last updated time\n     * @param currentTimestamp Current timestamp\n     * @param streamStartTime Timestamp when the stream starts\n     * @param streamEndTime Timestamp when the stream ends\n     * @param lastUpdated Timestamp when the stream was last updated\n     * @return The ratio of time elapsed since last update compared to total remaining time (scaled by 1e18)\n     */\n    function calculateDiff(\n        uint256 currentTimestamp,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 lastUpdated\n    ) internal pure returns (Decimal memory) {\n        // If the stream is not started yet or already ended, return 0\n        if (currentTimestamp < streamStartTime || lastUpdated >= streamEndTime) {\n            return DecimalMath.fromNumber(0);\n        }\n\n        // If lastUpdated is before start time, set it to start time\n        uint256 effectiveLastUpdated = lastUpdated;\n        if (effectiveLastUpdated < streamStartTime) {\n            effectiveLastUpdated = streamStartTime;\n        }\n\n        // If current time is past end time, use end time instead\n        uint256 effectiveNow = currentTimestamp;\n        if (effectiveNow > streamEndTime) {\n            effectiveNow = streamEndTime;\n        }\n\n        uint256 numerator = effectiveNow - effectiveLastUpdated;\n        uint256 denominator = streamEndTime - effectiveLastUpdated;\n\n        if (denominator == 0 || numerator == 0) {\n            return DecimalMath.fromNumber(0);\n        }\n        // Return ratio of time elapsed since last update compared to total remaining time\n        return DecimalMath.fromRatio(numerator, denominator);\n    }\n\n    /**\n     * @dev Calculates the stream status based on the current state and timestamp\n     * @param currentStatus Current status of the stream\n     * @param currentTime Current timestamp to check against\n     * @param bootstrappingStartTime Timestamp when bootstrapping phase starts\n     * @param streamStartTime Timestamp when active streaming starts\n     * @param streamEndTime Timestamp when streaming ends\n     * @return IStreamTypes.Status The calculated stream status\n     */\n    function calculateStreamStatus(\n        StreamTypes.Status currentStatus,\n        uint256 currentTime,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime\n    ) internal pure returns (StreamTypes.Status) {\n        // Don't update if stream is in a final state\n        if (\n            currentStatus == StreamTypes.Status.Cancelled ||\n            currentStatus == StreamTypes.Status.FinalizedRefunded ||\n            currentStatus == StreamTypes.Status.FinalizedStreamed\n        ) {\n            return currentStatus;\n        }\n\n        // Update status based on current timestamp\n        if (currentTime < bootstrappingStartTime) {\n            return StreamTypes.Status.Waiting;\n        } else if (currentTime >= bootstrappingStartTime && currentTime < streamStartTime) {\n            return StreamTypes.Status.Bootstrapping;\n        } else if (currentTime >= streamStartTime && currentTime < streamEndTime) {\n            return StreamTypes.Status.Active;\n        } else if (currentTime >= streamEndTime) {\n            return StreamTypes.Status.Ended;\n        }\n\n        // This should never be reached, but return current status as fallback\n        return currentStatus;\n    }\n\n    /**\n     * @dev Calculates updated stream state based on time difference\n     * @param state Current stream state\n     * @param diff Time difference in seconds\n     * @return Updated stream state\n     */\n    function calculateUpdatedState(\n        StreamTypes.StreamState memory state,\n        Decimal memory diff\n    ) internal pure returns (StreamTypes.StreamState memory) {\n        // Create a copy of the state to avoid modifying the input\n        StreamTypes.StreamState memory newState = state;\n\n        if (newState.shares > 0 && diff.value > 0) {\n            // Calculate new distribution balance and spent in amount\n            Decimal memory newDecimalDistributionBalance = DecimalMath.mul(\n                DecimalMath.fromNumber(newState.outRemaining),\n                diff\n            );\n            uint256 newDistributionBalance = DecimalMath.floor(newDecimalDistributionBalance);\n\n            Decimal memory newDecimalSpentIn = DecimalMath.mul(DecimalMath.fromNumber(newState.inSupply), diff);\n            uint256 spentIn = DecimalMath.floor(newDecimalSpentIn);\n\n            // Update state variables\n            newState.spentIn += spentIn;\n            newState.inSupply -= spentIn;\n\n            if (newDistributionBalance > 0) {\n                newState.outRemaining -= newDistributionBalance;\n                // Increment distribution index\n                Decimal memory distIndexIncrementAmount = DecimalMath.fromRatio(\n                    newDistributionBalance,\n                    newState.shares\n                );\n                newState.distIndex = DecimalMath.add(newState.distIndex, distIndexIncrementAmount);\n                // Update current streamed price\n                newState.currentStreamedPrice = DecimalMath.fromRatio(spentIn, newDistributionBalance);\n            }\n        }\n        return newState;\n    }\n\n    function computeSharesAmount(\n        uint256 amountIn,\n        bool roundUp,\n        uint256 inSupply,\n        uint256 totalShares\n    ) internal pure returns (uint256) {\n        if (totalShares == 0 || amountIn == 0) {\n            return amountIn;\n        }\n\n        uint256 totalSharesIn = totalShares * amountIn;\n        if (roundUp) {\n            return (totalSharesIn + inSupply - 1) / inSupply;\n        } else {\n            return totalSharesIn / inSupply;\n        }\n    }\n\n    /**\n     * @dev Calculates the exit fee amount based on the spent in amount\n     * @param spentInAmount Amount of tokens spent in the stream\n     * @return exitFeeAmount The calculated fee amount\n     * @return remainingAmount The remaining amount after fee deduction\n     */\n    function calculateExitFee(\n        uint256 spentInAmount,\n        Decimal memory exitFeeRatio\n    ) internal pure returns (uint256 exitFeeAmount, uint256 remainingAmount) {\n        Decimal memory decimalSpentIn = DecimalMath.fromNumber(spentInAmount);\n\n        // Calculate exit fee amount using DecimalMath\n        Decimal memory decimalExitFeeAmount = DecimalMath.mul(decimalSpentIn, exitFeeRatio);\n        exitFeeAmount = DecimalMath.floor(decimalExitFeeAmount);\n        remainingAmount = spentInAmount - exitFeeAmount;\n\n        return (exitFeeAmount, remainingAmount);\n    }\n\n    function calculatePoolAmount(uint256 creatorRevenue, Decimal memory poolRatio) internal pure returns (uint256) {\n        Decimal memory decimalCreatorRevenue = DecimalMath.fromNumber(creatorRevenue);\n        Decimal memory decimalPoolAmount = DecimalMath.mul(decimalCreatorRevenue, poolRatio);\n        return DecimalMath.floor(decimalPoolAmount);\n    }\n\n    function syncPosition(\n        PositionTypes.Position memory position,\n        Decimal memory distIndex,\n        uint256 totalShares,\n        uint256 inSupply,\n        uint256 nowTime\n    ) internal pure returns (PositionTypes.Position memory) {\n        // Create a new position in memory to store the updated values\n        PositionTypes.Position memory updatedPosition = PositionTypes.Position({\n            inBalance: position.inBalance,\n            shares: position.shares,\n            index: position.index,\n            lastUpdateTime: position.lastUpdateTime,\n            pendingReward: position.pendingReward,\n            spentIn: position.spentIn,\n            purchased: position.purchased,\n            exitDate: position.exitDate\n        });\n\n        // Calculate index difference for distributions since last update\n        Decimal memory indexDiff = DecimalMath.sub(distIndex, updatedPosition.index);\n        uint256 spent = 0;\n        uint256 purchased = 0;\n\n        // Only process if there are shares in the stream\n        if (totalShares > 0) {\n            // Calculate purchased amount based on position shares and index difference\n            Decimal memory positionSharesDecimal = DecimalMath.fromNumber(updatedPosition.shares);\n            Decimal memory purchasedDecimal = DecimalMath.add(\n                DecimalMath.mul(positionSharesDecimal, indexDiff),\n                updatedPosition.pendingReward\n            );\n            (purchased, purchasedDecimal) = DecimalMath.toNumber(purchasedDecimal);\n            updatedPosition.purchased += purchased;\n            updatedPosition.pendingReward = purchasedDecimal;\n\n            // Calculate remaining balance based on current shares ratio\n            uint256 inRemaining = (inSupply * updatedPosition.shares) / totalShares;\n            // Calculate spent amount\n            spent = updatedPosition.inBalance - inRemaining;\n            updatedPosition.spentIn += spent;\n            updatedPosition.inBalance = inRemaining;\n        }\n\n        // Update position tracking\n        updatedPosition.index = distIndex;\n        updatedPosition.lastUpdateTime = nowTime;\n\n        return updatedPosition;\n    }\n\n    function calculateVestingSchedule(\n        uint256 nowTime,\n        uint256 cliffDuration,\n        uint256 vestingDuration\n    ) internal pure returns (uint256 cliffTime, uint256 endTime) {\n        cliffTime = nowTime + cliffDuration;\n        endTime = nowTime + vestingDuration;\n        return (cliffTime, endTime);\n    }\n}\n"
    },
    "contracts/mock/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\n\n    // Add the mint function\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/mock/StreamMathLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../lib/math/StreamMathLib.sol\";\nimport \"../types/StreamTypes.sol\";\nimport \"../types/PositionTypes.sol\";\nimport \"../lib/math/DecimalMath.sol\";\n\ncontract StreamMathLibMock {\n    function calculateDiff(\n        uint256 currentTimestamp,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 lastUpdated\n    ) external pure returns (Decimal memory) {\n        return StreamMathLib.calculateDiff(currentTimestamp, streamStartTime, streamEndTime, lastUpdated);\n    }\n\n    function calculateStreamStatus(\n        StreamTypes.Status currentStatus,\n        uint256 currentTime,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime\n    ) external pure returns (StreamTypes.Status) {\n        return\n            StreamMathLib.calculateStreamStatus(\n                currentStatus,\n                currentTime,\n                bootstrappingStartTime,\n                streamStartTime,\n                streamEndTime\n            );\n    }\n\n    function calculateUpdatedState(\n        StreamTypes.StreamState memory state,\n        Decimal memory diff\n    ) external pure returns (StreamTypes.StreamState memory) {\n        return StreamMathLib.calculateUpdatedState(state, diff);\n    }\n\n    function computeSharesAmount(\n        uint256 amountIn,\n        bool roundUp,\n        uint256 inSupply,\n        uint256 totalShares\n    ) external pure returns (uint256) {\n        return StreamMathLib.computeSharesAmount(amountIn, roundUp, inSupply, totalShares);\n    }\n\n    function calculateExitFee(\n        uint256 spentInAmount,\n        Decimal memory ExitFeeRatio\n    ) external pure returns (uint256 feeAmount, uint256 remainingAmount) {\n        return StreamMathLib.calculateExitFee(spentInAmount, ExitFeeRatio);\n    }\n\n    function syncPosition(\n        PositionTypes.Position memory position,\n        Decimal memory distIndex,\n        uint256 shares,\n        uint256 inSupply,\n        uint256 nowTime\n    ) external pure returns (PositionTypes.Position memory) {\n        return StreamMathLib.syncPosition(position, distIndex, shares, inSupply, nowTime);\n    }\n}\n"
    },
    "contracts/PoolWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./types/PoolWrapperTypes.sol\";\n\ncontract PoolWrapper is Ownable {\n    using SafeERC20 for IERC20;\n\n    // Mapping from stream address to pool info\n    mapping(address => PoolWrapperTypes.CreatedPoolInfo) public streamPools;\n\n    event PoolCreated(\n        address indexed stream,\n        address indexed pool,\n        address indexed poolWrapper,\n        address token0,\n        address token1,\n        uint256 token0Amount,\n        uint256 token1Amount\n    );\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Creates a pool and adds liquidity\n     * @param createPoolMsg The parameters for pool creation and liquidity addition\n     * Callable by anyone\n     */\n    function createPool(\n        PoolWrapperTypes.CreatePoolMsg calldata createPoolMsg\n    ) external returns (PoolWrapperTypes.CreatedPoolInfo memory) {\n        // TODO: Implement pool creation logic\n        // 1. Validate that the tokens are valid ERC20s\n        // 2. Validate that the tokens are not the same\n        // 3. Validate that the pool doesn't already exist\n        // 4. Validate that the tokens are sent to this contract\n        // 5. Create the pool\n        // 6. Add liquidity to the pool\n        // 7. Store the pool info\n\n        // For testing purposes only - remove this when implementing the TODOs above\n        address mockPoolAddress = address(\n            uint160(uint256(keccak256(abi.encodePacked(createPoolMsg.token0, createPoolMsg.token1, block.timestamp))))\n        );\n\n        // Create pool info\n        PoolWrapperTypes.CreatedPoolInfo memory poolInfo = PoolWrapperTypes.CreatedPoolInfo({\n            poolAddress: mockPoolAddress,\n            token0: createPoolMsg.token0,\n            token1: createPoolMsg.token1\n        });\n\n        // Store pool info\n        streamPools[msg.sender] = poolInfo;\n\n        // Emit event\n        emit PoolCreated(\n            msg.sender,\n            mockPoolAddress,\n            address(this),\n            createPoolMsg.token0,\n            createPoolMsg.token1,\n            createPoolMsg.amount0,\n            createPoolMsg.amount1\n        );\n\n        return poolInfo;\n    }\n\n    /**\n     * @notice Gets pool info for a stream\n     * @param stream The stream address\n     */\n    function getPoolInfo(address stream) external view returns (PoolWrapperTypes.CreatedPoolInfo memory) {\n        return streamPools[stream];\n    }\n}\n"
    },
    "contracts/storage/PositionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../types/PositionTypes.sol\";\nimport \"../lib/math/DecimalMath.sol\";\n\ncontract PositionStorage {\n    using PositionTypes for PositionTypes.Position;\n\n    mapping(address => PositionTypes.Position) private positions;\n    address public immutable streamContractAddress;\n\n    constructor(address _streamContractAddress) {\n        streamContractAddress = _streamContractAddress;\n    }\n\n    function getPosition(address _owner) external view returns (PositionTypes.Position memory) {\n        return positions[_owner];\n    }\n\n    modifier onlyStreamContract() {\n        require(msg.sender == streamContractAddress, \"Position can only be set by the stream contract\");\n        _;\n    }\n\n    function createPosition(\n        address owner,\n        uint256 inBalance,\n        uint256 shares,\n        Decimal memory index\n    ) external onlyStreamContract {\n        positions[owner] = PositionTypes.Position(\n            inBalance,\n            shares,\n            index,\n            block.timestamp,\n            DecimalMath.fromNumber(0),\n            0,\n            0,\n            0\n        );\n    }\n\n    function updatePosition(address owner, PositionTypes.Position memory position) external onlyStreamContract {\n        positions[owner] = position;\n    }\n\n    function setExitDate(address owner, uint256 exitDate) external onlyStreamContract {\n        positions[owner].exitDate = exitDate;\n    }\n}\n"
    },
    "contracts/Stream.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./interfaces/IPositionStorage.sol\";\nimport \"./types/PositionTypes.sol\";\nimport \"./interfaces/IStreamEvents.sol\";\nimport \"./interfaces/IStreamErrors.sol\";\nimport \"./types/StreamTypes.sol\";\nimport \"./StreamFactory.sol\";\nimport \"./types/StreamFactoryTypes.sol\";\nimport \"./lib/math/DecimalMath.sol\";\nimport \"./lib/math/StreamMathLib.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/helpers/TokenHelpers.sol\";\nimport \"./interfaces/IPoolWrapper.sol\";\nimport \"./interfaces/IVesting.sol\";\nimport \"./types/PoolWrapperTypes.sol\";\n\ncontract Stream is IStreamErrors, IStreamEvents {\n    address public creator;\n    address immutable streamFactoryAddress;\n    address public positionStorageAddress;\n    bool private initialized;\n\n    StreamTypes.StreamState public streamState;\n    StreamTypes.StreamTokens public streamTokens;\n    StreamTypes.StreamMetadata public streamMetadata;\n    StreamTypes.Status public streamStatus;\n    StreamTypes.StreamTimes public streamTimes;\n    StreamTypes.PostStreamActions public postStreamActions;\n\n    modifier onlyOnce() {\n        if (initialized) revert Unauthorized();\n        _;\n        initialized = true;\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != streamFactoryAddress) revert Unauthorized();\n        _;\n    }\n\n    constructor(address _streamFactoryAddress) {\n        streamFactoryAddress = _streamFactoryAddress;\n    }\n\n    function initialize(\n        StreamTypes.createStreamMessage memory createStreamMessage,\n        address _positionStorageAddress\n    ) external onlyOnce onlyAdmin {\n        // Validate that output token is a valid ERC20\n        if (!TokenHelpers.isValidERC20(createStreamMessage.outSupplyToken, msg.sender)) {\n            revert InvalidOutSupplyToken();\n        }\n        // Check if the contract has enough balance of output token\n        uint256 totalRequiredAmount = createStreamMessage.streamOutAmount +\n            createStreamMessage.poolInfo.poolOutSupplyAmount;\n        if (!TokenHelpers.hasEnoughBalance(createStreamMessage.outSupplyToken, address(this), totalRequiredAmount)) {\n            revert InsufficientOutAmount();\n        }\n        // Validate that in token is a valid ERC20\n        if (!TokenHelpers.isValidERC20(createStreamMessage.inSupplyToken, msg.sender)) {\n            revert InvalidInSupplyToken();\n        }\n        // Validate and set creator vesting info\n        if (createStreamMessage.creatorVesting.isVestingEnabled) {\n            // Validate vesting duration\n            if (createStreamMessage.creatorVesting.vestingDuration == 0) {\n                revert InvalidVestingDuration();\n            }\n            if (createStreamMessage.creatorVesting.cliffDuration == 0) {\n                revert InvalidVestingCliffDuration();\n            }\n            if (\n                createStreamMessage.creatorVesting.cliffDuration >= createStreamMessage.creatorVesting.vestingDuration\n            ) {\n                revert InvalidVestingCliffDuration();\n            }\n            // set vesting info\n            postStreamActions.creatorVesting = createStreamMessage.creatorVesting;\n        }\n        // Validate and set beneficiary vesting info\n        if (createStreamMessage.beneficiaryVesting.isVestingEnabled) {\n            // Validate vesting duration\n            if (createStreamMessage.beneficiaryVesting.vestingDuration == 0) {\n                revert InvalidVestingDuration();\n            }\n            if (createStreamMessage.beneficiaryVesting.cliffDuration == 0) {\n                revert InvalidVestingCliffDuration();\n            }\n            if (\n                createStreamMessage.beneficiaryVesting.cliffDuration >=\n                createStreamMessage.beneficiaryVesting.vestingDuration\n            ) {\n                revert InvalidVestingCliffDuration();\n            }\n            // set vesting info\n            postStreamActions.beneficiaryVesting = createStreamMessage.beneficiaryVesting;\n        }\n        // Validate pool config\n        if (createStreamMessage.poolInfo.poolOutSupplyAmount > 0) {\n            // Validate pool amount is less than or equal to out amount\n            if (createStreamMessage.poolInfo.poolOutSupplyAmount > createStreamMessage.streamOutAmount) {\n                revert InvalidAmount();\n            }\n            postStreamActions.poolInfo = createStreamMessage.poolInfo;\n        }\n        // Save position storage address\n        positionStorageAddress = _positionStorageAddress;\n        // Set creator\n        creator = createStreamMessage.creator;\n        // Initialize stream state\n        streamState = StreamTypes.StreamState({\n            distIndex: DecimalMath.fromNumber(0),\n            outRemaining: createStreamMessage.streamOutAmount,\n            inSupply: 0,\n            spentIn: 0,\n            shares: 0,\n            currentStreamedPrice: DecimalMath.fromNumber(0),\n            threshold: createStreamMessage.threshold,\n            outSupply: createStreamMessage.streamOutAmount,\n            lastUpdated: block.timestamp\n        });\n        // Initialize stream tokens\n        streamTokens = StreamTypes.StreamTokens({\n            inSupplyToken: createStreamMessage.inSupplyToken,\n            outSupplyToken: createStreamMessage.outSupplyToken\n        });\n        // Initialize stream metadata\n        streamMetadata = StreamTypes.StreamMetadata({ name: createStreamMessage.name });\n        // Initialize stream status\n        streamStatus = StreamTypes.Status.Waiting;\n        // Initialize stream times\n        streamTimes = StreamTypes.StreamTimes({\n            bootstrappingStartTime: createStreamMessage.bootstrappingStartTime,\n            streamStartTime: createStreamMessage.streamStartTime,\n            streamEndTime: createStreamMessage.streamEndTime\n        });\n    }\n\n    function syncStream(\n        StreamTypes.StreamState memory state,\n        StreamTypes.StreamTimes memory times,\n        uint256 nowTime\n    ) internal pure returns (StreamTypes.StreamState memory) {\n        Decimal memory diff = StreamMathLib.calculateDiff(\n            nowTime,\n            times.streamStartTime,\n            times.streamEndTime,\n            state.lastUpdated\n        );\n        state.lastUpdated = nowTime;\n\n        if (diff.value == 0) {\n            return state;\n        }\n\n        StreamTypes.StreamState memory updatedState = StreamMathLib.calculateUpdatedState(state, diff);\n        return updatedState;\n    }\n\n    function saveStreamState(StreamTypes.StreamState memory state) internal {\n        streamState = state;\n    }\n\n    function loadStreamState() internal view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    /**\n     * @dev Validates if an operation is allowed based on the current stream status\n     * @param allowedStatuses Array of allowed statuses for the operation\n     */\n    function isOperationAllowed(\n        StreamTypes.Status currentStatus,\n        StreamTypes.Status[] memory allowedStatuses\n    ) internal pure {\n        for (uint256 i = 0; i < allowedStatuses.length; i++) {\n            if (currentStatus == allowedStatuses[i]) {\n                return;\n            }\n        }\n        revert OperationNotAllowed();\n    }\n\n    /**\n     * @dev Checks if the threshold has been reached for stream finalization\n     * @return bool True if the threshold has been reached, false otherwise\n     */\n    function isThresholdReached(StreamTypes.StreamState memory state) internal pure returns (bool) {\n        return state.spentIn >= state.threshold;\n    }\n\n    /**\n     * @dev Validates a position exists and is active\n     * @param position The position to validate\n     * @return bool True if the position is valid and active\n     */\n    function isValidActivePosition(PositionTypes.Position memory position) internal pure returns (bool) {\n        return position.shares > 0 && position.exitDate == 0;\n    }\n\n    function withdraw(uint256 cap) external {\n        assertAmountNotZero(cap);\n        // Load position once\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n\n        // Check if position is valid and active\n        if (!isValidActivePosition(position)) {\n            revert InvalidPosition();\n        }\n\n        // load stream times\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        StreamTypes.Status[] memory allowedStatuses = new StreamTypes.Status[](2);\n        allowedStatuses[0] = StreamTypes.Status.Active;\n        allowedStatuses[1] = StreamTypes.Status.Bootstrapping;\n        isOperationAllowed(status, allowedStatuses);\n\n        // Save the updated status\n        saveStreamStatus(status);\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state, times, block.timestamp);\n\n        // Sync position with the updated state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // Check if withdrawal amount exceeds position balance\n        if (cap > position.inBalance) {\n            revert WithdrawAmountExceedsBalance(cap);\n        }\n\n        uint256 shareDeduction = 0;\n\n        if (cap == position.inBalance) {\n            shareDeduction = position.shares;\n        } else {\n            shareDeduction = StreamMathLib.computeSharesAmount(cap, true, state.inSupply, position.shares);\n        }\n\n        // Update position\n        position.shares = position.shares - shareDeduction;\n        position.inBalance = position.inBalance - cap;\n\n        // Update stream state\n        state.inSupply = state.inSupply - cap;\n        state.shares = state.shares - shareDeduction;\n\n        // Save everything at the end\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        // Token transfer\n        TokenHelpers.safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, cap);\n        emit Withdrawn(address(this), msg.sender, position.inBalance, position.shares, state.inSupply, state.shares);\n    }\n\n    function subscribe(uint256 amountIn) external payable {\n        assertAmountNotZero(amountIn);\n        // Load status once\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        // Update the loaded status\n        status = syncStreamStatus(status, times, block.timestamp);\n        // Check if operation is allowed with the updated status\n        StreamTypes.Status[] memory allowedStatuses = new StreamTypes.Status[](2);\n        allowedStatuses[0] = StreamTypes.Status.Bootstrapping;\n        allowedStatuses[1] = StreamTypes.Status.Active;\n        isOperationAllowed(status, allowedStatuses);\n        // Save the updated status\n        saveStreamStatus(status);\n\n        // Validate if sender has enough tokens\n        IERC20 streamInToken = IERC20(streamTokens.inSupplyToken);\n        uint256 streamInTokenBalance = streamInToken.balanceOf(msg.sender);\n        if (streamInTokenBalance < amountIn) {\n            revert InsufficientTokenPayment(amountIn, streamInTokenBalance);\n        }\n\n        // Transfer tokens from sender to this contract\n        bool success = streamInToken.transferFrom(msg.sender, address(this), amountIn);\n        if (!success) {\n            revert PaymentFailed();\n        }\n        // Load position once\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n\n        // Load stream state once\n        StreamTypes.StreamState memory state = loadStream();\n\n        // Update the stream state\n        state = syncStream(state);\n\n        uint256 newShares = 0;\n\n        if (position.shares == 0) {\n            // New position case\n            newShares = StreamMathLib.computeSharesAmount(amountIn, false, state.inSupply, state.shares);\n            position = PositionTypes.Position({\n                inBalance: amountIn,\n                shares: newShares,\n                index: state.distIndex,\n                lastUpdateTime: block.timestamp,\n                pendingReward: DecimalMath.fromNumber(0),\n                spentIn: 0,\n                purchased: 0,\n                exitDate: 0\n            });\n        } else {\n            // Update existing position\n            newShares = StreamMathLib.computeSharesAmount(amountIn, false, state.inSupply, state.shares);\n            position = StreamMathLib.syncPosition(\n                position,\n                state.distIndex,\n                state.shares,\n                state.inSupply,\n                block.timestamp\n            );\n            position.inBalance += amountIn;\n            position.shares += newShares;\n        }\n\n        // Update StreamState\n        state.inSupply += amountIn;\n        state.shares += newShares;\n\n        // Save everything once we're done modifying\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        // Emit event\n        emit Subscribed(address(this), msg.sender, amountIn, newShares, state.inSupply, state.shares);\n    }\n\n    function exitStream() external {\n        // Load position\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n\n        // Check if position is valid and active\n        if (!isValidActivePosition(position)) {\n            revert InvalidPosition();\n        }\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        // Sync position with updated state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        bool thresholdReached = isThresholdReached(state);\n\n        // Handle token distributions based on exit scenario\n        handleExitDistribution(status, thresholdReached, position, postStreamActions.beneficiaryVesting);\n\n        // Set exit date\n        position.exitDate = block.timestamp;\n\n        // Save everything\n        saveStreamStatus(status);\n        saveStream(state);\n        savePosition(msg.sender, position);\n    }\n\n    function handleExitDistribution(\n        StreamTypes.Status status,\n        bool thresholdReached,\n        PositionTypes.Position memory position,\n        StreamTypes.VestingInfo memory vestingInfo\n    ) internal {\n        // Case 1: Successful stream completion\n        if (isSuccessfulExit(status, thresholdReached)) {\n            // Return any unused input tokens\n            if (position.inBalance > 0) {\n                TokenHelpers.safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, position.inBalance);\n            }\n            if (vestingInfo.isVestingEnabled) {\n                // Distribute earned output tokens\n                uint256 amountToDistribute = position.purchased;\n                // Load factory params\n                StreamFactory factoryContract = StreamFactory(streamFactoryAddress);\n                StreamFactoryTypes.Params memory params = factoryContract.getParams();\n                address vestingContractAddress = params.vestingAddress;\n                IVesting vestingContract = IVesting(vestingContractAddress);\n                // Create vesting schedule\n                (uint256 cliffTime, uint256 endTime) = StreamMathLib.calculateVestingSchedule(\n                    block.timestamp,\n                    vestingInfo.cliffDuration,\n                    vestingInfo.vestingDuration\n                );\n                // Transfer tokens to vesting contract\n                TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, vestingContractAddress, amountToDistribute);\n                // Create vesting schedule\n                vestingContract.stakeFunds(\n                    msg.sender,\n                    streamTokens.outSupplyToken,\n                    cliffTime,\n                    endTime,\n                    amountToDistribute\n                );\n            } else {\n                // Direct transfer if vesting is not enabled\n                TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, msg.sender, position.purchased);\n            }\n            emit ExitStreamed(address(this), msg.sender, position.purchased, position.spentIn, block.timestamp);\n            return;\n        }\n\n        // Case 2: Refund scenario\n        if (isRefundExit(status, thresholdReached)) {\n            // Full refund of all input tokens (both spent and unspent)\n            uint256 totalRefund = position.inBalance + position.spentIn;\n            TokenHelpers.safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, totalRefund);\n            emit ExitRefunded(address(this), msg.sender, totalRefund, block.timestamp);\n            return;\n        }\n\n        // If neither condition is met, the exit is not allowed\n        revert InvalidExitCondition();\n    }\n\n    function isSuccessfulExit(StreamTypes.Status status, bool thresholdReached) internal pure returns (bool) {\n        return\n            (status == StreamTypes.Status.Ended && thresholdReached) ||\n            (status == StreamTypes.Status.FinalizedStreamed);\n    }\n\n    function isRefundExit(StreamTypes.Status status, bool thresholdReached) internal pure returns (bool) {\n        return\n            status == StreamTypes.Status.Cancelled ||\n            status == StreamTypes.Status.FinalizedRefunded ||\n            (status == StreamTypes.Status.Ended && !thresholdReached);\n    }\n\n    function deductExitFee(\n        Decimal memory exitFeeRatio,\n        address tokenAddress,\n        address feeCollector,\n        uint256 spentIn\n    ) internal returns (uint256, uint256) {\n        // Calculate exit fee\n        (uint256 feeAmount, uint256 creatorRevenue) = StreamMathLib.calculateExitFee(spentIn, exitFeeRatio);\n\n        // Transfer fee to fee collector if needed\n        if (feeAmount > 0) {\n            TokenHelpers.safeTokenTransfer(tokenAddress, feeCollector, feeAmount);\n        }\n        return (creatorRevenue, feeAmount);\n    }\n\n    function finalizeStream() external {\n        assertIsCreator();\n\n        // Get factory params\n        StreamFactory factoryContract = StreamFactory(streamFactoryAddress);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        StreamTypes.Status[] memory allowedStatuses = new StreamTypes.Status[](1);\n        allowedStatuses[0] = StreamTypes.Status.Ended;\n        isOperationAllowed(status, allowedStatuses);\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state, times, block.timestamp);\n\n        bool thresholdReached = isThresholdReached(state);\n\n        if (thresholdReached) {\n            address feeCollector = params.feeCollector;\n            Decimal memory exitFeeRatio = params.exitFeeRatio;\n\n            // Calculate exit fee\n            (uint256 creatorRevenue, uint256 feeAmount) = deductExitFee(\n                exitFeeRatio,\n                streamTokens.inSupplyToken,\n                feeCollector,\n                state.spentIn\n            );\n\n            // Handle pool creation if configured\n            if (postStreamActions.poolInfo.poolOutSupplyAmount > 0) {\n                // Calculate pool ratio\n                Decimal memory poolRatio = DecimalMath.div(\n                    DecimalMath.fromNumber(postStreamActions.poolInfo.poolOutSupplyAmount),\n                    DecimalMath.fromNumber(streamState.outSupply)\n                );\n\n                uint256 poolInSupplyAmount = StreamMathLib.calculatePoolAmount(creatorRevenue, poolRatio);\n                uint256 poolOutSupplyAmount = postStreamActions.poolInfo.poolOutSupplyAmount;\n                // Calculate remaining revenue\n                creatorRevenue = creatorRevenue - poolInSupplyAmount;\n\n                // Create pool and add liquidity\n                createPoolAndAddLiquidity(\n                    streamTokens.inSupplyToken,\n                    streamTokens.outSupplyToken,\n                    poolInSupplyAmount,\n                    poolOutSupplyAmount\n                );\n            }\n\n            // Handle vesting if enabled\n            if (postStreamActions.creatorVesting.isVestingEnabled) {\n                // Create vesting schedule\n                (uint256 cliffTime, uint256 endTime) = StreamMathLib.calculateVestingSchedule(\n                    block.timestamp,\n                    postStreamActions.creatorVesting.cliffDuration,\n                    postStreamActions.creatorVesting.vestingDuration\n                );\n                createVesting(\n                    streamTokens.inSupplyToken,\n                    creator,\n                    params.vestingAddress,\n                    creatorRevenue,\n                    cliffTime,\n                    endTime\n                );\n            } else {\n                // Transfer creator revenue to creator\n                TokenHelpers.safeTokenTransfer(streamTokens.inSupplyToken, creator, creatorRevenue);\n            }\n\n            // Update status\n            status = StreamTypes.Status.FinalizedStreamed;\n\n            // Refund out tokens to creator if left any\n            if (state.outRemaining > 0) {\n                TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, creator, state.outRemaining);\n            }\n\n            emit FinalizedStreamed(address(this), creator, creatorRevenue, feeAmount, state.outRemaining, status);\n        } else {\n            // Update status\n            status = StreamTypes.Status.FinalizedRefunded;\n\n            // Refund out tokens to creator\n            TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, creator, state.outSupply);\n\n            emit FinalizedRefunded(address(this), creator, state.outSupply, status);\n        }\n\n        // Save everything\n        saveStreamStatus(status);\n        saveStream(state);\n    }\n\n    function syncStreamExternal() external {\n        // Load, update and save stream state\n        StreamTypes.StreamState memory state = loadStream();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        state = syncStream(state, times, block.timestamp);\n        saveStream(state);\n\n        // Load, update and save status\n        StreamTypes.Status status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n        saveStreamStatus(status);\n\n        emit StreamSynced(\n            address(this),\n            state.lastUpdated,\n            uint8(status),\n            state.distIndex,\n            state.outRemaining,\n            state.inSupply,\n            state.spentIn,\n            state.currentStreamedPrice\n        );\n    }\n\n    function syncPosition(address user) external {\n        PositionTypes.Position memory position = loadPosition(user);\n        StreamTypes.StreamState memory state = loadStream();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        state = syncStream(state, times, block.timestamp);\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n        savePosition(user, position);\n        saveStream(state);\n        emit PositionSynced(address(this), user, position.inBalance, position.shares);\n    }\n\n    function cancelStream() external {\n        assertIsCreator();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        StreamTypes.Status[] memory allowedStatuses = new StreamTypes.Status[](1);\n        allowedStatuses[0] = StreamTypes.Status.Waiting;\n        isOperationAllowed(status, allowedStatuses);\n\n        // Refund out tokens to creator\n        TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, creator, streamState.outSupply);\n\n        // Update status\n        status = StreamTypes.Status.Cancelled;\n        saveStreamStatus(status);\n\n        emit StreamCancelled(address(this), creator, streamState.outSupply, status);\n    }\n\n    function cancelWithAdmin() external {\n        assertIsProtocolAdmin();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        StreamTypes.Status[] memory allowedStatuses = new StreamTypes.Status[](3);\n        allowedStatuses[0] = StreamTypes.Status.Waiting;\n        allowedStatuses[1] = StreamTypes.Status.Bootstrapping;\n        allowedStatuses[2] = StreamTypes.Status.Active;\n        isOperationAllowed(status, allowedStatuses);\n\n        // Refund out tokens to creator\n        TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, creator, streamState.outSupply);\n\n        // Update status\n        status = StreamTypes.Status.Cancelled;\n        saveStreamStatus(status);\n\n        emit StreamCancelled(address(this), creator, streamState.outSupply, status);\n    }\n\n    // Load helpers\n    function loadStream() internal view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    function loadStreamStatus() internal view returns (StreamTypes.Status) {\n        return streamStatus;\n    }\n\n    function loadPosition(address user) internal view returns (PositionTypes.Position memory) {\n        PositionStorage positionStorage = PositionStorage(positionStorageAddress);\n        return positionStorage.getPosition(user);\n    }\n\n    function loadStreamTimes() internal view returns (StreamTypes.StreamTimes memory) {\n        return streamTimes;\n    }\n\n    // Save helpers\n    function saveStream(StreamTypes.StreamState memory state) internal {\n        streamState = state;\n    }\n\n    function saveStreamStatus(StreamTypes.Status status) internal {\n        streamStatus = status;\n    }\n\n    function savePosition(address user, PositionTypes.Position memory position) internal {\n        PositionStorage positionStorage = PositionStorage(positionStorageAddress);\n        positionStorage.updatePosition(user, position);\n    }\n\n    // Refactored syncStream to work directly with a provided memory object\n    function syncStream(StreamTypes.StreamState memory state) internal view returns (StreamTypes.StreamState memory) {\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        Decimal memory diff = StreamMathLib.calculateDiff(\n            block.timestamp,\n            times.streamStartTime,\n            times.streamEndTime,\n            state.lastUpdated\n        );\n\n        if (diff.value > 0) {\n            state = StreamMathLib.calculateUpdatedState(state, diff);\n            state.lastUpdated = block.timestamp;\n        }\n\n        return state;\n    }\n\n    function createPoolAndAddLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    ) internal {\n        StreamFactory factoryContract = StreamFactory(streamFactoryAddress);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n\n        address poolWrapperAddress = params.poolWrapperAddress;\n        IPoolWrapper poolWrapper = IPoolWrapper(poolWrapperAddress);\n\n        PoolWrapperTypes.CreatePoolMsg memory createPoolMsg = PoolWrapperTypes.CreatePoolMsg({\n            token0: tokenA,\n            token1: tokenB,\n            amount0: amountADesired,\n            amount1: amountBDesired\n        });\n        poolWrapper.createPool(createPoolMsg);\n\n        // Transfer pool tokens to stream\n        TokenHelpers.safeTokenTransfer(tokenA, poolWrapperAddress, amountADesired);\n        TokenHelpers.safeTokenTransfer(tokenB, poolWrapperAddress, amountBDesired);\n    }\n\n    function createVesting(\n        address token,\n        address beneficiary,\n        address vestingAddress,\n        uint256 amount,\n        uint256 cliffDuration,\n        uint256 vestingDuration\n    ) internal {\n        IVesting vesting = IVesting(vestingAddress);\n        vesting.stakeFunds(token, beneficiary, cliffDuration, vestingDuration, amount);\n    }\n\n    // Refactored syncStreamStatus to work directly with a provided memory object\n    function syncStreamStatus(\n        StreamTypes.Status status,\n        StreamTypes.StreamTimes memory times,\n        uint256 nowTime\n    ) internal pure returns (StreamTypes.Status) {\n        status = StreamMathLib.calculateStreamStatus(\n            status,\n            nowTime,\n            times.bootstrappingStartTime,\n            times.streamStartTime,\n            times.streamEndTime\n        );\n\n        return status;\n    }\n\n    /**\n     * @dev Ensure value is non-zero\n     * @param value The value to check\n     * @param errorMessage The error message to revert with\n     */\n    function assertNonZero(uint256 value, string memory errorMessage) internal pure {\n        if (value == 0) revert(errorMessage);\n    }\n\n    /**\n     * @dev Ensure sender is the creator\n     */\n    function assertIsCreator() internal view {\n        if (msg.sender != creator) revert Unauthorized();\n    }\n\n    /**\n     * @dev Ensure sender is the protocol admin\n     */\n    function assertIsProtocolAdmin() internal view {\n        StreamFactory factoryContract = StreamFactory(streamFactoryAddress);\n        address protocolAdmin = factoryContract.getParams().protocolAdmin;\n        if (msg.sender != protocolAdmin) revert Unauthorized();\n    }\n\n    /**\n     * @dev Ensure status matches expected value\n     * @param status Current status to check\n     * @param expectedStatus Status that is expected\n     */\n    function assertStatus(StreamTypes.Status status, StreamTypes.Status expectedStatus) internal pure {\n        if (status != expectedStatus) revert OperationNotAllowed();\n    }\n\n    /**\n     * @dev Ensure amount is not zero\n     * @param amount Amount to check\n     */\n    function assertAmountNotZero(uint256 amount) internal pure {\n        if (amount == 0) revert InvalidAmount();\n    }\n\n    /**\n     * @dev Assert that the cap does not exceed balance\n     * @param cap Amount to withdraw\n     * @param balance Available balance\n     */\n    function assertWithinBalance(uint256 cap, uint256 balance) internal pure {\n        if (cap > balance) revert WithdrawAmountExceedsBalance(cap);\n    }\n\n    /**\n     * @dev Get the current stream status\n     * @return The current stream status\n     */\n    function getStreamStatus() external view returns (StreamTypes.Status) {\n        return streamStatus;\n    }\n\n    /**\n     * @dev Get the current stream state\n     * @return The current stream state\n     */\n    function getStreamState() external view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    function getPosition(address user) external view returns (PositionTypes.Position memory) {\n        PositionStorage positionStorage = PositionStorage(positionStorageAddress);\n        return positionStorage.getPosition(user);\n    }\n}\n"
    },
    "contracts/StreamFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\nimport \"./interfaces/IStreamEvents.sol\";\nimport \"./interfaces/IStreamFactoryErrors.sol\";\nimport \"./types/StreamTypes.sol\";\nimport \"./interfaces/IStream.sol\";\nimport \"./types/StreamFactoryTypes.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./storage/PositionStorage.sol\";\nimport \"./interfaces/IERC20.sol\";\n\ncontract StreamFactory is IStreamEvents, IStreamFactoryErrors {\n    // Storage optimization: Pack related variables together\n    bool public frozen;\n    bool public initialized;\n    uint16 public currentStreamId;\n    address public constant NATIVE_TOKEN = address(0);\n\n    StreamFactoryTypes.Params public params;\n\n    // Maps for lookups\n    mapping(uint16 => address) public streamAddresses;\n    mapping(address => bool) public acceptedInSupplyTokens;\n\n    constructor(address _protocolAdmin) {\n        if (_protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        params.protocolAdmin = _protocolAdmin;\n    }\n\n    modifier onlyOnce() {\n        if (initialized) revert(\"Already initialized\");\n        initialized = true;\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != params.protocolAdmin) revert NotAdmin();\n        _;\n    }\n\n    function initialize(\n        StreamFactoryTypes.initializeStreamMessage memory initializeStreamMessage\n    ) external onlyAdmin onlyOnce {\n        if (DecimalMath.gt(initializeStreamMessage.exitFeeRatio, DecimalMath.fromNumber(1)))\n            revert InvalidExitFeeRatio();\n\n        // Removed vesting contract deployment to save gas\n        address vesting = address(0);\n        emit VestingContractDeployed(address(this), vesting);\n\n        // Use unchecked for gas optimization where overflow is impossible\n        unchecked {\n            params.streamCreationFee = initializeStreamMessage.streamCreationFee;\n            params.streamCreationFeeToken = initializeStreamMessage.streamCreationFeeToken;\n            params.exitFeeRatio = initializeStreamMessage.exitFeeRatio;\n            params.minWaitingDuration = initializeStreamMessage.minWaitingDuration;\n            params.minBootstrappingDuration = initializeStreamMessage.minBootstrappingDuration;\n            params.minStreamDuration = initializeStreamMessage.minStreamDuration;\n            params.feeCollector = initializeStreamMessage.feeCollector;\n            params.tosVersion = initializeStreamMessage.tosVersion;\n            params.vestingAddress = vesting;\n            params.poolWrapperAddress = initializeStreamMessage.poolWrapperAddress;\n            params.streamImplementationAddress = initializeStreamMessage.streamImplementationAddress;\n        }\n\n        // Set accepted tokens\n        uint256 length = initializeStreamMessage.acceptedInSupplyTokens.length;\n        for (uint256 i; i < length; ) {\n            acceptedInSupplyTokens[initializeStreamMessage.acceptedInSupplyTokens[i]] = true;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function createStream(StreamTypes.createStreamMessage memory createStreamMessage) external payable {\n        if (frozen) revert ContractFrozen();\n        if (createStreamMessage.streamOutAmount == 0) revert ZeroOutSupplyNotAllowed();\n        if (!acceptedInSupplyTokens[createStreamMessage.inSupplyToken]) revert StreamInputTokenNotAccepted();\n\n        validateStreamTimes(\n            block.timestamp,\n            createStreamMessage.bootstrappingStartTime,\n            createStreamMessage.streamStartTime,\n            createStreamMessage.streamEndTime\n        );\n\n        if (\n            keccak256(abi.encodePacked(createStreamMessage.tosVersion)) !=\n            keccak256(abi.encodePacked(params.tosVersion))\n        ) revert InvalidToSVersion();\n\n        uint256 creationFee = params.streamCreationFee;\n        if (creationFee > 0) {\n            if (params.streamCreationFeeToken == address(0)) {\n                if (msg.value < creationFee) revert InsufficientNativeToken();\n                (bool success, ) = params.feeCollector.call{ value: creationFee }(\"\");\n                if (!success) revert FeeTransferFailed();\n            } else {\n                if (!IERC20(params.streamCreationFeeToken).transferFrom(msg.sender, params.feeCollector, creationFee))\n                    revert TokenTransferFailed();\n            }\n        }\n\n        // Clone and initialize stream\n        address clone = Clones.clone(params.streamImplementationAddress);\n        IStream stream = IStream(clone);\n\n        PositionStorage positionStorage = new PositionStorage(clone);\n\n        if (\n            !IERC20(createStreamMessage.outSupplyToken).transferFrom(\n                msg.sender,\n                clone,\n                createStreamMessage.streamOutAmount + createStreamMessage.poolInfo.poolOutSupplyAmount\n            )\n        ) revert TokenTransferFailed();\n\n        stream.initialize(createStreamMessage, address(positionStorage));\n\n        uint16 streamId = currentStreamId;\n        streamAddresses[streamId] = clone;\n\n        emit StreamCreated(\n            createStreamMessage.outSupplyToken,\n            createStreamMessage.inSupplyToken,\n            address(this),\n            createStreamMessage.streamOutAmount,\n            createStreamMessage.bootstrappingStartTime,\n            createStreamMessage.streamStartTime,\n            createStreamMessage.streamEndTime,\n            createStreamMessage.threshold,\n            createStreamMessage.name,\n            params.tosVersion,\n            clone,\n            streamId\n        );\n\n        unchecked {\n            ++currentStreamId;\n        }\n    }\n\n    function updateParams(\n        uint256 _streamCreationFee,\n        Decimal memory _exitFeeRatio,\n        uint256 _minWaitingDuration,\n        uint256 _minBootstrappingDuration,\n        uint256 _minStreamDuration,\n        string memory _tosVersion\n    ) external onlyAdmin {\n        params.streamCreationFee = _streamCreationFee;\n        params.exitFeeRatio = _exitFeeRatio;\n        params.minWaitingDuration = _minWaitingDuration;\n        params.minBootstrappingDuration = _minBootstrappingDuration;\n        params.minStreamDuration = _minStreamDuration;\n        params.tosVersion = _tosVersion;\n\n        emit ParamsUpdated(\n            address(this),\n            _streamCreationFee,\n            _exitFeeRatio.value,\n            _minWaitingDuration,\n            _minBootstrappingDuration,\n            _minStreamDuration,\n            _tosVersion\n        );\n    }\n\n    function updateFeeCollector(address _feeCollector) external onlyAdmin {\n        if (_feeCollector == address(0)) revert InvalidFeeCollector();\n        params.feeCollector = _feeCollector;\n        emit FeeCollectorUpdated(address(this), _feeCollector);\n    }\n\n    function updateProtocolAdmin(address _protocolAdmin) external onlyAdmin {\n        if (_protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        params.protocolAdmin = _protocolAdmin;\n        emit ProtocolAdminUpdated(address(this), _protocolAdmin);\n    }\n\n    function updateAcceptedTokens(\n        address[] calldata tokens_to_add,\n        address[] calldata tokens_to_remove\n    ) external onlyAdmin {\n        for (uint i = 0; i < tokens_to_add.length; i++) {\n            acceptedInSupplyTokens[tokens_to_add[i]] = true;\n        }\n        for (uint i = 0; i < tokens_to_remove.length; i++) {\n            acceptedInSupplyTokens[tokens_to_remove[i]] = false;\n        }\n        emit AcceptedTokensUpdated(address(this), tokens_to_add, tokens_to_remove);\n    }\n\n    function updatePoolWrapper(address _poolWrapper) external onlyAdmin {\n        if (_poolWrapper == address(0)) revert InvalidPoolWrapper();\n        params.poolWrapperAddress = _poolWrapper;\n        emit PoolWrapperUpdated(address(this), _poolWrapper);\n    }\n\n    function getStreams() external view returns (address[] memory) {\n        address[] memory streams = new address[](currentStreamId);\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            streams[i] = streamAddresses[i];\n        }\n        return streams;\n    }\n\n    function getStream(uint16 _streamId) external view returns (address) {\n        return streamAddresses[_streamId];\n    }\n\n    function isStream(address _streamAddress) external view returns (bool) {\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            if (streamAddresses[i] == _streamAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getParams() external view returns (StreamFactoryTypes.Params memory) {\n        return params;\n    }\n\n    function isAcceptedInSupplyToken(address token) public view returns (bool) {\n        return acceptedInSupplyTokens[token];\n    }\n\n    function getAcceptedInSupplyTokens() external view returns (address[] memory) {\n        address[] memory tokens = new address[](currentStreamId);\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            if (acceptedInSupplyTokens[streamAddresses[i]]) {\n                tokens[i] = streamAddresses[i];\n            }\n        }\n        return tokens;\n    }\n\n    function setFrozen(bool _frozen) external onlyAdmin {\n        frozen = _frozen;\n        emit FrozenStateUpdated(address(this), _frozen);\n    }\n\n    function validateStreamTimes(\n        uint256 nowTime,\n        uint256 _bootstrappingStartTime,\n        uint256 _startTime,\n        uint256 _endTime\n    ) internal view {\n        if (nowTime > _bootstrappingStartTime) revert InvalidBootstrappingStartTime();\n        if (_bootstrappingStartTime > _startTime) revert InvalidStreamStartTime();\n        if (_startTime > _endTime) revert InvalidStreamEndTime();\n        if (_endTime - _startTime < params.minStreamDuration) revert StreamDurationTooShort();\n        if (_startTime - _bootstrappingStartTime < params.minBootstrappingDuration)\n            revert BootstrappingDurationTooShort();\n        if (_bootstrappingStartTime - nowTime < params.minWaitingDuration) revert WaitingDurationTooShort();\n    }\n\n    function setImplementation(address _implementation) external onlyAdmin {\n        if (_implementation == address(0)) revert InvalidImplementationAddress();\n\n        params.streamImplementationAddress = _implementation;\n    }\n\n    function setStreamCreationFee(uint256 _fee) external onlyAdmin {\n        params.streamCreationFee = _fee;\n    }\n\n    function setStreamCreationFeeToken(address _token) external onlyAdmin {\n        params.streamCreationFeeToken = _token;\n    }\n\n    function setExitFeeRatio(Decimal memory _ratio) external onlyAdmin {\n        if (DecimalMath.gt(_ratio, DecimalMath.fromNumber(1))) revert InvalidExitFeeRatio();\n        params.exitFeeRatio = _ratio;\n    }\n}\n"
    },
    "contracts/types/PoolWrapperTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nlibrary PoolWrapperTypes {\n    struct CreatePoolMsg {\n        address token0;\n        address token1;\n        uint256 amount0;\n        uint256 amount1;\n    }\n\n    struct CreatedPoolInfo {\n        address poolAddress;\n        address token0;\n        address token1;\n    }\n}\n"
    },
    "contracts/types/PositionTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../lib/math/DecimalMath.sol\";\n\nlibrary PositionTypes {\n    struct Position {\n        uint256 inBalance;\n        uint256 shares;\n        Decimal index;\n        uint256 lastUpdateTime;\n        Decimal pendingReward;\n        uint256 spentIn;\n        uint256 purchased;\n        uint256 exitDate;\n    }\n}\n"
    },
    "contracts/types/StreamFactoryTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../lib/math/DecimalMath.sol\";\n\nlibrary StreamFactoryTypes {\n    struct Params {\n        uint256 streamCreationFee;\n        address streamCreationFeeToken;\n        Decimal exitFeeRatio;\n        uint256 minWaitingDuration;\n        uint256 minBootstrappingDuration;\n        uint256 minStreamDuration;\n        address feeCollector;\n        address protocolAdmin;\n        string tosVersion;\n        address vestingAddress;\n        address poolWrapperAddress;\n        address streamImplementationAddress;\n    }\n\n    struct initializeStreamMessage {\n        uint256 streamCreationFee;\n        address streamCreationFeeToken;\n        Decimal exitFeeRatio;\n        uint256 minWaitingDuration;\n        uint256 minBootstrappingDuration;\n        uint256 minStreamDuration;\n        address feeCollector;\n        address protocolAdmin;\n        string tosVersion;\n        address poolWrapperAddress;\n        address[] acceptedInSupplyTokens;\n        address streamImplementationAddress;\n    }\n}\n"
    },
    "contracts/types/StreamTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../lib/math/DecimalMath.sol\";\n\nlibrary StreamTypes {\n    enum Status {\n        Waiting,\n        Bootstrapping,\n        Active,\n        Ended,\n        FinalizedRefunded,\n        FinalizedStreamed,\n        Cancelled\n    }\n\n    struct createStreamMessage {\n        uint256 streamOutAmount;\n        address outSupplyToken;\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n        uint256 threshold;\n        string name;\n        address inSupplyToken;\n        address creator;\n        VestingInfo creatorVesting;\n        VestingInfo beneficiaryVesting;\n        PoolInfo poolInfo;\n        bytes32 salt;\n        string tosVersion;\n    }\n    struct StreamTimes {\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n    }\n\n    struct StreamMetadata {\n        string name;\n    }\n\n    struct StreamState {\n        uint256 outRemaining;\n        Decimal distIndex;\n        uint256 spentIn;\n        uint256 shares;\n        Decimal currentStreamedPrice;\n        uint256 threshold;\n        uint256 inSupply;\n        uint256 outSupply;\n        uint256 lastUpdated;\n    }\n\n    struct StreamTokens {\n        address inSupplyToken;\n        address outSupplyToken;\n    }\n\n    struct VestingInfo {\n        bool isVestingEnabled;\n        uint16 vestingDuration;\n        uint16 cliffDuration;\n    }\n\n    struct PoolInfo {\n        uint256 poolOutSupplyAmount;\n    }\n\n    struct PostStreamActions {\n        PoolInfo poolInfo;\n        VestingInfo creatorVesting;\n        VestingInfo beneficiaryVesting;\n    }\n}\n"
    },
    "contracts/Vesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./interfaces/IERC20.sol\";\n\ncontract Vesting {\n    struct VestingSchedule {\n        uint256 cliffTime;\n        uint256 endTime;\n        uint256 totalAmount;\n        uint256 releasedAmount;\n    }\n\n    mapping(address => mapping(address => VestingSchedule[])) private tokenVestings;\n\n    event FundsStaked(\n        address indexed beneficiary,\n        address indexed token,\n        uint256 totalAmount,\n        uint256 cliffTime,\n        uint256 endTime\n    );\n\n    event FundsWithdrawn(address indexed beneficiary, address indexed token, uint256 scheduleIndex, uint256 amount);\n\n    function stakeFunds(\n        address beneficiary,\n        address tokenAddress,\n        uint256 cliffTime,\n        uint256 endTime,\n        uint256 totalAmount\n    ) external {\n        require(cliffTime >= block.timestamp, \"Cliff time must be in the future\");\n        require(endTime > cliffTime, \"End time must be after cliff time\");\n        require(totalAmount > 0, \"Total amount must be greater than zero\");\n\n        require(IERC20(tokenAddress).transferFrom(msg.sender, address(this), totalAmount), \"Token transfer failed\");\n\n        VestingSchedule[] storage vestingSchedules = tokenVestings[beneficiary][tokenAddress];\n        vestingSchedules.push(VestingSchedule(cliffTime, endTime, totalAmount, 0));\n\n        emit FundsStaked(beneficiary, tokenAddress, totalAmount, cliffTime, endTime);\n    }\n\n    function withdrawFunds(address tokenAddress, uint256 scheduleIndex) external {\n        VestingSchedule[] storage vestingSchedules = tokenVestings[msg.sender][tokenAddress];\n        require(scheduleIndex < vestingSchedules.length, \"Invalid schedule index\");\n\n        VestingSchedule storage vestingSchedule = vestingSchedules[scheduleIndex];\n        require(vestingSchedule.cliffTime <= block.timestamp, \"Funds are still in the cliff period\");\n\n        uint256 withdrawableAmount = calculateWithdrawableAmount(vestingSchedule);\n        require(withdrawableAmount > 0, \"No funds available for withdrawal\");\n\n        vestingSchedule.releasedAmount += withdrawableAmount;\n\n        require(IERC20(tokenAddress).transfer(msg.sender, withdrawableAmount), \"Token transfer failed\");\n\n        emit FundsWithdrawn(msg.sender, tokenAddress, scheduleIndex, withdrawableAmount);\n\n        if (vestingSchedule.releasedAmount == vestingSchedule.totalAmount) {\n            delete vestingSchedules[scheduleIndex];\n        }\n    }\n\n    function getStakesForBeneficiary(\n        address beneficiary,\n        address tokenAddress\n    ) external view returns (VestingSchedule[] memory) {\n        return tokenVestings[beneficiary][tokenAddress];\n    }\n\n    function calculateWithdrawableAmount(VestingSchedule storage vestingSchedule) private view returns (uint256) {\n        uint256 elapsedTime = block.timestamp - vestingSchedule.cliffTime;\n\n        if (elapsedTime >= vestingSchedule.endTime - vestingSchedule.cliffTime) {\n            // Can now access all of the funds minus any that have already been claimed\n            return vestingSchedule.totalAmount - vestingSchedule.releasedAmount;\n        } else {\n            // Calculate what proportion of funds is now available and only return that amount\n\n            // How long is the unlock period\n            uint256 totalUnlockPeriod = vestingSchedule.endTime - vestingSchedule.cliffTime;\n\n            // How much should have been unlocked so far\n            uint256 totalAmountAccessible = (vestingSchedule.totalAmount / totalUnlockPeriod) * elapsedTime;\n\n            // Amount available to withdraw is the currently unlocked amount minus anything\n            // that has already been claimed to prevent repeat counting funds\n            uint256 actualAccessible = totalAmountAccessible - vestingSchedule.releasedAmount;\n\n            return actualAccessible;\n        }\n    }\n\n    function getBlockTime() external view returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}