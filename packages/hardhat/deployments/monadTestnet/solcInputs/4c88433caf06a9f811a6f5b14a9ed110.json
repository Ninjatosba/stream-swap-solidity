{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    },
    "src/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title IPermit2\n * @notice Minimal interface for Uniswap Permit2 used by Stream contract\n * @dev We only include the single-permit allowance flow (PermitSingle) and basic transferFrom\n *      as those are sufficient for subscribeWithPermit. Additional Permit2 functions can be\n *      added later if the protocol needs them.\n */\ninterface IPermit2 {\n    /// @notice Data for a single token allowance\n    struct PermitDetails {\n        address token;       // ERC20 token address\n        uint160 amount;      // allowance amount\n        uint48 expiration;   // timestamp at which allowance expires\n        uint48 nonce;        // unique nonce to prevent replay\n    }\n\n    /// @notice Full permit message for a single token allowance\n    struct PermitSingle {\n        PermitDetails details; // allowance details\n        address spender;       // address being approved to spend the tokens\n        uint256 sigDeadline;   // deadline for the signature (timestamp)\n    }\n\n    /**\n     * @notice Approve token allowance via EIP-712 signature\n     * @param owner The owner of the tokens and signer of the permit\n     * @param permitSingle Full permit data\n     * @param signature Signature over the permit data\n     */\n    function permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature) external;\n\n    /**\n     * @notice Transfer tokens using an existing Permit2 allowance\n     * @param from Token owner\n     * @param to Recipient\n     * @param amount Amount to transfer (uint160 per Permit2 spec)\n     * @param token ERC20 token address\n     */\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n} "
    },
    "src/interfaces/IPoolRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { StreamTypes } from \"../types/StreamTypes.sol\";\nimport { PoolWrapperTypes } from \"../types/PoolWrapperTypes.sol\";\nimport { PoolRouterTypes } from \"../types/PoolRouterTypes.sol\";\n\ninterface IPoolRouter {\n    // Admin\n    function setWrapper(StreamTypes.DexType dex, uint256 key, address wrapper) external;\n    function getWrapper(StreamTypes.DexType dex, uint256 key) external view returns (address);\n\n    // Factory-time validation\n    function validatePoolParams(StreamTypes.PoolInfo calldata info) external view;\n\n    // Stream-time execution\n    function createPool(PoolRouterTypes.CreatePoolRequest calldata req)\n        external\n        returns (PoolWrapperTypes.CreatedPoolInfo memory);\n}\n\n\n"
    },
    "src/interfaces/IPoolWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { PoolWrapperTypes } from \"../types/PoolWrapperTypes.sol\";\n\ninterface IPoolWrapper {\n    function createPool(\n        PoolWrapperTypes.CreatePoolMsg calldata createPoolMsg\n    ) external returns (PoolWrapperTypes.CreatedPoolInfo memory);\n\n    function getPoolInfo(address stream) external view returns (PoolWrapperTypes.CreatedPoolInfo memory);\n}\n"
    },
    "src/interfaces/IPoolWrapperErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title IPoolWrapperErrors\n * @dev Interface for custom errors used in the PoolWrapper contract\n */\ninterface IPoolWrapperErrors {\n    error InvalidAddress();\n    error InvalidAmount();\n    error InsufficientBalance();\n    error PoolCreationFailed();\n    error DifferentTokensRequired();\n} "
    },
    "src/interfaces/IPositionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { PositionTypes } from \"../types/PositionTypes.sol\";\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\ninterface IPositionStorage {\n    function getPosition(address _owner) external view returns (PositionTypes.Position memory);\n\n    function createPosition(address owner, uint256 inBalance, uint256 shares, Decimal memory index) external;\n\n    function updatePosition(address owner, PositionTypes.Position memory position) external;\n\n    function setExitDate(address owner, uint256 exitDate) external;\n}\n"
    },
    "src/interfaces/IStreamErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IStreamErrors {\n    // Stream errors\n    error InsufficientTokenPayment(uint256 requiredTokenAmount, uint256 tokenBalance);\n    error InvalidOutSupplyToken();\n    error InvalidInSupplyToken();\n    error PaymentFailed();\n    error OperationNotAllowed();\n    error Unauthorized();\n    error InvalidWithdrawAmount();\n    error WithdrawAmountExceedsBalance(uint256 cap);\n    error InsufficientOutAmount();\n    error InvalidPosition(address user, uint256 shares, uint256 exitDate, string reason);\n    error InvalidExitCondition();\n    error InvalidVestingDuration();\n    error InvalidVestingCliffDuration();\n    error InvalidPoolOutSupplyAmount();\n    error InvalidPoolType();\n    error InvalidAmount();\n    error StreamFactoryAddressAlreadySet();\n    error InvalidStreamFactoryAddress();\n    error InvalidPositionStorageAddress();\n    error InvalidImplementationAddress();\n    error InvalidInputToken();\n    error SameInputAndOutputToken();\n    error InvalidDexType();\n}\n"
    },
    "src/interfaces/IStreamEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IStreamEvents {\n    event StreamStateUpdated(\n        address indexed streamAddress,\n        uint256 lastUpdated,\n        uint256 distIndex,\n        uint256 outRemaining,\n        uint256 inSupply,\n        uint256 spentIn,\n        uint256 currentStreamedPrice\n    );\n\n    event Subscribed(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 positionInBalance,\n        uint256 positionShares,\n        uint256 positionLastUpdateTime,\n        uint256 positionSpentIn,\n        uint256 positionPurchased,\n        uint256 positionIndex,\n        uint256 streamInSupply,\n        uint256 streamShares\n    );\n\n    event StreamSynced(\n        address indexed streamAddress,\n        uint256 lastUpdated,\n        uint8 newStatus,\n        uint256 distIndex,\n        uint256 outRemaining,\n        uint256 inSupply,\n        uint256 spentIn,\n        uint256 currentStreamedPrice\n    );\n\n    event PositionSynced(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 positionInBalance,\n        uint256 positionShares,\n        uint256 positionLastUpdateTime,\n        uint256 positionSpentIn,\n        uint256 positionPurchased,\n        uint256 positionIndex\n    );\n\n    event Withdrawn(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 positionInBalance,\n        uint256 positionShares,\n        uint256 positionLastUpdateTime,\n        uint256 positionSpentIn,\n        uint256 positionPurchased,\n        uint256 positionIndex,\n        uint256 streamInSupply,\n        uint256 streamShares\n    );\n\n    event ExitRefunded(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 inBalance,\n        uint256 spentIn,\n        uint256 exitTimestamp\n    );\n    event ExitStreamed(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 purchased,\n        uint256 spentIn,\n        uint256 index,\n        uint256 inBalance,\n        uint256 exitTimestamp\n    );\n\n    event FinalizedStreamed(\n        address indexed streamAddress,\n        address indexed creator,\n        uint256 creatorRevenue,\n        uint256 exitFeeAmount,\n        uint256 refundedOutAmount\n    );\n\n    event FinalizedRefunded(address indexed streamAddress, address indexed creator, uint256 refundedOutAmount);\n\n    event StreamCancelled(address indexed streamAddress, address creator, uint256 outSupply, uint8 status);\n\n    event StreamMetadataUpdated(address indexed streamAddress, string metadataIpfsHash);\n\n    event CreatorVestingCreated(address indexed creator, address vestingAddress, uint256 vestingDuration, address token, uint256 amount);\n\n    event BeneficiaryVestingCreated(address indexed beneficiary, address vestingAddress, uint64 vestingDuration, address token, uint256 amount);\n\n    event PoolCreated(\n        address indexed streamAddress,\n        address indexed poolAddress,\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 refundedAmount0,\n        uint256 refundedAmount1,\n        address indexed creator\n    );\n}\n"
    },
    "src/interfaces/IStreamFactoryParams.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { StreamFactoryTypes } from \"../types/StreamFactoryTypes.sol\";\n\n/**\n * @title IStreamFactoryParams\n * @notice Minimal interface to read factory params without importing a concrete factory\n */\ninterface IStreamFactoryParams {\n    function getParams() external view returns (StreamFactoryTypes.Params memory);\n}\n\n\n"
    },
    "src/interfaces/IUniswapV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IUniswapV3Factory {\n    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool);\n    function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);\n}\n\ninterface IUniswapV3Pool {\n    function initialize(uint160 sqrtPriceX96) external;\n\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n}\n\ninterface INonfungiblePositionManager {\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n}\n\n\n"
    },
    "src/interfaces/IVestingFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title IVestingFactory\n * @dev Interface for the VestingFactory contract that creates OpenZeppelin VestingWallet instances\n */\ninterface IVestingFactory {\n    /**\n     * @dev Creates a VestingWallet and transfers tokens to it in one transaction\n     * @param beneficiary address of the beneficiary\n     * @param startTime the time (as Unix time) at which point vesting begins\n     * @param duration duration in seconds of the period in which the tokens will vest\n     * @param token the token to transfer to the vesting wallet (zero address for native token)\n     * @param amount the amount of tokens to transfer\n     * @return vestingWallet the address of the created VestingWallet\n     * @notice When token is address(0), native tokens are sent via msg.value. For ERC20 tokens, \n     *         the caller must approve this contract first.\n     */\n    function createVestingWalletWithTokens(\n        address beneficiary,\n        uint64 startTime,\n        uint64 duration,\n        address token,\n        uint256 amount\n    ) external payable returns (address vestingWallet);\n\n    /**\n     * @dev Event emitted when a new VestingWallet is created\n     */\n    event VestingWalletCreated(\n        address indexed beneficiary,\n        address indexed vestingWallet,\n        uint64 startTime,\n        uint64 duration,\n        address token,\n        uint256 amount\n    );\n}\n"
    },
    "src/lib/math/DecimalMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title DecimalMath\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Library for high-precision decimal arithmetic operations\n * @dev Provides decimal arithmetic with 6 decimal places precision (1e6):\n *      - Supports basic arithmetic operations (add, sub, mul, div)\n *      - Includes comparison operations (gt, lt)\n *      - Provides conversion between decimals and integers\n *      - Used throughout the protocol for precise calculations\n */\n\n/**\n * @title Decimal type and math operations\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\n\nstruct Decimal {\n    uint256 value; // Value scaled by DECIMAL_PRECISION\n}\n\n/**\n * @title DecimalMath\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\nlibrary DecimalMath {\n    // We'll use 6 decimal places for precision\n    uint256 public constant DECIMAL_PRECISION = 1e6;\n\n    // Convert a regular number to a Decimal\n    function fromNumber(uint256 value) internal pure returns (Decimal memory) {\n        return Decimal({ value: value * DECIMAL_PRECISION });\n    }\n\n    // Convert a Decimal to a regular number while keeping the remainder\n    function toNumber(Decimal memory d) internal pure returns (uint256, Decimal memory) {\n        return (d.value / DECIMAL_PRECISION, Decimal({ value: d.value % DECIMAL_PRECISION }));\n    }\n\n    // Floor division for Decimal\n    function floor(Decimal memory d) internal pure returns (uint256) {\n        return d.value / DECIMAL_PRECISION;\n    }\n\n    // Ceiling division for Decimal\n    function ceil(Decimal memory d) internal pure returns (uint256) {\n        return (d.value + DECIMAL_PRECISION - 1) / DECIMAL_PRECISION;\n    }\n\n    // Multiply two Decimals\n    function mul(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: (a.value * b.value) / DECIMAL_PRECISION });\n    }\n\n    // Multiply Decimal by a scalar\n    function mulScalar(Decimal memory a, uint256 scalar) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value * scalar });\n    }\n\n    // Divide two Decimals\n    function div(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: (a.value * DECIMAL_PRECISION) / b.value });\n    }\n\n    // Divide Decimal by a scalar\n    function divScalar(Decimal memory a, uint256 scalar) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value / scalar });\n    }\n\n    // Add two Decimals\n    function add(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value + b.value });\n    }\n\n    // Subtract two Decimals\n    function sub(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value - b.value });\n    }\n\n    // From ratio to Decimal\n    function fromRatio(uint256 num, uint256 denom) internal pure returns (Decimal memory) {\n        return Decimal({ value: (num * DECIMAL_PRECISION) / denom });\n    }\n\n    // > operator for Decimals\n    function gt(Decimal memory a, Decimal memory b) internal pure returns (bool) {\n        return a.value > b.value;\n    }\n\n    // < operator for Decimals\n    function lt(Decimal memory a, Decimal memory b) internal pure returns (bool) {\n        return a.value < b.value;\n    }\n}\n"
    },
    "src/lib/math/StreamMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title StreamMathLib\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Core mathematical engine powering StreamSwap's time-based distribution algorithm\n * @dev This library implements the mathematical model that enables StreamSwap's unique\n *      continuous token distribution mechanism. Unlike traditional AMMs or auction models,\n *      StreamSwap calculates distributions based on time progression and participation timing.\n *      \n *      Key Algorithms:\n *      - Time Differential Calculation: Determines distribution progress based on elapsed time\n *      - Share-based Distribution: Calculates proportional token allocation per participant\n *      - Dynamic Price Discovery: Computes real-time pricing based on participation\n *      - Position Synchronization: Updates user positions with accrued distributions\n *      - Exit Fee Computation: Applies configurable fees on successful stream exits\n *      \n *      Mathematical Precision:\n *      - Uses DecimalMath library for 6-decimal precision (1e6)\n *      - Handles edge cases like zero participation and boundary conditions\n *      - Prevents overflow/underflow through careful calculation ordering\n *      - Maintains accuracy across different time scales and token amounts\n */\n\nimport { StreamTypes } from \"../../types/StreamTypes.sol\";\nimport { DecimalMath, Decimal } from \"./DecimalMath.sol\";\nimport { PositionTypes } from \"../../types/PositionTypes.sol\";\nlibrary StreamMathLib {\n    /**\n     * @dev Calculates the time difference ratio between current time and last updated time\n     * @param currentTimestamp Current timestamp\n     * @param streamStartTime Timestamp when the stream starts\n     * @param streamEndTime Timestamp when the stream ends\n     * @param lastUpdated Timestamp when the stream was last updated\n     * @return The ratio of time elapsed since last update compared to total remaining time (scaled by 1e18)\n     */\n    function calculateDiff(\n        uint256 currentTimestamp,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 lastUpdated\n    ) internal pure returns (Decimal memory) {\n        // If the stream is not started yet or already ended, return 0\n        if (currentTimestamp < streamStartTime || lastUpdated >= streamEndTime) {\n            return DecimalMath.fromNumber(0);\n        }\n\n        // If lastUpdated is before start time, set it to start time\n        uint256 effectiveLastUpdated = lastUpdated;\n        if (effectiveLastUpdated < streamStartTime) {\n            effectiveLastUpdated = streamStartTime;\n        }\n\n        // If current time is past end time, use end time instead\n        uint256 effectiveNow = currentTimestamp;\n        if (effectiveNow > streamEndTime) {\n            effectiveNow = streamEndTime;\n        }\n\n        uint256 numerator = effectiveNow - effectiveLastUpdated;\n        uint256 denominator = streamEndTime - effectiveLastUpdated;\n\n        if (denominator == 0 || numerator == 0) {\n            return DecimalMath.fromNumber(0);\n        }\n        // Return ratio of time elapsed since last update compared to total remaining time\n        return DecimalMath.fromRatio(numerator, denominator);\n    }\n\n    /**\n     * @dev Calculates the stream status based on the current state and timestamp\n     * @param currentStatus Current status of the stream\n     * @param currentTime Current timestamp to check against\n     * @param bootstrappingStartTime Timestamp when bootstrapping phase starts\n     * @param streamStartTime Timestamp when active streaming starts\n     * @param streamEndTime Timestamp when streaming ends\n     * @return IStreamTypes.Status The calculated stream status\n     */\n    function calculateStreamStatus(\n        StreamTypes.Status currentStatus,\n        uint256 currentTime,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime\n    ) internal pure returns (StreamTypes.Status) {\n        // Don't update if stream is in a final state\n        if (\n            currentStatus == StreamTypes.Status.Cancelled ||\n            currentStatus == StreamTypes.Status.FinalizedRefunded ||\n            currentStatus == StreamTypes.Status.FinalizedStreamed\n        ) {\n            return currentStatus;\n        }\n\n        // Update status based on current timestamp\n        if (currentTime < bootstrappingStartTime) {\n            return StreamTypes.Status.Waiting;\n        } else if (currentTime >= bootstrappingStartTime && currentTime < streamStartTime) {\n            return StreamTypes.Status.Bootstrapping;\n        } else if (currentTime >= streamStartTime && currentTime < streamEndTime) {\n            return StreamTypes.Status.Active;\n        } else if (currentTime >= streamEndTime) {\n            return StreamTypes.Status.Ended;\n        }\n\n        // This should never be reached, but return current status as fallback\n        return currentStatus;\n    }\n\n    /**\n     * @dev Calculates updated stream state based on time difference\n     * @param state Current stream state\n     * @param diff Time difference in seconds\n     * @return Updated stream state\n     */\n    function calculateUpdatedState(\n        StreamTypes.StreamState memory state,\n        Decimal memory diff\n    ) internal pure returns (StreamTypes.StreamState memory) {\n        // Create a copy of the state to avoid modifying the input\n        StreamTypes.StreamState memory newState = state;\n\n        if (newState.shares > 0 && diff.value > 0) {\n            // Calculate new distribution balance and spent in amount\n            Decimal memory newDecimalDistributionBalance = DecimalMath.mul(\n                DecimalMath.fromNumber(newState.outRemaining),\n                diff\n            );\n            uint256 newDistributionBalance = DecimalMath.floor(newDecimalDistributionBalance);\n\n            Decimal memory newDecimalSpentIn = DecimalMath.mul(DecimalMath.fromNumber(newState.inSupply), diff);\n            uint256 spentIn = DecimalMath.floor(newDecimalSpentIn);\n\n            // Update state variables\n            newState.spentIn += spentIn;\n            newState.inSupply -= spentIn;\n\n            if (newDistributionBalance > 0) {\n                newState.outRemaining -= newDistributionBalance;\n                // Increment distribution index\n                Decimal memory distIndexIncrementAmount = DecimalMath.fromRatio(\n                    newDistributionBalance,\n                    newState.shares\n                );\n                newState.distIndex = DecimalMath.add(newState.distIndex, distIndexIncrementAmount);\n                // Update current streamed price\n                newState.currentStreamedPrice = DecimalMath.fromRatio(spentIn, newDistributionBalance);\n            }\n        }\n        return newState;\n    }\n\n    function computeSharesAmount(\n        uint256 amountIn,\n        bool roundUp,\n        uint256 inSupply,\n        uint256 totalShares\n    ) internal pure returns (uint256) {\n        if (totalShares == 0 || amountIn == 0) {\n            return amountIn;\n        }\n\n        uint256 totalSharesIn = totalShares * amountIn;\n\n        if (roundUp) {\n            return (totalSharesIn + inSupply - 1) / inSupply;\n        } else {\n            return totalSharesIn / inSupply;\n        }\n    }\n\n    /**\n     * @dev Calculates the exit fee amount based on the spent in amount\n     * @param spentInAmount Amount of tokens spent in the stream\n     * @return exitFeeAmount The calculated fee amount\n     * @return remainingAmount The remaining amount after fee deduction\n     */\n    function calculateExitFee(\n        uint256 spentInAmount,\n        Decimal memory exitFeeRatio\n    ) internal pure returns (uint256 exitFeeAmount, uint256 remainingAmount) {\n        Decimal memory decimalSpentIn = DecimalMath.fromNumber(spentInAmount);\n\n        // Calculate exit fee amount using DecimalMath\n        Decimal memory decimalExitFeeAmount = DecimalMath.mul(decimalSpentIn, exitFeeRatio);\n        exitFeeAmount = DecimalMath.floor(decimalExitFeeAmount);\n        remainingAmount = spentInAmount - exitFeeAmount;\n\n        return (exitFeeAmount, remainingAmount);\n    }\n\n    function syncPosition(\n        PositionTypes.Position memory position,\n        Decimal memory distIndex,\n        uint256 totalShares,\n        uint256 inSupply,\n        uint256 nowTime\n    ) internal pure returns (PositionTypes.Position memory) {\n        // Calculate index difference for distributions since last update\n        Decimal memory indexDiff = DecimalMath.sub(distIndex, position.index);\n        uint256 spent = 0;\n        uint256 purchased = 0;\n\n        // Only process if there are shares in the stream\n        if (position.shares > 0) {\n            // Calculate purchased amount based on position shares and index difference\n            Decimal memory positionSharesDecimal = DecimalMath.fromNumber(position.shares);\n            Decimal memory purchasedDecimal = DecimalMath.add(\n                DecimalMath.mul(positionSharesDecimal, indexDiff),\n                position.pendingReward\n            );\n            (purchased, purchasedDecimal) = DecimalMath.toNumber(purchasedDecimal);\n            position.purchased += purchased;\n            position.pendingReward = purchasedDecimal;\n\n            // Calculate remaining balance based on current shares ratio\n            uint256 inRemaining = (inSupply * position.shares) / totalShares;\n            // Calculate spent amount\n            spent = position.inBalance - inRemaining;\n            position.spentIn += spent;\n            position.inBalance = inRemaining;\n        }\n\n        // Update position tracking\n        position.index = distIndex;\n        position.lastUpdateTime = nowTime;\n\n        return position;\n    }\n}\n"
    },
    "src/lib/math/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    error T();\n    error R();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\n\n            uint256 ratio = absTick & 0x1 != 0\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\n                : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // second inequality must be < because the price can never reach the price at the max tick\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}"
    },
    "src/lib/TransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title TransferLib\n * @author Adnan Deniz\n * @notice Unified handling of ERC20 and native transfers.\n * @dev Supports both fresh ETH via msg.value and already-held ETH in contract.\n */\nlibrary TransferLib {\n    using SafeERC20 for IERC20;\n\n    /// @notice Native token address (zero address)\n    address public constant NATIVE_TOKEN = address(0);\n\n    /**\n     * @dev Transfer funds from `from` to `to`. Works with native token and ERC20.\n     * @param token Token address (zero address for native token)\n     * @param from Address providing funds (msg.sender or this for native, any for ERC20)\n     * @param to Address receiving funds\n     * @param amount Amount to transfer\n     */\n    function transferFunds(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) return;\n\n        if (token == NATIVE_TOKEN) {\n            if (from == msg.sender) {\n                // Pulling fresh ETH\n                if (msg.value != amount) revert IncorrectNativeAmount(amount, msg.value);\n                if (to == address(this)) return; // staying in contract\n                (bool ok, ) = payable(to).call{ value: amount }(\"\");\n                if (!ok) revert NativeTokenTransferFailed();\n            } else if (from == address(this)) {\n                // Sending ETH already held by contract\n                (bool ok, ) = payable(to).call{ value: amount }(\"\");\n                if (!ok) revert NativeTokenTransferFailed();\n            } else {\n                revert InvalidNativePayer(from);\n            }\n            return;\n        }\n\n        // ERC20 path\n        if (from == address(this)) {\n            IERC20(token).safeTransfer(to, amount);\n        } else {\n            IERC20(token).safeTransferFrom(from, to, amount);\n        }\n    }\n\n    // ============ Errors ============\n    error NativeTokenTransferFailed();\n    error IncorrectNativeAmount(uint256 expected, uint256 actual);\n    error InvalidNativePayer(address from);\n}\n"
    },
    "src/PoolRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IPoolRouter } from \"./interfaces/IPoolRouter.sol\";\nimport { IPoolWrapper } from \"./interfaces/IPoolWrapper.sol\";\nimport { PoolWrapperTypes } from \"./types/PoolWrapperTypes.sol\";\nimport { PoolRouterTypes } from \"./types/PoolRouterTypes.sol\";\nimport { StreamTypes } from \"./types/StreamTypes.sol\";\nimport { TransferLib } from \"./lib/TransferLib.sol\";\n\ncontract PoolRouter is Ownable, IPoolRouter {\n    // Mapping of dex enum value => (key => wrapper address)\n    mapping(uint8 => mapping(uint256 => address)) private _wrappers;\n\n    // ============ Errors ============\n    error InvalidAddress();\n    error InvalidDexType();\n    error WrapperNotFound();\n    error InvalidAmount();\n    error InvalidExtraParams();\n\n    // ============ Events ============\n    event WrapperSet(uint8 indexed dex, uint256 indexed key, address wrapper);\n    event RoutedCreatePool(\n        address indexed stream,\n        address indexed wrapper,\n        address pool,\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    constructor() Ownable() {}\n\n    // ============ Admin ============\n\n    function setWrapper(StreamTypes.DexType dex, uint256 key, address wrapper) external override onlyOwner {\n        if (wrapper == address(0)) revert InvalidAddress();\n        _wrappers[uint8(dex)][key] = wrapper;\n        emit WrapperSet(uint8(dex), key, wrapper);\n    }\n\n    function getWrapper(StreamTypes.DexType dex, uint256 key) external view override returns (address) {\n        return _wrappers[uint8(dex)][key];\n    }\n\n    // ============ Validation ============\n\n    function validatePoolParams(StreamTypes.PoolInfo calldata info) external view override {\n        (uint256 key, ) = _computeKey(info.dexType, info.extra);\n        address w = _wrappers[uint8(info.dexType)][key];\n        if (w == address(0)) revert WrapperNotFound();\n        if (info.dexType == StreamTypes.DexType.V2 && info.extra.length != 0) revert InvalidExtraParams();\n        if (info.dexType == StreamTypes.DexType.V3 && info.extra.length != 32) revert InvalidExtraParams();\n        if (info.dexType == StreamTypes.DexType.Aerodrome && info.extra.length != 1) revert InvalidExtraParams();\n    }\n\n    // ============ Execution ============\n\n    function createPool(PoolRouterTypes.CreatePoolRequest calldata req)\n        external\n        override\n        returns (PoolWrapperTypes.CreatedPoolInfo memory)\n    {\n        if (req.tokenA == address(0) || req.tokenB == address(0)) revert InvalidAddress();\n        if (req.amountADesired == 0 || req.amountBDesired == 0) revert InvalidAmount();\n        if (req.tokenA == req.tokenB) revert InvalidAddress();\n        if (req.creator == address(0)) revert InvalidAddress();\n\n        (uint256 key, ) = _computeKey(req.dexType, req.extra);\n        address wrapper = _wrappers[uint8(req.dexType)][key];\n        if (wrapper == address(0)) revert WrapperNotFound();\n\n        // Transfer funds to wrapper\n        TransferLib.transferFunds(req.tokenA, address(this), wrapper, req.amountADesired);\n        TransferLib.transferFunds(req.tokenB, address(this), wrapper, req.amountBDesired);\n\n        // Call wrapper\n        PoolWrapperTypes.CreatePoolMsg memory msg_ = PoolWrapperTypes.CreatePoolMsg({\n            token0: req.tokenA,\n            token1: req.tokenB,\n            amount0Desired: req.amountADesired,\n            amount1Desired: req.amountBDesired,\n            creator: req.creator,\n            extra: req.extra\n        });\n\n        PoolWrapperTypes.CreatedPoolInfo memory info = IPoolWrapper(wrapper).createPool(msg_);\n\n        emit RoutedCreatePool(\n            msg.sender,\n            wrapper,\n            info.poolAddress,\n            info.token0,\n            info.token1,\n            info.amount0,\n            info.amount1\n        );\n\n        return info;\n    }\n\n    // ============ Internals ============\n\n    function _computeKey(\n        StreamTypes.DexType dex,\n        bytes memory extra\n    ) internal pure returns (uint256 key, bool isAerodrome) {\n        if (dex == StreamTypes.DexType.V2) {\n            if (extra.length != 0) revert InvalidExtraParams();\n            return (0, false);\n        } else if (dex == StreamTypes.DexType.V3) {\n            uint24 fee = abi.decode(extra, (uint24));\n            if (fee == 0) revert InvalidExtraParams();\n            return (uint256(fee), false);\n        } else if (dex == StreamTypes.DexType.Aerodrome) {\n            bool stable = abi.decode(extra, (bool));\n            return (stable ? 1 : 0, true);\n        } else {\n            revert InvalidDexType();\n        }\n    }\n\n    // Accept ETH for native token routing\n    receive() external payable {}\n}\n\n\n"
    },
    "src/PoolWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { PoolWrapperTypes } from \"./types/PoolWrapperTypes.sol\";\nimport { IPoolWrapperErrors } from \"./interfaces/IPoolWrapperErrors.sol\";\nimport { TransferLib } from \"./lib/TransferLib.sol\";\nimport \"hardhat/console.sol\";\n\nabstract contract PoolWrapper is Ownable, IPoolWrapperErrors {\n    using SafeERC20 for IERC20;\n\n    // Mapping from stream address to pool info\n    mapping(address => PoolWrapperTypes.CreatedPoolInfo) public streamPools;\n\n    constructor() Ownable() {}\n\n    /**\n     * @notice Creates a pool and adds liquidity\n     * @param createPoolMsg The parameters for pool creation and liquidity addition\n     * Callable by anyone\n     */\n    function createPool(\n        PoolWrapperTypes.CreatePoolMsg calldata createPoolMsg\n    ) external returns (PoolWrapperTypes.CreatedPoolInfo memory) {\n        // Validate that the tokens are valid ERC20s\n        if (createPoolMsg.token0 == address(0)) revert InvalidAddress();\n        if (createPoolMsg.token1 == address(0)) revert InvalidAddress();\n        if (createPoolMsg.token0 == createPoolMsg.token1) revert DifferentTokensRequired();\n        if (createPoolMsg.amount0Desired == 0) revert InvalidAmount();\n        if (createPoolMsg.amount1Desired == 0) revert InvalidAmount();\n        if (createPoolMsg.creator == address(0)) revert InvalidAddress();\n\n        // Validate that the tokens are sent to this contract\n        if (IERC20(createPoolMsg.token0).balanceOf(address(this)) < createPoolMsg.amount0Desired) {\n            revert InsufficientBalance();\n        }\n        if (IERC20(createPoolMsg.token1).balanceOf(address(this)) < createPoolMsg.amount1Desired) {\n            revert InsufficientBalance();\n        }\n\n        // DEX-specific pool creation and liquidity addition\n        (address poolAddress, uint256 amount0, uint256 amount1, uint256 refundedAmount0, uint256 refundedAmount1) = _createPoolInternal(createPoolMsg);\n\n        // Store the pool info\n        PoolWrapperTypes.CreatedPoolInfo memory poolInfo = PoolWrapperTypes.CreatedPoolInfo({\n            poolAddress: poolAddress,\n            token0: createPoolMsg.token0,\n            token1: createPoolMsg.token1,\n            amount0: amount0,\n            amount1: amount1,\n            creator: createPoolMsg.creator,\n            refundedAmount0: refundedAmount0,\n            refundedAmount1: refundedAmount1\n        });\n\n        // Send refunded tokens to the creator\n        TransferLib.transferFunds(createPoolMsg.token0, address(this), createPoolMsg.creator, refundedAmount0);\n        TransferLib.transferFunds(createPoolMsg.token1, address(this), createPoolMsg.creator, refundedAmount1);\n\n        streamPools[msg.sender] = poolInfo;\n        return poolInfo;\n    }\n\n    /**\n     * @notice Gets pool info for a stream\n     * @param stream The stream address\n     */\n    function getPoolInfo(address stream) external view returns (PoolWrapperTypes.CreatedPoolInfo memory) {\n        return streamPools[stream];\n    }\n\n    /**\n     * @dev Abstract method for DEX-specific pool creation and liquidity addition\n     * @param createPoolMsg The pool creation parameters\n     * @return poolAddress The address of the created pool\n     * @return amount0 The actual amount of token0 added\n     * @return amount1 The actual amount of token1 added\n     * @return refundedAmount0 The amount of token0 refunded\n     * @return refundedAmount1 The amount of token1 refunded\n     */\n    function _createPoolInternal(\n        PoolWrapperTypes.CreatePoolMsg calldata createPoolMsg\n    ) internal virtual returns (address poolAddress, uint256 amount0, uint256 amount1, uint256 refundedAmount0, uint256 refundedAmount1);\n\n    /**\n     * @dev Abstract method to get the DEX factory address\n     */\n    function _getFactory() internal view virtual returns (address);\n\n    /**\n     * @dev Abstract method to get the DEX router address\n     */\n    function _getRouter() internal view virtual returns (address);\n}\n"
    },
    "src/StreamCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title StreamCore\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Abstract base contract for streaming functionality with extension hooks\n * @dev This contract contains the core streaming logic with virtual hook functions\n *      that can be overridden by implementation contracts to add features like\n *      vesting, pool creation, etc. All storage is defined here to ensure\n *      consistent layout across implementations for upgradeability.\n */\n\nimport { PositionTypes } from \"./types/PositionTypes.sol\";\nimport { IPositionStorage } from \"./interfaces/IPositionStorage.sol\";\nimport { IStreamEvents } from \"./interfaces/IStreamEvents.sol\";\nimport { IStreamErrors } from \"./interfaces/IStreamErrors.sol\";\nimport { StreamTypes } from \"./types/StreamTypes.sol\";\nimport { StreamFactoryTypes } from \"./types/StreamFactoryTypes.sol\";\nimport { IStreamFactoryParams } from \"./interfaces/IStreamFactoryParams.sol\";\nimport { DecimalMath, Decimal } from \"./lib/math/DecimalMath.sol\";\nimport { StreamMathLib } from \"./lib/math/StreamMathLib.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { TransferLib } from \"./lib/TransferLib.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport \"hardhat/console.sol\";\n\nabstract contract StreamCore is IStreamErrors, IStreamEvents, UUPSUpgradeable {\n    // ============ State Variables ============\n    // All storage must be defined here for upgrade compatibility\n    \n    /// @notice Address of the stream creator\n    address public creator;\n\n    /// @notice Address of the stream factory that deployed this stream\n    /// @dev Changed from immutable to storage for proxy compatibility\n    address public STREAM_FACTORY_ADDRESS;\n\n    /// @notice Address of the position storage contract\n    address public positionStorageAddress;\n\n    /// @notice Flag to ensure initialization happens only once\n    bool private initialized;\n\n    /// @notice Current state of the stream (distribution index, remaining tokens, etc.)\n    StreamTypes.StreamState public streamState;\n\n    /// @notice Token addresses for input and output tokens\n    StreamTypes.StreamTokens public streamTokens;\n\n    /// @notice Metadata associated with the stream\n    StreamTypes.StreamMetadata public streamMetadata;\n\n    /// @notice Current status of the stream (Waiting, Bootstrapping, Active, etc.)\n    StreamTypes.Status public streamStatus;\n\n    /// @notice Timing information for the stream phases\n    StreamTypes.StreamTimes public streamTimes;\n\n    /// @notice Post-stream actions like vesting and pool creation\n    StreamTypes.PostStreamActions public postStreamActions;\n\n    /// @notice Address of the Permit2 contract\n    address public constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /// @notice Storage gap for future upgrades\n    uint256[40] private __gap;\n\n    // ============ Modifiers ============\n\n    /**\n     * @dev Ensures the function can only be called once during initialization\n     */\n    modifier onlyOnce() {\n        if (initialized) revert Unauthorized();\n        _;\n        initialized = true;\n    }\n\n    /**\n     * @dev Ensures only the stream factory can call the function\n     */\n    modifier onlyStreamFactory() {\n        if (msg.sender != STREAM_FACTORY_ADDRESS) revert Unauthorized();\n        _;\n    }\n\n    /**\n     * @dev Ensures only the stream creator can call the function\n     */\n    modifier onlyCreator() {\n        if (msg.sender != creator) revert Unauthorized();\n        _;\n    }\n\n    /**\n     * @dev Ensures only the protocol admin can call the function\n     */\n    modifier onlyProtocolAdmin() {\n        IStreamFactoryParams factoryContract = IStreamFactoryParams(STREAM_FACTORY_ADDRESS);\n        address protocolAdmin = factoryContract.getParams().protocolAdmin;\n        if (msg.sender != protocolAdmin) revert Unauthorized();\n        _;\n    }\n\n    // ============ Initialization ============\n\n    /**\n     * @dev Initializes the stream with the provided configuration\n     * @param createStreamMessage Stream creation parameters\n     * @param storageAddress Address of the position storage contract\n     * @notice This function can only be called once and must be invoked by the factory\n     */\n    function initialize(\n        StreamTypes.CreateStreamMessage memory createStreamMessage,\n        address storageAddress\n    ) external virtual onlyOnce {\n        if (storageAddress == address(0)) revert InvalidPositionStorageAddress();\n        \n        // Set factory address from caller (mirrors how the original constructor captured it)\n        STREAM_FACTORY_ADDRESS = msg.sender;\n        \n        // Save position storage address\n        positionStorageAddress = storageAddress;\n        \n        // Set creator\n        creator = createStreamMessage.creator;\n        \n        // Initialize stream state\n        streamState = StreamTypes.StreamState({\n            distIndex: DecimalMath.fromNumber(0),\n            outRemaining: createStreamMessage.streamOutAmount,\n            inSupply: 0,\n            spentIn: 0,\n            shares: 0,\n            currentStreamedPrice: DecimalMath.fromNumber(0),\n            threshold: createStreamMessage.threshold,\n            outSupply: createStreamMessage.streamOutAmount,\n            lastUpdated: block.timestamp\n        });\n        \n        // Initialize stream tokens\n        streamTokens = StreamTypes.StreamTokens({\n            inSupplyToken: createStreamMessage.inSupplyToken,\n            outSupplyToken: createStreamMessage.outSupplyToken\n        });\n        \n        // Initialize stream metadata\n        streamMetadata = createStreamMessage.metadata;\n        \n        // Initialize stream status\n        streamStatus = StreamTypes.Status.Waiting;\n        \n        // Initialize stream times\n        streamTimes = StreamTypes.StreamTimes({\n            bootstrappingStartTime: createStreamMessage.bootstrappingStartTime,\n            streamStartTime: createStreamMessage.streamStartTime,\n            streamEndTime: createStreamMessage.streamEndTime\n        });\n        \n        // Store post-stream actions for extensions to use\n        postStreamActions = StreamTypes.PostStreamActions({\n            poolInfo: createStreamMessage.poolInfo,\n            creatorVesting: createStreamMessage.creatorVesting,\n            beneficiaryVesting: createStreamMessage.beneficiaryVesting\n        });\n        \n        // Call initialization hook for extensions\n        _onInitialize(createStreamMessage);\n    }\n\n    // ============ Extension Hooks (Virtual Functions) ============\n\n    /**\n     * @dev Hook called during initialization for extensions to set up their state\n     * @param createStreamMessage Stream creation parameters\n     */\n    function _onInitialize(StreamTypes.CreateStreamMessage memory createStreamMessage) internal virtual {}\n\n    /**\n     * @dev Hook called after a subscription\n     * @param user Address of the subscriber\n     * @param amountIn Amount subscribed\n     */\n    function _onSubscribe(address user, uint256 amountIn) internal virtual {}\n\n    /**\n     * @dev Hook called after a withdrawal\n     * @param user Address of the withdrawer\n     * @param amountOut Amount withdrawn\n     */\n    function _onWithdraw(address user, uint256 amountOut) internal virtual {}\n\n    /**\n     * @dev Hook called when a user exits successfully (threshold met)\n     * @param user Address of the exiting user\n     * @param purchased Amount of output tokens purchased\n     * @param inRefunded Amount of input tokens refunded\n     */\n    function _onExitSuccess(address user, uint256 purchased, uint256 inRefunded) internal virtual {\n        TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), user, purchased);\n        \n        if (inRefunded > 0) {\n            TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), user, inRefunded);\n        }\n    }\n\n    /**\n     * @dev Hook called when a user exits with refund (threshold not met or cancelled)\n     * @param user Address of the exiting user\n     * @param totalRefund Amount of input tokens to refund\n     */\n    function _onExitRefund(address user, uint256 totalRefund) internal virtual {\n        TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), user, totalRefund);\n    }\n\n    /**\n     * @dev Hook called before finalizing a successful stream\n     * @return adjustedCreatorRevenue Revenue after any adjustments (e.g., for pool)\n     */\n    function _beforeFinalizeSuccess(uint256 creatorRevenue) internal virtual returns (uint256 adjustedCreatorRevenue) {\n        return creatorRevenue;\n    }\n\n    /**\n     * @dev Hook called after finalizing a successful stream\n     * @param creatorRevenue Amount of input tokens for creator\n     * @param outRemaining Remaining output tokens\n     */\n    function _afterFinalizeSuccess(uint256 creatorRevenue, uint256 outRemaining) internal virtual {\n        TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), creator, creatorRevenue);\n        \n        if (outRemaining > 0) {\n            TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), creator, outRemaining);\n        }\n    }\n\n    /**\n     * @dev Hook called after finalizing a refunded stream\n     * @param outSupply Amount of output tokens to return\n     */\n    function _afterFinalizeRefund(uint256 outSupply) internal virtual {\n        TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), creator, outSupply);\n    }\n\n    // ============ Core Stream Functions ============\n\n    /**\n     * @dev Internal function containing the core subscription logic\n     * @param amountIn Amount of input tokens to subscribe with\n     */\n    function _subscribeCore(uint256 amountIn) internal {\n        if (amountIn == 0) revert InvalidAmount();\n\n        // Load and validate stream state\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Validate operation is allowed\n        if (status != StreamTypes.Status.Bootstrapping && status != StreamTypes.Status.Active) {\n            revert OperationNotAllowed();\n        }\n\n        // Load and sync stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        // Load and sync position\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // Calculate shares before any state changes\n        uint256 newShares = StreamMathLib.computeSharesAmount(amountIn, false, state.inSupply, state.shares);\n\n        // Update position\n        position.inBalance += amountIn;\n        position.shares += newShares;\n\n        // Update stream state\n        state.inSupply += amountIn;\n        state.shares += newShares;\n\n        // Save all states\n        saveStreamStatus(status);\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        emit Subscribed(\n            address(this),\n            msg.sender,\n            position.inBalance,\n            newShares,\n            position.lastUpdateTime,\n            position.spentIn,\n            position.purchased,\n            position.index.value,\n            state.inSupply,\n            state.shares\n        );\n\n        // Call subscription hook\n        _onSubscribe(msg.sender, amountIn);\n    }\n\n    /**\n     * @dev Allows users to subscribe to the stream by providing input tokens\n     * @param amountIn Amount of input tokens to subscribe with\n     */\n    function subscribe(uint256 amountIn) external {\n        if (streamTokens.inSupplyToken == address(0)) revert InvalidInputToken();\n        // Pull funds (ERC20)\n        TransferLib.transferFunds(streamTokens.inSupplyToken, msg.sender, address(this), amountIn);\n        _subscribeCore(amountIn);\n    }\n\n    /**\n     * @dev Allows users to subscribe with native tokens\n     * @param amountIn Amount of native tokens to subscribe with\n     */\n    function subscribeWithNativeToken(uint256 amountIn) external payable {\n        if (streamTokens.inSupplyToken != address(0)) revert InvalidInputToken();\n        // Pull funds (native)\n        TransferLib.transferFunds(address(0), msg.sender, address(this), amountIn);\n        _subscribeCore(amountIn);\n    }\n\n    /**\n     * @dev Allows users to withdraw their input tokens from the stream\n     * @param cap Amount of input tokens to withdraw\n     */\n    function withdraw(uint256 cap) external {\n        // Load position once\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n\n        // Validate position\n        validatePosition(position, msg.sender);\n\n        // load stream times\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (status != StreamTypes.Status.Active && status != StreamTypes.Status.Bootstrapping) {\n            revert OperationNotAllowed();\n        }\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        // Sync position with the updated state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // If cap is 0, withdraw all available balance\n        uint256 withdrawAmount = (cap == 0) ? position.inBalance : cap;\n\n        // Check if withdrawal amount exceeds position balance\n        if (withdrawAmount > position.inBalance) revert WithdrawAmountExceedsBalance(withdrawAmount);\n\n        uint256 shareDeduction = 0;\n\n        if (withdrawAmount == position.inBalance) {\n            shareDeduction = position.shares;\n        } else {\n            shareDeduction = StreamMathLib.computeSharesAmount(withdrawAmount, true, state.inSupply, state.shares);\n        }\n\n        // Update position\n        position.shares = position.shares - shareDeduction;\n        position.inBalance = position.inBalance - withdrawAmount;\n\n        // Update stream state\n        state.inSupply = state.inSupply - withdrawAmount;\n        state.shares = state.shares - shareDeduction;\n\n        // Save all states first\n        saveStreamStatus(status);\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        // Emit events\n        emit Withdrawn(\n            address(this),\n            msg.sender,\n            position.inBalance,\n            position.shares,\n            position.lastUpdateTime,\n            position.spentIn,\n            position.purchased,\n            position.index.value,\n            state.inSupply,\n            state.shares\n        );\n\n        // Transfer tokens\n        TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), msg.sender, withdrawAmount);\n        \n        // Call withdrawal hook\n        _onWithdraw(msg.sender, withdrawAmount);\n    }\n\n    /**\n     * @dev Allows users to exit the stream and receive their tokens based on stream outcome\n     */\n    function exitStream() external {\n        // Load and validate position\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n        if (position.exitDate != 0) revert InvalidPosition(msg.sender, position.shares, position.exitDate, \"Position has already exited\");\n\n        // Load and sync stream state\n        StreamTypes.StreamState memory state = syncStream(loadStream());\n\n        // Sync position with updated stream state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // Load and sync stream status\n        StreamTypes.Status status = syncStreamStatus(loadStreamStatus(), loadStreamTimes(), block.timestamp);\n\n        // Store values for distribution before changing state\n        uint256 inBalance = position.inBalance;\n        uint256 purchased = position.purchased;\n        uint256 spentIn = position.spentIn;\n        position.exitDate = block.timestamp;\n\n        // Save updated state before making external calls\n        saveStreamStatus(status);\n        saveStream(state);\n        savePosition(msg.sender, position);\n\n        // Determine outcome\n        bool thresholdReached = (state.spentIn >= state.threshold);\n        bool isSuccess = (status == StreamTypes.Status.FinalizedStreamed ||\n            (status == StreamTypes.Status.Ended && thresholdReached));\n        bool isRefund = (status == StreamTypes.Status.FinalizedRefunded ||\n            status == StreamTypes.Status.Cancelled ||\n            (status == StreamTypes.Status.Ended && !thresholdReached));\n\n        if (isSuccess) {\n            // Case 1: Successful exit - use hook for distribution\n            emit ExitStreamed(address(this), msg.sender, purchased, spentIn, position.index.value, inBalance, block.timestamp);\n            _onExitSuccess(msg.sender, purchased, inBalance);\n        } else if (isRefund) {\n            // Case 2: Refund exit - use hook for refund\n            uint256 totalRefund = inBalance + spentIn;\n            position.purchased = 0;\n            position.spentIn = 0;\n            position.inBalance = totalRefund;\n            savePosition(msg.sender, position);\n            emit ExitRefunded(address(this), msg.sender, position.inBalance, position.spentIn, block.timestamp);\n            _onExitRefund(msg.sender, totalRefund);\n        } else {\n            // Case 3: No exit allowed\n            revert OperationNotAllowed();\n        }\n    }\n\n    /**\n     * @dev Allows the creator to finalize the stream after it has ended\n     */\n    function finalizeStream() external onlyCreator {\n        // Get factory params\n        IStreamFactoryParams factoryContract = IStreamFactoryParams(STREAM_FACTORY_ADDRESS);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (status != StreamTypes.Status.Ended) {\n            revert OperationNotAllowed();\n        }\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        bool thresholdReached = state.spentIn >= state.threshold;\n\n        // Store values needed for distribution before state changes\n        uint256 outRemaining = state.outRemaining;\n        uint256 outSupply = state.outSupply;\n        uint256 spentIn = state.spentIn;\n\n        if (thresholdReached) {\n            address feeCollector = params.feeCollector;\n            Decimal memory exitFeeRatio = params.exitFeeRatio;\n            // Calculate exit fee\n            (uint256 feeAmount, uint256 creatorRevenue) = StreamMathLib.calculateExitFee(spentIn, exitFeeRatio);\n\n            // Call hook to allow adjustments (e.g., for pool)\n            creatorRevenue = _beforeFinalizeSuccess(creatorRevenue);\n\n            // Update status\n            status = StreamTypes.Status.FinalizedStreamed;\n            saveStreamStatus(status);\n            saveStream(state);\n\n            // Emit event before external calls\n            emit FinalizedStreamed(address(this), creator, creatorRevenue, feeAmount, outRemaining);\n\n            // External calls last\n            TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), feeCollector, feeAmount);\n            \n            // Call hook for final distribution\n            _afterFinalizeSuccess(creatorRevenue, outRemaining);\n        } else {\n            // Update status\n            status = StreamTypes.Status.FinalizedRefunded;\n            saveStreamStatus(status);\n            saveStream(state);\n\n            // Emit event before external call\n            emit FinalizedRefunded(address(this), creator, outSupply);\n\n            // Call hook for refund\n            _afterFinalizeRefund(outSupply);\n        }\n    }\n\n    /**\n     * @dev Allows the creator to cancel the stream during the Waiting phase\n     */\n    function cancelStream() external onlyCreator {\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (status != StreamTypes.Status.Waiting) {\n            revert OperationNotAllowed();\n        }\n\n        // Store amount to transfer before updating state\n        uint256 amountToTransfer = streamState.outSupply;\n\n        // Update status\n        status = StreamTypes.Status.Cancelled;\n        saveStreamStatus(status);\n\n        emit StreamCancelled(address(this), creator, amountToTransfer, uint8(status));\n        TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), creator, amountToTransfer);\n    }\n\n    /**\n     * @dev Allows the protocol admin to cancel the stream\n     */\n    function cancelWithAdmin() external onlyProtocolAdmin {\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (\n            status != StreamTypes.Status.Waiting &&\n            status != StreamTypes.Status.Bootstrapping &&\n            status != StreamTypes.Status.Active\n        ) {\n            revert OperationNotAllowed();\n        }\n\n        // Store amount to transfer before updating state\n        uint256 amountToTransfer = streamState.outSupply;\n\n        // Update status\n        status = StreamTypes.Status.Cancelled;\n        saveStreamStatus(status);\n\n        emit StreamCancelled(address(this), creator, amountToTransfer, uint8(status));\n\n        // External call last\n        TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), creator, amountToTransfer);\n    }\n\n    /**\n     * @dev Allows the creator to update the stream metadata\n     */\n    function updateStreamMetadata(string memory metadataIpfsHash) external onlyCreator {\n        streamMetadata.ipfsHash = metadataIpfsHash;\n        emit StreamMetadataUpdated(address(this), metadataIpfsHash);\n    }\n\n    // ============ External Sync Functions ============\n\n    /**\n     * @dev External function to sync the stream state and status\n     */\n    function syncStreamExternal() external {\n        // Load, update and save stream state\n        StreamTypes.StreamState memory state = loadStream();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        state = syncStream(state);\n        saveStream(state);\n\n        // Load, update and save status\n        StreamTypes.Status status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n        saveStreamStatus(status);\n\n        emit StreamSynced(\n            address(this),\n            state.lastUpdated,\n            uint8(status),\n            state.distIndex.value,\n            state.outRemaining,\n            state.inSupply,\n            state.spentIn,\n            state.currentStreamedPrice.value\n        );\n    }\n\n    /**\n     * @dev External function to sync a specific user's position\n     * @param user Address of the user whose position should be synced\n     */\n    function syncPositionExternal(address user) external {\n        PositionTypes.Position memory position = loadPosition(user);\n        validatePosition(position, user);\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n        savePosition(user, position);\n        saveStream(state);\n        emit PositionSynced(\n            address(this),\n            user,\n            position.inBalance,\n            position.shares,\n            position.lastUpdateTime,\n            position.spentIn,\n            position.purchased,\n            position.index.value\n        );\n    }\n\n    // ============ View Functions ============\n\n    function getStreamStatus() external view returns (StreamTypes.Status) {\n        return streamStatus;\n    }\n\n    function getStreamState() external view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    function getStreamMetadata() external view returns (StreamTypes.StreamMetadata memory) {\n        return streamMetadata;\n    }\n\n    function getPostStreamActions() external view returns (StreamTypes.PostStreamActions memory) {\n        return postStreamActions;\n    }\n\n    function getPosition(address user) external view returns (PositionTypes.Position memory) {\n        IPositionStorage positionStorage = IPositionStorage(positionStorageAddress);\n        return positionStorage.getPosition(user);\n    }\n\n    // ============ Internal Helper Functions ============\n\n    function syncStream(StreamTypes.StreamState memory state) internal returns (StreamTypes.StreamState memory) {\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        Decimal memory diff = StreamMathLib.calculateDiff(\n            block.timestamp,\n            times.streamStartTime,\n            times.streamEndTime,\n            state.lastUpdated\n        );\n\n        if (diff.value == 0) {\n            state.lastUpdated = block.timestamp;\n            return state;\n        }\n\n        state = StreamMathLib.calculateUpdatedState(state, diff);\n        state.lastUpdated = block.timestamp;\n\n        emit StreamStateUpdated(\n            address(this),\n            state.lastUpdated,\n            state.distIndex.value,\n            state.outRemaining,\n            state.inSupply,\n            state.spentIn,\n            state.currentStreamedPrice.value\n        );\n\n        return state;\n    }\n\n    function syncStreamStatus(\n        StreamTypes.Status status,\n        StreamTypes.StreamTimes memory times,\n        uint256 nowTime\n    ) internal pure returns (StreamTypes.Status) {\n        status = StreamMathLib.calculateStreamStatus(\n            status,\n            nowTime,\n            times.bootstrappingStartTime,\n            times.streamStartTime,\n            times.streamEndTime\n        );\n\n        return status;\n    }\n\n    // ============ Load Functions ============\n\n    function loadStream() internal view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    function loadStreamStatus() internal view returns (StreamTypes.Status) {\n        return streamStatus;\n    }\n\n    function loadPosition(address user) internal view returns (PositionTypes.Position memory) {\n        IPositionStorage positionStorage = IPositionStorage(positionStorageAddress);\n        return positionStorage.getPosition(user);\n    }\n\n    function loadStreamTimes() internal view returns (StreamTypes.StreamTimes memory) {\n        return streamTimes;\n    }\n\n    // ============ Save Functions ============\n\n    function saveStream(StreamTypes.StreamState memory state) internal {\n        streamState = state;\n    }\n\n    function saveStreamStatus(StreamTypes.Status status) internal {\n        streamStatus = status;\n    }\n\n    function savePosition(address user, PositionTypes.Position memory position) internal {\n        IPositionStorage positionStorage = IPositionStorage(positionStorageAddress);\n        positionStorage.updatePosition(user, position);\n    }\n\n    // ============ Validation Functions ============\n\n    function validatePosition(PositionTypes.Position memory position, address user) internal pure {\n        if (position.shares == 0) {\n            revert InvalidPosition(user, position.shares, position.exitDate, \"Position has no shares\");\n        }\n        if (position.exitDate != 0) {\n            revert InvalidPosition(user, position.shares, position.exitDate, \"Position has already exited\");\n        }\n    }\n\n    // ============ UUPS Upgrade Authorization ============\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract\n     * @param newImplementation Address of the new implementation\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyProtocolAdmin {\n        // Only protocol admin can upgrade\n        // Additional checks can be added here (e.g., timelock, phase restrictions)\n    }\n}\n"
    },
    "src/StreamFull.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title StreamFull\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Full-featured stream implementation with vesting and pool creation\n * @dev This contract extends StreamCore to include all available features:\n *      - Vesting for creators and beneficiaries\n *      - Automated liquidity pool creation\n *      - Permit2 subscription support (optional)\n *      This implementation combines logic from StreamWithVesting and StreamWithPool.\n */\n\nimport { StreamCore } from \"./StreamCore.sol\";\nimport { StreamTypes } from \"./types/StreamTypes.sol\";\nimport { StreamFactoryTypes } from \"./types/StreamFactoryTypes.sol\";\nimport { IStreamFactoryParams } from \"./interfaces/IStreamFactoryParams.sol\";\nimport { IVestingFactory } from \"./interfaces/IVestingFactory.sol\";\nimport { PoolWrapperTypes } from \"./types/PoolWrapperTypes.sol\";\nimport { IPoolRouter } from \"./interfaces/IPoolRouter.sol\";\nimport { PoolRouterTypes } from \"./types/PoolRouterTypes.sol\";\nimport { DecimalMath, Decimal } from \"./lib/math/DecimalMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { TransferLib } from \"./lib/TransferLib.sol\";\nimport { IPermit2 } from \"./interfaces/IPermit2.sol\";\n\ncontract StreamFull is StreamCore {\n    string public constant VERSION = \"1.0.0\";\n    string public constant VARIANT = \"Full\";\n\n    // ============ Override Hooks ============\n\n    /**\n     * @dev Hook called during initialization to validate configurations\n     * @param createStreamMessage Stream creation parameters\n     */\n    function _onInitialize(StreamTypes.CreateStreamMessage memory createStreamMessage) internal override {\n        // Validate vesting configurations\n        if (createStreamMessage.creatorVesting.isVestingEnabled) {\n            if (createStreamMessage.creatorVesting.vestingDuration == 0) {\n                revert InvalidVestingDuration();\n            }\n        }\n        \n        if (createStreamMessage.beneficiaryVesting.isVestingEnabled) {\n            if (createStreamMessage.beneficiaryVesting.vestingDuration == 0) {\n                revert InvalidVestingDuration();\n            }\n        }\n\n        // Validate pool config if pool creation is enabled\n        if (createStreamMessage.poolInfo.poolOutSupplyAmount > 0) {\n            // Validate pool amount is less than or equal to out amount\n            if (createStreamMessage.poolInfo.poolOutSupplyAmount > createStreamMessage.streamOutAmount) {\n                revert InvalidPoolOutSupplyAmount();\n            }\n            \n            // Validate pool type\n            if (createStreamMessage.poolInfo.dexType != StreamTypes.DexType.V2 && \n                createStreamMessage.poolInfo.dexType != StreamTypes.DexType.V3 &&\n                createStreamMessage.poolInfo.dexType != StreamTypes.DexType.Aerodrome) {\n                revert InvalidPoolType();\n            }\n        }\n    }\n\n    /**\n     * @dev Hook called when a user exits successfully (threshold met)\n     * @param user Address of the exiting user\n     * @param purchased Amount of output tokens purchased\n     * @param inRefunded Amount of input tokens refunded\n     */\n    function _onExitSuccess(address user, uint256 purchased, uint256 inRefunded) internal override {\n        // Handle unused input tokens refund (if any)\n        if (inRefunded > 0) {\n            TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), user, inRefunded);\n        }\n\n        // Handle output tokens - either vest or transfer directly\n        if (postStreamActions.beneficiaryVesting.isVestingEnabled && purchased > 0) {\n            // Create vesting wallet for beneficiary\n            _createBeneficiaryVesting(user, purchased);\n        } else if (purchased > 0) {\n            // Direct transfer if vesting is not enabled\n            TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), user, purchased);\n        }\n    }\n\n    /**\n     * @dev Hook called before finalizing a successful stream\n     * @param creatorRevenue Original creator revenue\n     * @return adjustedCreatorRevenue Revenue after pool allocation\n     */\n    function _beforeFinalizeSuccess(uint256 creatorRevenue) internal view\n     override returns (uint256 adjustedCreatorRevenue) {\n        // If no pool creation, return original revenue\n        if (postStreamActions.poolInfo.poolOutSupplyAmount == 0) {\n            return creatorRevenue;\n        }\n\n        // Calculate pool ratio based on output token allocation\n        Decimal memory poolRatio = DecimalMath.div(\n            DecimalMath.fromNumber(postStreamActions.poolInfo.poolOutSupplyAmount),\n            DecimalMath.fromNumber(streamState.outSupply)\n        );\n\n        // Calculate input token amount for pool (proportional to output allocation)\n        Decimal memory decimalCreatorRevenue = DecimalMath.fromNumber(creatorRevenue);\n        Decimal memory decimalPoolAmount = DecimalMath.mul(decimalCreatorRevenue, poolRatio);\n        uint256 poolInSupplyAmount = DecimalMath.floor(decimalPoolAmount);\n\n        // Adjust creator revenue by subtracting pool allocation\n        return creatorRevenue - poolInSupplyAmount;\n    }\n\n    /**\n     * @dev Hook called after finalizing a successful stream\n     * @param creatorRevenue Amount of input tokens for creator (after pool adjustment)\n     * @param outRemaining Remaining output tokens\n     */\n    function _afterFinalizeSuccess(uint256 creatorRevenue, uint256 outRemaining) internal override {\n        // Handle pool creation first if configured\n        if (postStreamActions.poolInfo.poolOutSupplyAmount > 0) {\n            // Calculate pool amounts\n            Decimal memory poolRatio = DecimalMath.div(\n                DecimalMath.fromNumber(postStreamActions.poolInfo.poolOutSupplyAmount),\n                DecimalMath.fromNumber(streamState.outSupply)\n            );\n\n            // Calculate original revenue before adjustment\n            uint256 originalRevenue = DecimalMath.floor(\n                DecimalMath.div(\n                    DecimalMath.fromNumber(creatorRevenue),\n                    DecimalMath.sub(DecimalMath.fromNumber(1), poolRatio)\n                )\n            );\n\n            uint256 poolInSupplyAmount = originalRevenue - creatorRevenue;\n            uint256 poolOutSupplyAmount = postStreamActions.poolInfo.poolOutSupplyAmount;\n\n            // Create pool and add liquidity\n            _createPoolAndAddLiquidity(\n                streamTokens.inSupplyToken,\n                streamTokens.outSupplyToken,\n                poolInSupplyAmount,\n                poolOutSupplyAmount,\n                postStreamActions.poolInfo.dexType,\n                creator\n            );\n        }\n\n        // Handle remaining output tokens (always direct transfer)\n        if (outRemaining > 0) {\n            TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), creator, outRemaining);\n        }\n\n        // Handle creator revenue - either vest or transfer directly\n        if (postStreamActions.creatorVesting.isVestingEnabled && creatorRevenue > 0) {\n            // Create vesting wallet for creator\n            _createCreatorVesting(creatorRevenue);\n        } else if (creatorRevenue > 0) {\n            // Direct transfer if vesting is not enabled\n            TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), creator, creatorRevenue);\n        }\n    }\n\n    // ============ Permit2 Support ============\n\n    /**\n     * @dev Allows users to subscribe using Permit2 signature-based allowance\n     * @param amountIn Amount of input tokens user wants to contribute\n     * @param owner Address that actually holds the tokens (signer of permit)\n     * @param permitSingle Full Permit2 data struct describing the allowance\n     * @param signature EIP-712 signature over `permitSingle`\n     */\n    function subscribeWithPermit(\n        uint256 amountIn,\n        address owner,\n        IPermit2.PermitSingle calldata permitSingle,\n        bytes calldata signature\n    ) external {\n        // Validate the permit matches the stream requirements\n        if (permitSingle.details.token != streamTokens.inSupplyToken) revert InvalidAmount();\n        if (permitSingle.details.amount < uint160(amountIn)) revert InvalidAmount();\n        if (permitSingle.spender != address(this)) revert InvalidAmount();\n        if (permitSingle.sigDeadline < block.timestamp) revert InvalidAmount();\n\n        // Execute Permit2 flow\n        IPermit2 permit2 = IPermit2(PERMIT2);\n        // 1. Validate & store allowance via signature\n        permit2.permit(owner, permitSingle, signature);\n        // 2. Pull tokens from owner to the stream contract\n        permit2.transferFrom(owner, address(this), uint160(amountIn), streamTokens.inSupplyToken);\n\n        // Tokens are now in this contract  proceed with core logic\n        _subscribeCore(amountIn);\n    }\n\n    // ============ Internal Helper Functions - Vesting ============\n\n    /**\n     * @dev Creates a vesting wallet for the beneficiary\n     * @param beneficiary Address of the beneficiary\n     * @param amount Amount of tokens to vest\n     */\n    function _createBeneficiaryVesting(address beneficiary, uint256 amount) internal {\n        IStreamFactoryParams factoryContract = IStreamFactoryParams(STREAM_FACTORY_ADDRESS);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n        IVestingFactory vestingFactory = IVestingFactory(params.vestingFactoryAddress);\n\n        // Approve tokens to vesting factory\n        IERC20(streamTokens.outSupplyToken).approve(params.vestingFactoryAddress, amount);\n        \n        // Create vesting wallet\n        address vestingAddress = vestingFactory.createVestingWalletWithTokens(\n            beneficiary,\n            uint64(block.timestamp),\n            postStreamActions.beneficiaryVesting.vestingDuration,\n            streamTokens.outSupplyToken,\n            amount\n        );\n\n        emit BeneficiaryVestingCreated(\n            beneficiary,\n            vestingAddress,\n            postStreamActions.beneficiaryVesting.vestingDuration,\n            streamTokens.outSupplyToken,\n            amount\n        );\n    }\n\n    /**\n     * @dev Creates a vesting wallet for the creator\n     * @param amount Amount of tokens to vest\n     */\n    function _createCreatorVesting(uint256 amount) internal {\n        IStreamFactoryParams factoryContract = IStreamFactoryParams(STREAM_FACTORY_ADDRESS);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n        IVestingFactory vestingFactory = IVestingFactory(params.vestingFactoryAddress);\n\n        // Approve tokens to vesting factory\n        IERC20(streamTokens.inSupplyToken).approve(params.vestingFactoryAddress, amount);\n        \n        // Create vesting wallet\n        address vestingAddress = vestingFactory.createVestingWalletWithTokens(\n            creator,\n            uint64(block.timestamp),\n            postStreamActions.creatorVesting.vestingDuration,\n            streamTokens.inSupplyToken,\n            amount\n        );\n\n        emit CreatorVestingCreated(\n            creator,\n            vestingAddress,\n            postStreamActions.creatorVesting.vestingDuration,\n            streamTokens.inSupplyToken,\n            amount\n        );\n    }\n\n    // ============ Internal Helper Functions - Pool ============\n\n    /**\n     * @dev Creates a pool and adds liquidity using the pool wrapper\n     * @param tokenA First token address\n     * @param tokenB Second token address\n     * @param amountADesired Amount of token A to add\n     * @param amountBDesired Amount of token B to add\n     * @param dexType Type of DEX (V2, V3, or Aerodrome)\n     * @param streamCreator Address of the stream creator\n     */\n    function _createPoolAndAddLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        StreamTypes.DexType dexType,\n        address streamCreator\n    ) internal {\n        IStreamFactoryParams factoryContract = IStreamFactoryParams(STREAM_FACTORY_ADDRESS);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n        address router = params.poolRouterAddress;\n        if (router == address(0)) revert InvalidDexType();\n\n        // Transfer pool tokens to the router contract first\n        TransferLib.transferFunds(tokenA, address(this), router, amountADesired);\n        TransferLib.transferFunds(tokenB, address(this), router, amountBDesired);\n\n        // Sort tokens\n        (address token0, address token1, uint256 amount0Desired, uint256 amount1Desired) = _sortTokens(\n            tokenA,\n            tokenB,\n            amountADesired,\n            amountBDesired\n        );\n\n        // Create the router request and get the result\n        IPoolRouter poolRouter = IPoolRouter(router);\n        PoolRouterTypes.CreatePoolRequest memory req = PoolRouterTypes.CreatePoolRequest({\n            tokenA: token0,\n            tokenB: token1,\n            amountADesired: amount0Desired,\n            amountBDesired: amount1Desired,\n            dexType: dexType,\n            extra: postStreamActions.poolInfo.extra,\n            creator: streamCreator\n        });\n\n        PoolWrapperTypes.CreatedPoolInfo memory createdPoolInfo = poolRouter.createPool(req);\n\n        // Map refunds so that refundedAmount0 (out) and refundedAmount1 (in) match token semantics\n        uint256 refundedOut = createdPoolInfo.token0 == streamTokens.outSupplyToken\n            ? createdPoolInfo.refundedAmount0\n            : createdPoolInfo.refundedAmount1;\n        uint256 refundedIn = createdPoolInfo.token0 == streamTokens.inSupplyToken\n            ? createdPoolInfo.refundedAmount0\n            : createdPoolInfo.refundedAmount1;\n\n        emit PoolCreated(\n            address(this),\n            createdPoolInfo.poolAddress,\n            createdPoolInfo.token0,\n            createdPoolInfo.token1,\n            createdPoolInfo.amount0,\n            createdPoolInfo.amount1,\n            refundedOut,\n            refundedIn,\n            createdPoolInfo.creator\n        );\n    }\n\n    /**\n     * @dev Sorts tokens and their amounts to ensure consistent ordering\n     * @param tokenA First token address\n     * @param tokenB Second token address\n     * @param amountA Amount of first token\n     * @param amountB Amount of second token\n     * @return token0 Lower address token\n     * @return token1 Higher address token\n     * @return amount0Desired Amount for token0\n     * @return amount1Desired Amount for token1\n     */\n    function _sortTokens(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB\n    ) internal pure returns (address token0, address token1, uint256 amount0Desired, uint256 amount1Desired) {\n        if (tokenA < tokenB) {\n            return (tokenA, tokenB, amountA, amountB);\n        }\n        return (tokenB, tokenA, amountB, amountA);\n    }\n\n    /**\n     * @dev Returns the implementation name for identification\n     * @return Implementation name and version\n     */\n    function implementation() external pure returns (string memory) {\n        return string(abi.encodePacked(\"StreamFull v\", VERSION));\n    }\n}\n"
    },
    "src/types/PoolRouterTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { StreamTypes } from \"./StreamTypes.sol\";\n\nlibrary PoolRouterTypes {\n    struct V3Extra {\n        uint24 fee;\n    }\n\n    struct AerodromeExtra {\n        bool stable;\n    }\n\n    struct CreatePoolRequest {\n        address tokenA;\n        address tokenB;\n        uint256 amountADesired;\n        uint256 amountBDesired;\n        StreamTypes.DexType dexType;\n        bytes extra;        // abi-encoded per-dex extra params\n        address creator;    // LP recipient/refund target\n    }\n}\n\n\n"
    },
    "src/types/PoolWrapperTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nlibrary PoolWrapperTypes {\n    struct CreatePoolMsg {\n        address token0;\n        address token1;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        address creator;\n        bytes extra; // abi-encoded per-dex parameters (optional)\n    }\n\n    struct CreatedPoolInfo {\n        address poolAddress;\n        address token0;\n        address token1;\n        uint256 amount0;\n        uint256 amount1;\n        address creator;\n        uint256 refundedAmount0;\n        uint256 refundedAmount1;\n    }\n}\n"
    },
    "src/types/PositionTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\nlibrary PositionTypes {\n    struct Position {\n        uint256 inBalance;\n        uint256 shares;\n        Decimal index;\n        uint256 lastUpdateTime;\n        Decimal pendingReward;\n        uint256 spentIn;\n        uint256 purchased;\n        uint256 exitDate;\n    }\n}\n"
    },
    "src/types/StreamFactoryTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\nlibrary StreamFactoryTypes {\n    struct Params {\n        uint256 streamCreationFee;\n        address streamCreationFeeToken;\n        Decimal exitFeeRatio;\n        uint256 minWaitingDuration;\n        uint256 minBootstrappingDuration;\n        uint256 minStreamDuration;\n        address feeCollector;\n        address protocolAdmin;\n        string tosVersion;\n        address vestingFactoryAddress;\n        address poolRouterAddress;\n        address tokenFactoryAddress;\n    }\n\n    struct InitializeStreamFactoryMessage {\n        uint256 streamCreationFee;\n        address streamCreationFeeToken;\n        Decimal exitFeeRatio;\n        uint256 minWaitingDuration;\n        uint256 minBootstrappingDuration;\n        uint256 minStreamDuration;\n        address feeCollector;\n        address protocolAdmin;\n        string tosVersion;\n        address poolRouterAddress;\n        // Variant implementations\n        address basicImplementationAddress;\n        address withVestingImplementationAddress;\n        address withPoolImplementationAddress;\n        address fullImplementationAddress;\n        address[] acceptedInSupplyTokens;\n        address tokenFactoryAddress;\n    }\n}\n"
    },
    "src/types/StreamTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\nlibrary StreamTypes {\n    enum Status {\n        Waiting,\n        Bootstrapping,\n        Active,\n        Ended,\n        FinalizedRefunded,\n        FinalizedStreamed,\n        Cancelled\n    }\n\n    enum DexType {\n            V2,\n            V3,\n            Aerodrome\n    }\n\n    struct CreateStreamMessage {\n        address creator;\n        address inSupplyToken;\n        address outSupplyToken;\n        uint256 streamOutAmount;\n        uint256 threshold;\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n        StreamMetadata metadata;\n        VestingInfo creatorVesting;\n        VestingInfo beneficiaryVesting;\n        PoolInfo poolInfo;\n        string tosVersion;\n    }\n    struct StreamTimes {\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n    }\n\n    struct StreamMetadata {\n        string ipfsHash;\n    }\n\n    struct StreamState {\n        uint256 outRemaining;\n        Decimal distIndex;\n        uint256 spentIn;\n        uint256 shares;\n        Decimal currentStreamedPrice;\n        uint256 threshold;\n        uint256 inSupply;\n        uint256 outSupply;\n        uint256 lastUpdated;\n    }\n\n    struct StreamTokens {\n        address inSupplyToken;\n        address outSupplyToken;\n    }\n\n    struct VestingInfo {\n        bool isVestingEnabled;\n        uint64 vestingDuration;\n    }\n\n    struct PoolInfo {\n        uint256 poolOutSupplyAmount;\n        DexType dexType;\n        bytes extra; // abi-encoded dex-specific params (see PoolRouterTypes)\n    }\n\n \n    struct PostStreamActions {\n        PoolInfo poolInfo;\n        VestingInfo creatorVesting;\n        VestingInfo beneficiaryVesting;\n    }\n\n    struct TokenCreationInfo {\n        string name;\n        string symbol;\n        uint8 decimals;\n        uint256 totalSupply;\n    }\n}\n"
    },
    "src/V3PoolWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { PoolWrapper } from \"./PoolWrapper.sol\";\nimport { TickMath } from \"./lib/math/TickMath.sol\";\n\nimport { PoolWrapperTypes } from \"./types/PoolWrapperTypes.sol\";\nimport { IUniswapV3Factory, IUniswapV3Pool, INonfungiblePositionManager } from \"./interfaces/IUniswapV3.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * @title V3PoolWrapper\n * @notice Wrapper for creating v3 pools and adding liquidity within a price range\n */\ncontract V3PoolWrapper is PoolWrapper {\n    address public immutable UNISWAP_V3_FACTORY;\n    address public immutable NONFUNGIBLE_POSITION_MANAGER;\n    uint24 public immutable FEE_TIER;\n\n    constructor(address factory, address positionManager, uint24 feeTier) {\n        if (factory == address(0)) revert InvalidAddress();\n        if (positionManager == address(0)) revert InvalidAddress();\n        if (feeTier == 0) revert InvalidAmount();\n\n        UNISWAP_V3_FACTORY = factory;\n        NONFUNGIBLE_POSITION_MANAGER = positionManager;\n        FEE_TIER = feeTier;\n    }\n\n    function _createPoolInternal(\n        PoolWrapperTypes.CreatePoolMsg calldata createPoolMsg\n    ) internal virtual override returns (address poolAddress, uint256 amount0, uint256 amount1, uint256 refundedAmount0, uint256 refundedAmount1) {\n        address token0 = createPoolMsg.token0;\n        address token1 = createPoolMsg.token1;\n        uint256 amount0Desired = createPoolMsg.amount0Desired;\n        uint256 amount1Desired = createPoolMsg.amount1Desired;\n\n        // Determine fee tier: prefer msg.extra if provided, otherwise fallback to immutable\n        uint24 feeTier = FEE_TIER;\n        if (createPoolMsg.extra.length > 0) {\n            uint24 decodedFee = abi.decode(createPoolMsg.extra, (uint24));\n            if (decodedFee == 0) revert InvalidAmount();\n            feeTier = decodedFee;\n        }\n\n        IUniswapV3Factory factory = IUniswapV3Factory(UNISWAP_V3_FACTORY);\n        poolAddress = factory.getPool(token0, token1, feeTier);\n\n        if (poolAddress == address(0)) {\n            // Set initial price so that token0/token1 reflects amount0Desired/amount1Desired\n            uint160 sqrtPriceX96 = _getSqrtPriceX96(amount0Desired, amount1Desired);\n            poolAddress = factory.createPool(token0, token1, feeTier);\n            if (poolAddress == address(0)) revert PoolCreationFailed();\n            IUniswapV3Pool(poolAddress).initialize(sqrtPriceX96);\n        }\n\n        IERC20(token0).approve(NONFUNGIBLE_POSITION_MANAGER, amount0Desired);\n        IERC20(token1).approve(NONFUNGIBLE_POSITION_MANAGER, amount1Desired);\n\n        // Safe tick calculation\n        {\n            int24 tickSpacing;\n            if (feeTier == 100) {\n                tickSpacing = 1;\n            } else if (feeTier == 500) {\n                tickSpacing = 10;\n            } else if (feeTier == 3000) {\n                tickSpacing = 60;\n            } else if (feeTier == 10000) {\n                tickSpacing = 200;\n            } else {\n                // default to 60 to avoid revert on uncommon fee tiers\n                tickSpacing = 60;\n            }\n            int24 currentTick = TickMath.getTickAtSqrtRatio(_getSqrtPriceX96(amount0Desired, amount1Desired));\n\n            // Create a wider range around the current price (10 tick spacings on each side)\n            int24 tickLower = ((currentTick - (tickSpacing * 10)) / tickSpacing) * tickSpacing;\n            int24 tickUpper = ((currentTick + (tickSpacing * 10)) / tickSpacing) * tickSpacing;\n\n            require(tickLower < tickUpper, \"Invalid tick range\");\n\n            INonfungiblePositionManager.MintParams memory params =\n                INonfungiblePositionManager.MintParams({\n                    token0: token0,\n                    token1: token1,\n                    fee: feeTier,\n                    tickLower: tickLower,\n                    tickUpper: tickUpper,\n                    amount0Desired: amount0Desired,\n                    amount1Desired: amount1Desired,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    recipient: createPoolMsg.creator,\n                    deadline: block.timestamp + 300\n                });\n\n            (, , amount0, amount1) = INonfungiblePositionManager(NONFUNGIBLE_POSITION_MANAGER).mint(params);\n            refundedAmount0 = createPoolMsg.amount0Desired - amount0;\n            refundedAmount1 = createPoolMsg.amount1Desired - amount1;\n        }\n        return (poolAddress, amount0, amount1, refundedAmount0, refundedAmount1);\n    }\n\n    function _getFactory() internal view virtual override returns (address) {\n        return UNISWAP_V3_FACTORY;\n    }\n\n    function _getRouter() internal view virtual override returns (address) {\n        return NONFUNGIBLE_POSITION_MANAGER;\n    }\n\n    function _getSqrtPriceX96(uint256 amount1, uint256 amount0) internal pure returns (uint160 sqrtPriceX96) {\n        if (amount0 == 0) revert InvalidAmount();\n        if (amount1 == 0) return 0;\n\n        uint256 priceX128 = (amount1 << 128) / amount0;\n        uint256 sqrtPriceX64 = _sqrt(priceX128);\n        uint256 result = sqrtPriceX64 << 32;\n        require(result <= type(uint160).max, \"R\");\n        sqrtPriceX96 = uint160(result);\n    }\n\n    function _sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) return 0;\n        uint256 z = (x + 1) / 2;\n        uint256 y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        return y;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}