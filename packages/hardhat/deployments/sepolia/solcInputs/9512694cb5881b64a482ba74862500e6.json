{
  "language": "Solidity",
  "sources": {
    "contracts/DecimalMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title DecimalMath\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\nlibrary DecimalMath {\n    // We'll use 6 decimal places for precision\n    uint256 public constant DECIMAL_PRECISION = 1e6;\n    \n    // Convert a regular number to a decimal representation\n    function fromNumber(uint256 value) internal pure returns (uint256) {\n        return value * DECIMAL_PRECISION;\n    }\n    function floor(uint256 value) internal pure returns (uint256) {\n        return value / DECIMAL_PRECISION;\n    }\n    function ceil(uint256 value) internal pure returns (uint256) {\n        return (value + DECIMAL_PRECISION - 1) / DECIMAL_PRECISION;\n    }\n    \n    // Multiply two decimal numbers\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * b) / DECIMAL_PRECISION;\n    }\n    \n    // Divide two decimal numbers\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * DECIMAL_PRECISION) / b;\n    }\n    \n    // Add two decimal numbers\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n    \n    // Subtract two decimal numbers\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n}"
    },
    "contracts/PositionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./PositionTypes.sol\";   \n\ncontract PositionStorage {\n    using PositionTypes for PositionTypes.Position;\n\n    mapping(address => PositionTypes.Position) private positions;\n    address public immutable streamContractAddress;\n\n    constructor() {\n        streamContractAddress = msg.sender;\n    }\n\n    function getPosition(address _owner) external view returns (PositionTypes.Position memory) {\n        return positions[_owner];\n    }\n\n    modifier onlySender() {\n        require(msg.sender == streamContractAddress, \"Position can only be set by the stream contract\");\n        _;\n    }\n\n    function createPosition(\n        address owner,\n        uint256 inBalance,\n        uint256 shares,\n        uint256 index\n    ) external onlySender {\n        positions[owner] = PositionTypes.Position(inBalance, shares, index, block.timestamp, 0, 0, 0, 0);\n    }\n\n    function updatePosition(\n        address owner,\n        PositionTypes.Position memory position\n    ) external onlySender {\n        positions[owner] = position;\n    }\n\n    function setExitDate(address owner, uint256 exitDate) external onlySender {\n        positions[owner].exitDate = exitDate;\n    }\n}\n"
    },
    "contracts/PositionTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary PositionTypes {\n    struct Position {\n        uint256 inBalance;\n        uint256 shares;\n        uint256 index;\n        uint256 lastUpdateTime;\n        uint256 pendingReward;\n        uint256 spentIn;\n        uint256 purchased;\n        uint256 exitDate;\n    }\n} "
    },
    "contracts/Stream.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./PositionStorage.sol\";\nimport \"./PositionTypes.sol\";\nimport \"./StreamEvents.sol\";\nimport \"./StreamErrors.sol\";\nimport \"./StreamTypes.sol\";\nimport \"./StreamFactory.sol\";\nimport \"./DecimalMath.sol\";\nimport \"./StreamMathLib.sol\";\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract Stream is IStreamErrors, IStreamEvents {\n    address public creator;\n    address public positionStorageAddress;\n    string public name;\n\n    IStreamTypes.StreamState public streamState;\n    IStreamTypes.StreamMetadata public streamMetadata;\n    IStreamTypes.StatusInfo public streamStatus;\n    IStreamTypes.StreamTimes public streamTimes;\n    IStreamTypes.StreamTokens public streamTokens;\n    address public factory;\n\n    PositionStorage public positionStorage;\n\n    // constructor should return its address\n    constructor(\n        uint256 _streamOutAmount,\n        address _outSupplyToken,\n        uint256 _bootstrappingStartTime,\n        uint256 _streamStartTime,\n        uint256 _streamEndTime,\n        uint256 _threshold,\n        string memory _name,\n        address _inSupplyToken,\n        address _creator\n    ) {\n        // Validate that output token is a valid ERC20\n        if (!isValidERC20(_outSupplyToken, msg.sender)) {\n            revert InvalidOutSupplyToken();\n        }\n\n        // Check if the contract has enough balance of output token\n        if (!hasEnoughBalance(_outSupplyToken, address(this), _streamOutAmount)) {\n            revert InsufficientOutAmount();\n        }\n\n        // Validate that in token is a valid ERC20\n        if (!isValidERC20(_inSupplyToken, msg.sender)) {\n            revert InvalidInSupplyToken();\n        }\n\n        creator = _creator;\n        positionStorage = new PositionStorage();\n        positionStorageAddress = address(positionStorage);\n\n        streamState = IStreamTypes.StreamState({\n            distIndex: 0,\n            outRemaining: _streamOutAmount,\n            inSupply: 0,\n            spentIn: 0,\n            shares: 0,\n            currentStreamedPrice: 0,\n            threshold: _threshold,\n            outSupply: _streamOutAmount,\n            lastUpdated: block.timestamp\n        });\n\n        streamTokens = IStreamTypes.StreamTokens({ inSupplyToken: _inSupplyToken, outSupplyToken: _outSupplyToken });\n\n        streamMetadata = IStreamTypes.StreamMetadata({ name: _name });\n\n        streamStatus.mainStatus = IStreamTypes.Status.Waiting;\n\n        streamTimes = IStreamTypes.StreamTimes({\n            bootstrappingStartTime: _bootstrappingStartTime,\n            streamStartTime: _streamStartTime,\n            streamEndTime: _streamEndTime\n        });\n\n        // Store the factory address\n        factory = msg.sender;\n    }\n\n    /**\n     * @dev Updates the stream status based on the current timestamp\n     */\n    function syncStreamStatus() internal {\n        streamStatus.mainStatus = StreamMathLib.calculateStreamStatus(\n            streamStatus.mainStatus,\n            block.timestamp,\n            streamTimes.bootstrappingStartTime,\n            streamTimes.streamStartTime,\n            streamTimes.streamEndTime\n        );\n    }\n\n    function computeSharesAmount(\n        uint256 amountIn,\n        bool roundUp,\n        uint256 inSupply,\n        uint256 totalShares\n    ) internal pure returns (uint256) {\n        if (totalShares == 0 || amountIn == 0) {\n            return amountIn;\n        }\n\n        uint256 totalSharesIn = totalShares * amountIn;\n        if (roundUp) {\n            return (totalSharesIn + inSupply - 1) / inSupply;\n        } else {\n            return totalSharesIn / inSupply;\n        }\n    }\n\n    function syncStream() internal {\n        uint256 diff = StreamMathLib.calculateDiff(\n            block.timestamp,\n            streamTimes.streamStartTime,\n            streamTimes.streamEndTime,\n            streamState.lastUpdated\n        );\n\n        if (diff > 0) {\n            // Get updated state without modifying storage yet\n            IStreamTypes.StreamState memory updatedState = StreamMathLib.calculateUpdatedState(streamState, diff);\n\n            // Update storage with the new state\n            streamState = updatedState;\n        }\n\n        streamState.lastUpdated = block.timestamp;\n    }\n\n    /**\n     * @dev Validates if an operation is allowed based on the current stream status\n     * @param allowedStatuses Array of allowed statuses for the operation\n     * @return bool True if the operation is allowed, false otherwise\n     */\n    function isOperationAllowed(IStreamTypes.Status[] memory allowedStatuses) internal view returns (bool) {\n        for (uint256 i = 0; i < allowedStatuses.length; i++) {\n            if (streamStatus.mainStatus == allowedStatuses[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Safely transfers tokens from the contract to a recipient\n     * @param tokenAddress Address of the token to transfer\n     * @param recipient Address of the recipient\n     * @param amount Amount of tokens to transfer\n     * @return bool True if the transfer was successful\n     */\n    function safeTokenTransfer(address tokenAddress, address recipient, uint256 amount) internal returns (bool) {\n        if (amount == 0 || recipient == address(0)) {\n            return true;\n        }\n\n        IERC20 token = IERC20(tokenAddress);\n        bool success = token.transfer(recipient, amount);\n        if (!success) {\n            revert PaymentFailed();\n        }\n        return true;\n    }\n\n    /**\n     * @dev Calculates the exit fee amount based on the spent in amount\n     * @param spentInAmount Amount of tokens spent in the stream\n     * @return feeAmount The calculated fee amount\n     * @return remainingAmount The remaining amount after fee deduction\n     */\n    function calculateExitFee(\n        uint256 spentInAmount\n    ) internal view returns (uint256 feeAmount, uint256 remainingAmount) {\n        StreamFactory factoryContract = StreamFactory(factory);\n        StreamFactory.Params memory params = factoryContract.getParams();\n        uint256 decimalExitFee = params.exitFeePercent;\n\n        // Calculate exit fee amount using DecimalMath\n        uint256 decimalSpentIn = DecimalMath.fromNumber(spentInAmount);\n        uint256 exitFeeAmount = DecimalMath.mul(decimalSpentIn, decimalExitFee);\n        feeAmount = DecimalMath.floor(exitFeeAmount);\n        remainingAmount = spentInAmount - feeAmount;\n\n        return (feeAmount, remainingAmount);\n    }\n\n    /**\n     * @dev Checks if the threshold has been reached for stream finalization\n     * @return bool True if the threshold has been reached, false otherwise\n     */\n    function isThresholdReached() internal view returns (bool) {\n        return streamState.spentIn >= streamState.threshold;\n    }\n\n    /**\n     * @dev Validates a position exists and is active\n     * @param position The position to validate\n     * @return bool True if the position is valid and active\n     */\n    function isValidActivePosition(PositionTypes.Position memory position) internal pure returns (bool) {\n        return position.shares > 0 && position.exitDate == 0;\n    }\n\n    function syncPosition(\n        PositionTypes.Position memory position,\n        uint256 distIndex,\n        uint256 shares,\n        uint256 inSupply,\n        uint256 nowTime\n    ) internal pure returns (PositionTypes.Position memory) {\n        // Create a new position in memory to store the updated values\n        PositionTypes.Position memory updatedPosition = PositionTypes.Position({\n            inBalance: position.inBalance,\n            shares: position.shares,\n            index: position.index,\n            lastUpdateTime: position.lastUpdateTime,\n            pendingReward: position.pendingReward,\n            spentIn: position.spentIn,\n            purchased: position.purchased,\n            exitDate: position.exitDate\n        });\n\n        // Calculate index difference for distributions since last update\n        uint256 indexDiff = distIndex - updatedPosition.index;\n        uint256 spent = 0;\n        uint256 purchased = 0;\n\n        // Only process if there are shares in the stream\n        if (shares > 0) {\n            // Calculate purchased amount based on position shares and index difference\n            uint256 positionPurchased = (updatedPosition.shares * indexDiff) / 1e18 + updatedPosition.pendingReward;\n            // Calculate remaining balance based on current shares ratio\n            uint256 inRemaining = (inSupply * updatedPosition.shares) / shares;\n            // Calculate spent amount\n            spent = updatedPosition.inBalance - inRemaining;\n            updatedPosition.spentIn += spent;\n            updatedPosition.inBalance = inRemaining;\n\n            // Update purchased amount\n            purchased = positionPurchased;\n            updatedPosition.purchased += purchased;\n        }\n\n        // Update position tracking\n        updatedPosition.index = distIndex;\n        updatedPosition.lastUpdateTime = nowTime;\n\n        return updatedPosition;\n    }\n\n    function withdraw(uint256 cap) external {\n        if (cap == 0) {\n            revert InvalidWithdrawAmount();\n        }\n        PositionTypes.Position memory position = positionStorage.getPosition(msg.sender);\n        if (position.shares == 0) {\n            revert OperationNotAllowed();\n        }\n\n        if (cap > position.inBalance) {\n            revert WithdrawAmountExceedsBalance(cap);\n        }\n\n        syncStreamStatus();\n\n        // Use the new internal function to check if operation is allowed\n        IStreamTypes.Status[] memory allowedStatuses = new IStreamTypes.Status[](2);\n        allowedStatuses[0] = IStreamTypes.Status.Active;\n        allowedStatuses[1] = IStreamTypes.Status.Bootstrapping;\n        if (!isOperationAllowed(allowedStatuses)) {\n            revert OperationNotAllowed();\n        }\n\n        syncStream();\n        position = syncPosition(\n            position,\n            streamState.distIndex,\n            streamState.shares,\n            streamState.inSupply,\n            block.timestamp\n        );\n\n        if (cap == position.inBalance) {\n            position.shares = 0;\n            position.inBalance = 0;\n        } else {\n            position.shares = position.shares - computeSharesAmount(cap, true, streamState.inSupply, position.shares);\n            position.inBalance = position.inBalance - cap;\n        }\n\n        positionStorage.updatePosition(msg.sender, position);\n        streamState.inSupply = streamState.inSupply - cap;\n        streamState.shares =\n            streamState.shares -\n            computeSharesAmount(cap, true, streamState.inSupply, streamState.shares);\n\n        // Use the new safeTokenTransfer function\n        safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, cap);\n        emit Withdrawn(msg.sender, cap);\n    }\n\n    function subscribe(uint256 amountIn) external payable {\n        // Get current status\n        syncStreamStatus();\n\n        // Use the new internal function to check if operation is allowed\n        IStreamTypes.Status[] memory allowedStatuses = new IStreamTypes.Status[](2);\n        allowedStatuses[0] = IStreamTypes.Status.Bootstrapping;\n        allowedStatuses[1] = IStreamTypes.Status.Active;\n        if (!isOperationAllowed(allowedStatuses)) {\n            revert OperationNotAllowed();\n        }\n\n        // Validate if sender has enough tokens\n        IERC20 streamInToken = IERC20(streamTokens.inSupplyToken);\n        uint256 streamInTokenBalance = streamInToken.balanceOf(msg.sender);\n        if (streamInTokenBalance < amountIn) {\n            revert InsufficientTokenPayment(amountIn, streamInTokenBalance);\n        }\n        // Transfer tokens from sender to this contract\n        bool success = streamInToken.transferFrom(msg.sender, address(this), amountIn);\n        if (!success) {\n            revert PaymentFailed();\n        }\n\n        // Query position from PositionStorage contract\n        PositionTypes.Position memory position = positionStorage.getPosition(msg.sender);\n        uint256 newShares = 0;\n\n        if (position.shares == 0) {\n            // New position case\n            // First sync the stream to ensure new tokens don't participate in previous distribution\n            syncStream();\n\n            // Calculate new shares (we'll implement this next)\n            newShares = computeSharesAmount(amountIn, false, streamState.inSupply, streamState.shares);\n            positionStorage.createPosition(msg.sender, amountIn, newShares, streamState.distIndex);\n        } else {\n            // Sync stream to ensure new tokens don't participate in previous distribution\n            syncStream();\n            // Calculate new shares (we'll implement this next)\n            newShares = computeSharesAmount(amountIn, false, streamState.inSupply, streamState.shares);\n            position = syncPosition(\n                position,\n                streamState.distIndex,\n                streamState.shares,\n                streamState.inSupply,\n                block.timestamp\n            );\n            position.inBalance += amountIn;\n            position.shares += newShares;\n            // Save position to PositionStorage contract\n            positionStorage.updatePosition(msg.sender, position);\n        }\n\n        // Update StreamState\n        streamState.inSupply += amountIn;\n        streamState.shares += newShares;\n\n        // Emit event\n        emit Subscribed(msg.sender, amountIn, newShares);\n    }\n\n    function exitStream() external {\n        PositionTypes.Position memory position = positionStorage.getPosition(msg.sender);\n\n        // Use the new isValidActivePosition function\n        if (!isValidActivePosition(position)) {\n            revert OperationNotAllowed();\n        }\n\n        // Sync stream\n        syncStream();\n        // Sync position\n        position = syncPosition(\n            position,\n            streamState.distIndex,\n            streamState.shares,\n            streamState.inSupply,\n            block.timestamp\n        );\n        // Check status\n        syncStreamStatus();\n\n        // Use the new isThresholdReached function\n        if (\n            (streamStatus.mainStatus == IStreamTypes.Status.Ended && isThresholdReached()) ||\n            (streamStatus.mainStatus == IStreamTypes.Status.Finalized &&\n                streamStatus.subStatus[IStreamTypes.Status.Finalized] == IStreamTypes.Substatus.Streamed)\n        ) {\n            // Normal exit\n            // Refund in_amount remaining if any in position\n            if (position.inBalance > 0) {\n                // Use the new safeTokenTransfer function\n                safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, position.inBalance);\n            }\n            // send out_amount earned to position owner\n            safeTokenTransfer(streamTokens.outSupplyToken, msg.sender, position.purchased);\n        } else {\n            // Refund total in_amount\n            uint256 total_amount = position.inBalance + position.spentIn;\n            // Use the new safeTokenTransfer function\n            safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, total_amount);\n        }\n        // Set exit date\n        positionStorage.setExitDate(msg.sender, block.timestamp);\n        emit Exited(msg.sender, position.purchased);\n        positionStorage.updatePosition(msg.sender, position);\n    }\n\n    function finalizeStream() external {\n        // Check is sender is the creator\n        if (msg.sender != creator) {\n            revert Unauthorized();\n        }\n        // Check status\n        syncStreamStatus();\n        // Finalize is only allowed if stream is ended\n        if (streamStatus.mainStatus != IStreamTypes.Status.Ended) {\n            revert OperationNotAllowed();\n        }\n        // Sync stream\n        syncStream();\n\n        // Use the new isThresholdReached function\n        if (isThresholdReached()) {\n            // Get fee collector from factory\n            StreamFactory factoryContract = StreamFactory(factory);\n            StreamFactory.Params memory params = factoryContract.getParams();\n            address feeCollector = params.feeCollector;\n\n            // Use the new calculateExitFee function\n            (uint256 feeAmount, uint256 creatorRevenue) = calculateExitFee(streamState.spentIn);\n\n            // Transfer fee to fee collector if needed\n            if (feeAmount > 0) {\n                safeTokenTransfer(streamTokens.inSupplyToken, feeCollector, feeAmount);\n            }\n\n            // Send revenue to creator\n            safeTokenTransfer(streamTokens.inSupplyToken, creator, creatorRevenue);\n\n            streamStatus.subStatus[IStreamTypes.Status.Finalized] = IStreamTypes.Substatus.Streamed;\n            streamStatus.mainStatus = IStreamTypes.Status.Finalized;\n\n            // Refund out tokens to creator if left any\n            if (streamState.outRemaining > 0) {\n                safeTokenTransfer(streamTokens.outSupplyToken, creator, streamState.outRemaining);\n            }\n        } else {\n            streamStatus.subStatus[IStreamTypes.Status.Finalized] = IStreamTypes.Substatus.Refunded;\n            streamStatus.mainStatus = IStreamTypes.Status.Finalized;\n            // Refund out tokens to creator\n            safeTokenTransfer(streamTokens.outSupplyToken, creator, streamState.outSupply);\n        }\n\n        emit StreamFinalized(\n            creator,\n            streamState.spentIn,\n            streamState.outRemaining,\n            streamStatus.subStatus[IStreamTypes.Status.Finalized]\n        );\n    }\n\n    function syncStreamExternal() external {\n        syncStream();\n        syncStreamStatus();\n    }\n\n    /**\n     * @dev Checks if an address is a valid ERC20 token\n     * @param tokenAddress The token address to validate\n     * @param testAccount The account to use for testing the token interface\n     * @return isValid True if the address implements the ERC20 interface\n     */\n    function isValidERC20(address tokenAddress, address testAccount) internal view returns (bool isValid) {\n        if (tokenAddress == address(0)) {\n            return false;\n        }\n\n        try IERC20(tokenAddress).balanceOf(testAccount) returns (uint256) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Checks if an account has sufficient token balance\n     * @param tokenAddress The ERC20 token address\n     * @param account The account to check balance for\n     * @param requiredAmount The minimum required balance\n     * @return hasEnoughBalance True if the account has sufficient balance\n     */\n    function hasEnoughBalance(\n        address tokenAddress,\n        address account,\n        uint256 requiredAmount\n    ) internal view returns (bool hasEnoughBalance) {\n        IERC20 token = IERC20(tokenAddress);\n        uint256 balance = token.balanceOf(account);\n        return balance >= requiredAmount;\n    }\n}\n"
    },
    "contracts/StreamErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IStreamErrors {\n    // Stream errors\n    error InvalidBootstrappingStartTime();\n    error InvalidStreamStartTime();\n    error InvalidStreamEndTime();\n    error StreamDurationTooShort();\n    error BootstrappingDurationTooShort();\n    error WaitingDurationTooShort();\n    error InsufficientTokenPayment(uint256 requiredTokenAmount, uint256 tokenBalance);\n    error InvalidOutSupplyToken();\n    error InvalidInSupplyToken();\n    error PaymentFailed();\n    error OperationNotAllowed();\n    error Unauthorized();\n    error InvalidWithdrawAmount();\n    error WithdrawAmountExceedsBalance(uint256 cap);\n    error InsufficientOutAmount();\n    // StreamFactory errors\n    error ContractFrozen();\n    error ZeroOutSupplyNotAllowed();\n    error StreamInputTokenNotAccepted();\n    error InvalidBootstrappingTime();\n    error StreamStartMustBeAfterBootstrapping();\n    error StreamEndMustBeAfterStart();\n    error InvalidToSVersion();\n    error InsufficientNativeToken();\n    error FeeTransferFailed();\n    error TokenTransferFailed();\n    error StreamAddressPredictionFailed();\n    error InvalidFeeCollector();\n    error InvalidProtocolAdmin();\n    error NotAdmin();\n} "
    },
    "contracts/StreamEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./StreamTypes.sol\";\n\ninterface IStreamEvents {\n        event StreamCreated(\n        uint256 indexed streamOutAmount,\n        uint256 indexed bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        address indexed streamAddress\n    );\n    \n    event StreamSynced(\n        IStreamTypes.Status mainStatus,\n        IStreamTypes.Substatus subStatus,\n        uint256 lastUpdated\n    );\n    \n    event Subscribed(address indexed subscriber, uint256 amountIn, uint256 newShares);\n    event Withdrawn(address indexed subscriber, uint256 amountIn);\n    event Exited(address indexed subscriber, uint256 purchased);\n    event StreamFinalized(address indexed creator, uint256 spentIn, uint256 outRemaining, IStreamTypes.Substatus subStatus);\n    event ParamsUpdated();\n    event FeeCollectorUpdated(address newFeeCollector);\n    event ProtocolAdminUpdated(address newProtocolAdmin);\n    event FrozenStateUpdated(bool frozen);\n}"
    },
    "contracts/StreamFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./Stream.sol\";\nimport \"./StreamEvents.sol\";\nimport \"./StreamErrors.sol\";\n\ncontract StreamFactory is IStreamEvents, IStreamErrors {\n    struct Params {\n        uint256 streamCreationFee;    // Fixed fee to create a stream\n        address streamCreationFeeToken; // Token used for creation fee,\n        uint256 exitFeePercent;       // Fee percentage when exiting a stream\n        uint256 minWaitingDuration;   // Minimum waiting period\n        uint256 minBootstrappingDuration;  // Minimum bootstrapping period\n        uint256 minStreamDuration;    // Minimum duration for a stream\n        address feeCollector;         // Address where fees are collected\n        address protocolAdmin;        // Admin address for protocol\n        string tosVersion;          // Terms of service version\n    }\n\n    mapping(address => bool) public acceptedInSupplyTokens;\n    \n    address public constant NATIVE_TOKEN = address(0);\n\n    uint16 public currentStreamId;\n    \n    Params public params;\n    mapping( uint16 => address) public streamAddresses;\n\n    bool public frozen;\n\n    constructor(\n        uint256 _streamCreationFee,\n        address _streamCreationFeeToken,\n        uint256 _exitFeePercent,\n        uint256 _minWaitingDuration,\n        uint256 _minBootstrappingDuration,\n        uint256 _minStreamDuration,\n        address[] memory _acceptedInSupplyTokens,\n        address _feeCollector,\n        address _protocolAdmin,\n        string memory _tosVersion\n    ) {\n        if (_feeCollector == address(0)) revert InvalidFeeCollector();\n        if (_protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        \n        params = Params({\n            streamCreationFee: _streamCreationFee,\n            streamCreationFeeToken: _streamCreationFeeToken,\n            exitFeePercent: _exitFeePercent,\n            minWaitingDuration: _minWaitingDuration,\n            minBootstrappingDuration: _minBootstrappingDuration,\n            minStreamDuration: _minStreamDuration,\n            feeCollector: _feeCollector,\n            protocolAdmin: _protocolAdmin,\n            tosVersion: _tosVersion\n        });\n\n        // Set accepted tokens\n        for (uint i = 0; i < _acceptedInSupplyTokens.length; i++) {\n            acceptedInSupplyTokens[_acceptedInSupplyTokens[i]] = true;\n        }\n        currentStreamId = 0;\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != params.protocolAdmin) revert NotAdmin();\n        _;\n    }\n\n    function updateParams(\n        uint256 _streamCreationFee,\n        uint256 _exitFeePercent,\n        uint256 _minWaitingDuration,\n        uint256 _minBootstrappingDuration,\n        uint256 _minStreamDuration,\n        string memory _tosVersion\n    ) external onlyAdmin {\n        params.streamCreationFee = _streamCreationFee;\n        params.exitFeePercent = _exitFeePercent;\n        params.minWaitingDuration = _minWaitingDuration;\n        params.minBootstrappingDuration = _minBootstrappingDuration;\n        params.minStreamDuration = _minStreamDuration;\n        params.tosVersion = _tosVersion;\n        \n        emit ParamsUpdated();\n    }\n\n    function updateFeeCollector(address _feeCollector) external onlyAdmin {\n        if (_feeCollector == address(0)) revert InvalidFeeCollector();\n        params.feeCollector = _feeCollector;\n        emit FeeCollectorUpdated(_feeCollector);\n    }\n\n    function updateProtocolAdmin(address _protocolAdmin) external onlyAdmin {\n        if (_protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        params.protocolAdmin = _protocolAdmin;\n        emit ProtocolAdminUpdated(_protocolAdmin);\n    }\n\n    function updateAcceptedTokens(address[] calldata tokens_to_add, address[] calldata tokens_to_remove) external onlyAdmin {\n        for (uint i = 0; i < tokens_to_add.length; i++) {\n            acceptedInSupplyTokens[tokens_to_add[i]] = true;\n        }\n        for (uint i = 0; i < tokens_to_remove.length; i++) {\n            acceptedInSupplyTokens[tokens_to_remove[i]] = false;\n        }\n    }\n\n    function isAcceptedInSupplyToken(address token) public view returns (bool) {\n        return acceptedInSupplyTokens[token];\n    }\n\n    function createStream(\n        uint256 _streamOutAmount,\n        address _outSupplyToken,\n        uint256 _bootstrappingStartTime,\n        uint256 _streamStartTime,\n        uint256 _streamEndTime,\n        uint256 _threshold,\n        string memory _name,\n        address _inSupplyToken,\n        string memory _tosVersion,\n        bytes32 _salt\n    ) external payable {\n        // Check if contract is accepting new streams (not frozen)\n        if (frozen) revert ContractFrozen();\n        \n        // Validate input parameters\n        if (_streamOutAmount == 0) revert ZeroOutSupplyNotAllowed();\n        if (!acceptedInSupplyTokens[_inSupplyToken]) revert StreamInputTokenNotAccepted();\n        \n        // Validate time parameters using validateStreamTimes\n        validateStreamTimes(\n            block.timestamp,\n            _bootstrappingStartTime,\n            _streamStartTime,\n            _streamEndTime\n        );\n        \n        // Validate TOS version\n        if (keccak256(abi.encodePacked(_tosVersion)) != keccak256(abi.encodePacked(params.tosVersion)))\n            revert InvalidToSVersion();\n\n        // Load creation fee\n        uint256 creationFee = params.streamCreationFee;\n        if (creationFee > 0) {\n            if (params.streamCreationFeeToken == address(0)) {\n                // Native token\n                if (msg.value < creationFee) revert InsufficientNativeToken();\n                // Transfer fee to fee collector\n                if (!payable(params.feeCollector).send(creationFee)) revert FeeTransferFailed();\n            } else {\n                // ERC20 token\n                if (!IERC20(params.streamCreationFeeToken).transferFrom(msg.sender, address(params.feeCollector), creationFee)) revert TokenTransferFailed();\n            }\n        }\n        // Increment stream id\n        currentStreamId++;\n        // Predict stream address\nbytes32 bytecodeHash = keccak256(abi.encodePacked(\n    type(Stream).creationCode,\n    abi.encode(\n        _streamOutAmount,\n        _outSupplyToken,\n        _bootstrappingStartTime,\n        _streamStartTime,\n        _streamEndTime,\n        _threshold,\n        _name,\n        _inSupplyToken,\n        msg.sender\n    )\n        ));\n\n        address predictedAddress = predictAddress(address(this), _salt, bytecodeHash);\n        // Transfer out denom to stream contract\n        if (!IERC20(_outSupplyToken).transferFrom(msg.sender, predictedAddress, _streamOutAmount)) revert TokenTransferFailed();\n        // Deploy new stream contract with all parameters\n        Stream newStream = new Stream{salt: _salt}(\n            _streamOutAmount,\n            _outSupplyToken,\n            _bootstrappingStartTime,\n            _streamStartTime,\n            _streamEndTime,\n            _threshold,\n            _name,\n            _inSupplyToken,\n            msg.sender\n            );\n\n        if (address(newStream) != predictedAddress) revert StreamAddressPredictionFailed();\n            \n\n        emit StreamCreated(\n            _streamOutAmount,\n            _bootstrappingStartTime,\n            _streamStartTime,\n            _streamEndTime,\n            address(newStream)\n        );\n    }\n\n    function getStreams() external view returns (address[] memory) {\n        address[] memory streams = new address[](currentStreamId);\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            streams[i] = streamAddresses[i];\n        }\n        return streams;\n    }\n\n    function getStream(uint16 _streamId) external view returns (address) {\n        return streamAddresses[_streamId];\n    }\n\n    function isStream(address _streamAddress) external view returns (bool) {\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            if (streamAddresses[i] == _streamAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getParams() external view returns (Params memory) {\n        return params;\n    }\n\n    // Optional: Add ability to transfer ownership\n    function transferOwnership(address newOwner) external onlyAdmin {\n        if (newOwner == address(0)) revert InvalidProtocolAdmin();\n        params.protocolAdmin = newOwner;\n    }\n\n    function setFrozen(bool _frozen) external onlyAdmin {\n        frozen = _frozen;\n        emit FrozenStateUpdated(_frozen);\n    }\n\n    function predictAddress(address creator, bytes32 _salt, bytes32 bytecodeHash) public pure returns (address) {\n        return address(uint160(uint(keccak256(abi.encodePacked(\n            bytes1(0xff),\n            creator,\n            _salt,\n            bytecodeHash\n        )))));\n    }\n\n    function validateStreamTimes(\n        uint256 nowTime,\n        uint256 _bootstrappingStartTime,\n        uint256 _startTime,\n        uint256 _endTime\n    ) internal view {\n        if (nowTime > _bootstrappingStartTime) revert InvalidBootstrappingStartTime();\n        if (_bootstrappingStartTime > _startTime) revert InvalidStreamStartTime();\n        if (_startTime > _endTime) revert InvalidStreamEndTime();\n        if (_endTime - _startTime < params.minStreamDuration) revert StreamDurationTooShort();\n        if (_startTime - _bootstrappingStartTime < params.minBootstrappingDuration) revert BootstrappingDurationTooShort();\n        if (_bootstrappingStartTime - nowTime < params.minWaitingDuration) revert WaitingDurationTooShort();\n    }\n\n} "
    },
    "contracts/StreamMathLib.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"./StreamTypes.sol\";\n\n\nlibrary StreamMathLib {\n\n\n    /**\n     * @dev Calculates the time difference ratio between current time and last updated time\n     * @param currentTimestamp Current timestamp\n     * @param streamStartTime Timestamp when the stream starts\n     * @param streamEndTime Timestamp when the stream ends\n     * @param lastUpdated Timestamp when the stream was last updated\n     * @return The ratio of time elapsed since last update compared to total remaining time (scaled by 1e18)\n     */\n    function calculateDiff(\n        uint256 currentTimestamp,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 lastUpdated\n    ) internal pure returns (uint256) {\n    // If the stream is not started yet or already ended, return 0\n    if (currentTimestamp < streamStartTime || lastUpdated >= streamEndTime) {\n        return 0;\n    }\n\n    // If lastUpdated is before start time, set it to start time\n    uint256 effectiveLastUpdated = lastUpdated;\n    if (effectiveLastUpdated < streamStartTime) {\n        effectiveLastUpdated = streamStartTime;\n    }\n\n    // If current time is past end time, use end time instead\n    uint256 effectiveNow = currentTimestamp;\n    if (effectiveNow > streamEndTime) {\n        effectiveNow = streamEndTime;\n    }\n\n    uint256 numerator = effectiveNow - effectiveLastUpdated;\n    uint256 denominator = streamEndTime - effectiveLastUpdated;\n\n    if (denominator == 0 || numerator == 0) {\n        return 0;\n    }\n    // Return ratio of time elapsed since last update compared to total remaining time\n    return (numerator * 1e18) / denominator;\n}\n\n\n    /**\n     * @dev Calculates the stream status based on the current state and timestamp\n     * @param currentStatus Current status of the stream\n     * @param currentTime Current timestamp to check against\n     * @param bootstrappingStartTime Timestamp when bootstrapping phase starts\n     * @param streamStartTime Timestamp when active streaming starts\n     * @param streamEndTime Timestamp when streaming ends\n     * @return IStreamTypes.Status The calculated stream status\n     */\n    function calculateStreamStatus(\n        IStreamTypes.Status currentStatus,\n        uint256 currentTime,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime\n    ) internal pure returns (IStreamTypes.Status) {\n        // Don't update if stream is in a final state\n        if (currentStatus == IStreamTypes.Status.Cancelled || \n            currentStatus == IStreamTypes.Status.Finalized) {\n            return currentStatus;\n        }\n        \n\n        // Update status based on current timestamp\n        if (currentTime < bootstrappingStartTime) {\n            return IStreamTypes.Status.Waiting;\n        } \n        else if (currentTime >= bootstrappingStartTime && \n                 currentTime < streamStartTime) {\n            return IStreamTypes.Status.Bootstrapping;\n        }\n        else if (currentTime >= streamStartTime && \n                 currentTime < streamEndTime) {\n            return IStreamTypes.Status.Active;\n        }\n        else if (currentTime >= streamEndTime) {\n            return IStreamTypes.Status.Ended;\n        }\n        \n        // This should never be reached, but return current status as fallback\n        return currentStatus;\n    }\n\n\n       /**\n     * @dev Calculates updated stream state based on time difference\n     * @param state Current stream state\n     * @param diff Time difference in seconds\n     * @return Updated stream state\n     */\n    function calculateUpdatedState(\n        IStreamTypes.StreamState memory state,\n        uint256 diff\n    ) internal pure returns (IStreamTypes.StreamState memory) {\n        // Create a copy of the state to avoid modifying the input\n        IStreamTypes.StreamState memory newState = state;\n        \n        if (newState.shares > 0 && diff > 0) {\n            // Calculate new distribution balance and spent in amount\n            uint256 newDistributionBalance = (newState.outRemaining * diff) / 1e18;\n            uint256 spentIn = (newState.inSupply * diff) / 1e18;\n\n            // Update state variables\n            newState.spentIn += spentIn;\n            newState.inSupply -= spentIn;\n\n            if (newDistributionBalance > 0) {\n                newState.outRemaining -= newDistributionBalance;\n                // Update distribution index (shares are in base units, multiply by 1e18 for precision)\n                newState.distIndex += (newDistributionBalance * 1e18) / newState.shares;\n                // Update current streamed price\n                newState.currentStreamedPrice = (spentIn * 1e18) / newDistributionBalance;\n            }\n        }\n        \n        return newState;\n    }\n\n}"
    },
    "contracts/StreamTest.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity >=0.8.0 <0.9.0;\n\n// import \"./Stream.sol\";\n\n// import { StreamFactory } from \"./StreamFactory.sol\";\n\n// /**\n//  * @title StreamTest\n//  * @dev This contract is used for testing internal functions of the Stream contract\n//  */\n// contract StreamTest is Stream{\n//     constructor(\n//         uint256 _streamOutAmount,\n//         address _outSupplyToken,\n//         uint256 _bootstrappingStartTime,\n//         uint256 _streamStartTime,\n//         uint256 _streamEndTime,\n//         uint256 _threshold,\n//         string memory _name,\n//         address _inSupplyToken,\n//         address _creator\n//     ) Stream(\n//         _streamOutAmount,\n//         _outSupplyToken,\n//         _bootstrappingStartTime,\n//         _streamStartTime,\n//         _streamEndTime,\n//         _threshold,\n//         _name,\n//         _inSupplyToken,\n//         _creator\n//     ) {}\n\n//     function test_calculateDiff() public view returns (uint256) {\n//         return calculateDiff();\n//     }\n\n//     function test_computeSharesAmount(uint256 amountIn, bool roundUp) public view returns (uint256) {\n//         return computeSharesAmount(amountIn, roundUp);\n//     }\n\n//     function test_syncPosition(PositionTypes.Position memory position , uint256 distIndex, uint256 shares, address inSupply, uint256 timestamp) public view returns (PositionTypes.Position memory) {\n//     }\n\n//     // Test functions for the new internal functions\n    \n//     function test_isOperationAllowed(IStreamTypes.Status[] memory allowedStatuses) public view returns (bool) {\n//         return isOperationAllowed(allowedStatuses);\n//     }\n    \n//     function test_safeTokenTransfer(address tokenAddress, address recipient, uint256 amount) public returns (bool) {\n//         return safeTokenTransfer(tokenAddress, recipient, amount);\n//     }\n    \n//     function test_calculateExitFee(uint256 spentInAmount) public view returns (uint256 feeAmount, uint256 remainingAmount) {\n//         return calculateExitFee(spentInAmount);\n//     }\n    \n//     function test_isThresholdReached() public view returns (bool) {\n//         return isThresholdReached();\n//     }\n    \n//     function test_isValidActivePosition(PositionTypes.Position memory position) public pure returns (bool) {\n//         return isValidActivePosition(position);\n//     }\n\n//     // Add more test functions for other internal functions as needed\n// } "
    },
    "contracts/StreamTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IStreamTypes {\n    enum Status {\n        Waiting,\n        Bootstrapping, \n        Active,\n        Ended,\n        Finalized,\n        Cancelled\n    }\n\n    enum Substatus {\n        None,\n        Streamed,\n        Refunded\n    }\n\n    struct StatusInfo {\n        Status mainStatus;\n        mapping(Status => Substatus) subStatus;\n    }\n\n    struct StreamTimes {\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n    }\n\n    struct StreamMetadata {\n        string name;\n    }\n\n    struct StreamState {\n        uint256 outRemaining;\n        uint256 distIndex;\n        uint256 spentIn;\n        uint256 shares;\n        uint256 currentStreamedPrice;\n        uint256 threshold;\n        uint256 inSupply;\n        uint256 outSupply;\n        uint256 lastUpdated;\n    }\n\n    struct StreamTokens {\n        address inSupplyToken;\n        address outSupplyToken;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}