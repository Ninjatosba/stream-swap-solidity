{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts/finance/VestingWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (finance/VestingWallet.sol)\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/utils/SafeERC20.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @title VestingWallet\n * @dev This contract handles the vesting of Eth and ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract VestingWallet is Context {\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n    address private immutable _beneficiary;\n    uint64 private immutable _start;\n    uint64 private immutable _duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(address beneficiaryAddress, uint64 startTimestamp, uint64 durationSeconds) payable {\n        require(beneficiaryAddress != address(0), \"VestingWallet: beneficiary is zero address\");\n        _beneficiary = beneficiaryAddress;\n        _start = startTimestamp;\n        _duration = durationSeconds;\n    }\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable virtual {}\n\n    /**\n     * @dev Getter for the beneficiary address.\n     */\n    function beneficiary() public view virtual returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Getter for the start timestamp.\n     */\n    function start() public view virtual returns (uint256) {\n        return _start;\n    }\n\n    /**\n     * @dev Getter for the vesting duration.\n     */\n    function duration() public view virtual returns (uint256) {\n        return _duration;\n    }\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view virtual returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view virtual returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /**\n     * @dev Getter for the amount of releasable eth.\n     */\n    function releasable() public view virtual returns (uint256) {\n        return vestedAmount(uint64(block.timestamp)) - released();\n    }\n\n    /**\n     * @dev Getter for the amount of releasable `token` tokens. `token` should be the address of an\n     * IERC20 contract.\n     */\n    function releasable(address token) public view virtual returns (uint256) {\n        return vestedAmount(token, uint64(block.timestamp)) - released(token);\n    }\n\n    /**\n     * @dev Release the native token (ether) that have already vested.\n     *\n     * Emits a {EtherReleased} event.\n     */\n    function release() public virtual {\n        uint256 amount = releasable();\n        _released += amount;\n        emit EtherReleased(amount);\n        Address.sendValue(payable(beneficiary()), amount);\n    }\n\n    /**\n     * @dev Release the tokens that have already vested.\n     *\n     * Emits a {ERC20Released} event.\n     */\n    function release(address token) public virtual {\n        uint256 amount = releasable(token);\n        _erc20Released[token] += amount;\n        emit ERC20Released(token, amount);\n        SafeERC20.safeTransfer(IERC20(token), beneficiary(), amount);\n    }\n\n    /**\n     * @dev Calculates the amount of ether that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(address(this).balance + released(), timestamp);\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(IERC20(token).balanceOf(address(this)) + released(token), timestamp);\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp) internal view virtual returns (uint256) {\n        if (timestamp < start()) {\n            return 0;\n        } else if (timestamp > start() + duration()) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start())) / duration();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    },
    "src/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title IPermit2\n * @notice Minimal interface for Uniswap Permit2 used by Stream contract\n * @dev We only include the single-permit allowance flow (PermitSingle) and basic transferFrom\n *      as those are sufficient for subscribeWithPermit. Additional Permit2 functions can be\n *      added later if the protocol needs them.\n */\ninterface IPermit2 {\n    /// @notice Data for a single token allowance\n    struct PermitDetails {\n        address token;       // ERC20 token address\n        uint160 amount;      // allowance amount\n        uint48 expiration;   // timestamp at which allowance expires\n        uint48 nonce;        // unique nonce to prevent replay\n    }\n\n    /// @notice Full permit message for a single token allowance\n    struct PermitSingle {\n        PermitDetails details; // allowance details\n        address spender;       // address being approved to spend the tokens\n        uint256 sigDeadline;   // deadline for the signature (timestamp)\n    }\n\n    /**\n     * @notice Approve token allowance via EIP-712 signature\n     * @param owner The owner of the tokens and signer of the permit\n     * @param permitSingle Full permit data\n     * @param signature Signature over the permit data\n     */\n    function permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature) external;\n\n    /**\n     * @notice Transfer tokens using an existing Permit2 allowance\n     * @param from Token owner\n     * @param to Recipient\n     * @param amount Amount to transfer (uint160 per Permit2 spec)\n     * @param token ERC20 token address\n     */\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n} "
    },
    "src/interfaces/IPoolRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { StreamTypes } from \"../types/StreamTypes.sol\";\nimport { PoolWrapperTypes } from \"../types/PoolWrapperTypes.sol\";\nimport { PoolRouterTypes } from \"../types/PoolRouterTypes.sol\";\n\ninterface IPoolRouter {\n    // Admin\n    function setWrapper(StreamTypes.DexType dex, uint256 key, address wrapper) external;\n    function getWrapper(StreamTypes.DexType dex, uint256 key) external view returns (address);\n\n    // Factory-time validation\n    function validatePoolParams(StreamTypes.PoolInfo calldata info) external view;\n\n    // Stream-time execution\n    function createPool(PoolRouterTypes.CreatePoolRequest calldata req)\n        external\n        returns (PoolWrapperTypes.CreatedPoolInfo memory);\n}\n\n\n"
    },
    "src/interfaces/IPositionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { PositionTypes } from \"../types/PositionTypes.sol\";\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\ninterface IPositionStorage {\n    function getPosition(address _owner) external view returns (PositionTypes.Position memory);\n\n    function createPosition(address owner, uint256 inBalance, uint256 shares, Decimal memory index) external;\n\n    function updatePosition(address owner, PositionTypes.Position memory position) external;\n\n    function setExitDate(address owner, uint256 exitDate) external;\n}\n"
    },
    "src/interfaces/IStream.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { StreamTypes } from \"../types/StreamTypes.sol\";\nimport { PositionTypes } from \"../types/PositionTypes.sol\";\nimport { IStreamEvents } from \"./IStreamEvents.sol\";\nimport { IStreamErrors } from \"./IStreamErrors.sol\";\nimport { IPermit2 } from \"./IPermit2.sol\";\n\ninterface IStream is IStreamEvents, IStreamErrors {\n    function initialize(\n        StreamTypes.CreateStreamMessage memory createStreamMessage,\n        address positionStorageAddress\n    ) external;\n\n    function withdraw(uint256 cap) external;\n\n    function subscribe(uint256 amountIn) external;\n\n    function subscribeWithNativeToken(uint256 amountIn) external payable;\n\n    function subscribeWithPermit(\n        uint256 amountIn,\n        address owner,\n        IPermit2.PermitSingle calldata permitSingle,\n        bytes calldata signature\n    ) external;\n\n    function exitStream() external;\n\n    function finalizeStream() external;\n\n    function syncStreamExternal() external;\n\n    function syncPositionExternal(address user) external;\n\n    function cancelStream() external;\n\n    function cancelWithAdmin() external;\n\n    // View functions\n    function getStreamStatus() external view returns (StreamTypes.Status);\n\n    function getStreamState() external view returns (StreamTypes.StreamState memory);\n\n    function getStreamMetadata() external view returns (StreamTypes.StreamMetadata memory);\n\n    function getPostStreamActions() external view returns (StreamTypes.PostStreamActions memory);\n\n    function getPosition(address user) external view returns (PositionTypes.Position memory);\n\n    // State variables getters (since they're public)\n    function creator() external view returns (address);\n\n    function positionStorageAddress() external view returns (address);\n\n    function streamFactoryAddress() external view returns (address);\n\n    function updateStreamMetadata(string memory metadataIpfsHash) external;\n}\n"
    },
    "src/interfaces/IStreamErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IStreamErrors {\n    // Stream errors\n    error InsufficientTokenPayment(uint256 requiredTokenAmount, uint256 tokenBalance);\n    error InvalidOutSupplyToken();\n    error InvalidInSupplyToken();\n    error PaymentFailed();\n    error OperationNotAllowed();\n    error Unauthorized();\n    error InvalidWithdrawAmount();\n    error WithdrawAmountExceedsBalance(uint256 cap);\n    error InsufficientOutAmount();\n    error InvalidPosition(address user, uint256 shares, uint256 exitDate, string reason);\n    error InvalidExitCondition();\n    error InvalidVestingDuration();\n    error InvalidVestingCliffDuration();\n    error InvalidPoolOutSupplyAmount();\n    error InvalidPoolType();\n    error InvalidAmount();\n    error StreamFactoryAddressAlreadySet();\n    error InvalidStreamFactoryAddress();\n    error InvalidPositionStorageAddress();\n    error InvalidImplementationAddress();\n    error InvalidInputToken();\n    error SameInputAndOutputToken();\n    error InvalidDexType();\n}\n"
    },
    "src/interfaces/IStreamEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IStreamEvents {\n    event StreamStateUpdated(\n        address indexed streamAddress,\n        uint256 lastUpdated,\n        uint256 distIndex,\n        uint256 outRemaining,\n        uint256 inSupply,\n        uint256 spentIn,\n        uint256 currentStreamedPrice\n    );\n\n    event Subscribed(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 positionInBalance,\n        uint256 positionShares,\n        uint256 positionLastUpdateTime,\n        uint256 positionSpentIn,\n        uint256 positionPurchased,\n        uint256 positionIndex,\n        uint256 streamInSupply,\n        uint256 streamShares\n    );\n\n    event StreamSynced(\n        address indexed streamAddress,\n        uint256 lastUpdated,\n        uint8 newStatus,\n        uint256 distIndex,\n        uint256 outRemaining,\n        uint256 inSupply,\n        uint256 spentIn,\n        uint256 currentStreamedPrice\n    );\n\n    event PositionSynced(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 positionInBalance,\n        uint256 positionShares,\n        uint256 positionLastUpdateTime,\n        uint256 positionSpentIn,\n        uint256 positionPurchased,\n        uint256 positionIndex\n    );\n\n    event Withdrawn(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 positionInBalance,\n        uint256 positionShares,\n        uint256 positionLastUpdateTime,\n        uint256 positionSpentIn,\n        uint256 positionPurchased,\n        uint256 positionIndex,\n        uint256 streamInSupply,\n        uint256 streamShares\n    );\n\n    event ExitRefunded(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 inBalance,\n        uint256 spentIn,\n        uint256 exitTimestamp\n    );\n    event ExitStreamed(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 purchased,\n        uint256 spentIn,\n        uint256 index,\n        uint256 inBalance,\n        uint256 exitTimestamp\n    );\n\n    event FinalizedStreamed(\n        address indexed streamAddress,\n        address indexed creator,\n        uint256 creatorRevenue,\n        uint256 exitFeeAmount,\n        uint256 refundedOutAmount\n    );\n\n    event FinalizedRefunded(address indexed streamAddress, address indexed creator, uint256 refundedOutAmount);\n\n    event StreamCancelled(address indexed streamAddress, address creator, uint256 outSupply, uint8 status);\n\n    event StreamMetadataUpdated(address indexed streamAddress, string metadataIpfsHash);\n\n    event CreatorVestingCreated(address indexed creator, address vestingAddress, uint256 vestingDuration, address token, uint256 amount);\n\n    event BeneficiaryVestingCreated(address indexed beneficiary, address vestingAddress, uint64 vestingDuration, address token, uint256 amount);\n\n    event PoolCreated(\n        address indexed streamAddress,\n        address indexed poolAddress,\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 refundedAmount0,\n        uint256 refundedAmount1,\n        address indexed creator\n    );\n}\n"
    },
    "src/interfaces/IStreamFactoryErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n// StreamFactory errors\ninterface IStreamFactoryErrors {\n    // StreamFactory errors\n    error InvalidBootstrappingStartTime();\n    error InvalidStreamStartTime();\n    error InvalidStreamEndTime();\n    error StreamDurationTooShort();\n    error BootstrappingDurationTooShort();\n    error WaitingDurationTooShort();\n    error ContractFrozen();\n    error InvalidExitFeeRatio();\n    error ZeroOutSupplyNotAllowed();\n    error StreamInputTokenNotAccepted();\n    error InvalidBootstrappingTime();\n    error StreamStartMustBeAfterBootstrapping();\n    error StreamEndMustBeAfterStart();\n    error InvalidToSVersion();\n    error TokenTransferFailed();\n    error StreamAddressPredictionFailed();\n    error InvalidFeeCollector();\n    error InvalidProtocolAdmin();\n    error NotAdmin();\n    error PoolRouterNotSet();\n    error InvalidImplementationAddress();\n    error ImplementationNotSet(uint8 kind);\n    error InvalidStreamCreationFeeToken();\n    error AlreadyInitialized();\n    error InvalidAcceptedInSupplyTokens();\n    error InvalidStreamImplementationAddress();\n    error InvalidOutSupplyToken();\n    error InvalidCreator();\n    error InvalidVestingDuration();\n    error SameInputAndOutputToken();\n    error InvalidTokenName();\n    error InvalidTokenSymbol();\n    error InvalidTokenDecimals();\n    error InvalidTokenSupply();\n    error InvalidTokenTotalSupply();\n    error InvalidDexType();\n}\n"
    },
    "src/interfaces/IStreamFactoryEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IStreamFactoryEvents {\n    event StreamCreated(\n        address indexed streamFactoryAddress,\n        address streamOutToken,\n        address streamInToken,\n        address streamAddress,\n        address creator,\n        address positionStorageAddress,\n        uint256 streamOutAmount,\n        uint256 poolOutSupplyAmount,\n        string dexType,\n        bool isCreatorVestingEnabled,\n        bool isBeneficiaryVestingEnabled,\n        uint64 creatorVestingDuration,\n        uint64 beneficiaryVestingDuration,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 threshold,\n        string metadataIpfsHash,\n        string tosVersion,\n        uint16 streamId\n    );\n\n    event TokenCreated(address indexed token, string name, string symbol, uint8 decimals, uint256 totalSupply);\n\n    event FactoryInitialized(\n        address indexed factory,\n        address basicImplementationAddress,\n        address postActionsImplementationAddress,\n        address poolRouterAddress,\n        address feeCollector,\n        address protocolAdmin,\n        address streamCreationFeeToken,\n        address[] acceptedInSupplyTokens,\n        uint256 streamCreationFee,\n        uint256 exitFeeRatio,\n        uint256 minWaitingDuration,\n        uint256 minBootstrappingDuration,\n        uint256 minStreamDuration,\n        string tosVersion,\n        address vestingAddress\n    );\n\n    event FeeCollectorUpdated(address indexed factory, address oldFeeCollector, address newFeeCollector);\n\n    event ProtocolAdminUpdated(address indexed factory, address oldProtocolAdmin, address newProtocolAdmin);\n\n    event StreamFeeParametersUpdated(\n        address indexed factory,\n        uint256 oldFee,\n        uint256 newFee,\n        address oldFeeToken,\n        address newFeeToken\n    );\n\n    event TimingParametersUpdated(\n        address indexed factory,\n        uint256 oldMinWaitingDuration,\n        uint256 newMinWaitingDuration,\n        uint256 oldMinBootstrappingDuration,\n        uint256 newMinBootstrappingDuration,\n        uint256 oldMinStreamDuration,\n        uint256 newMinStreamDuration\n    );\n\n    event ImplementationParametersUpdated(\n        address indexed factory,\n        address oldBasic,\n        address newBasic,\n        address oldPostActions,\n        address newPostActions\n    );\n\n    event PoolRouterUpdated(\n        address indexed factory,\n        address oldPoolRouter,\n        address newPoolRouter\n    );\n\n    event ExitFeeRatioUpdated(address indexed factory, uint256 oldRatio, uint256 newRatio);\n\n    event TosVersionUpdated(address indexed factory, string oldVersion, string newVersion);\n\n    event FrozenStateUpdated(address indexed factory, bool frozen);\n\n    event AcceptedTokensUpdated(address indexed factory, address[] tokensAdded, address[] tokensRemoved);\n\n    event VestingContractDeployed(address indexed factoryAddress, address vestingContract);\n}\n"
    },
    "src/interfaces/IStreamFactoryParams.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { StreamFactoryTypes } from \"../types/StreamFactoryTypes.sol\";\n\n/**\n * @title IStreamFactoryParams\n * @notice Minimal interface to read factory params without importing a concrete factory\n */\ninterface IStreamFactoryParams {\n    function getParams() external view returns (StreamFactoryTypes.Params memory);\n}\n\n\n"
    },
    "src/interfaces/ITokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { StreamTypes } from \"../types/StreamTypes.sol\";\n\ninterface ITokenFactory {\n    function createToken(\n        StreamTypes.TokenCreationInfo calldata tokenInfo,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external returns (address tokenAddress);\n}\n\n\n"
    },
    "src/interfaces/IVestingFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title IVestingFactory\n * @dev Interface for the VestingFactory contract that creates OpenZeppelin VestingWallet instances\n */\ninterface IVestingFactory {\n    /**\n     * @dev Creates a VestingWallet and transfers tokens to it in one transaction\n     * @param beneficiary address of the beneficiary\n     * @param startTime the time (as Unix time) at which point vesting begins\n     * @param duration duration in seconds of the period in which the tokens will vest\n     * @param token the token to transfer to the vesting wallet (zero address for native token)\n     * @param amount the amount of tokens to transfer\n     * @return vestingWallet the address of the created VestingWallet\n     * @notice When token is address(0), native tokens are sent via msg.value. For ERC20 tokens, \n     *         the caller must approve this contract first.\n     */\n    function createVestingWalletWithTokens(\n        address beneficiary,\n        uint64 startTime,\n        uint64 duration,\n        address token,\n        uint256 amount\n    ) external payable returns (address vestingWallet);\n\n    /**\n     * @dev Event emitted when a new VestingWallet is created\n     */\n    event VestingWalletCreated(\n        address indexed beneficiary,\n        address indexed vestingWallet,\n        uint64 startTime,\n        uint64 duration,\n        address token,\n        uint256 amount\n    );\n}\n"
    },
    "src/lib/math/DecimalMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title DecimalMath\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Library for high-precision decimal arithmetic operations\n * @dev Provides decimal arithmetic with 6 decimal places precision (1e6):\n *      - Supports basic arithmetic operations (add, sub, mul, div)\n *      - Includes comparison operations (gt, lt)\n *      - Provides conversion between decimals and integers\n *      - Used throughout the protocol for precise calculations\n */\n\n/**\n * @title Decimal type and math operations\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\n\nstruct Decimal {\n    uint256 value; // Value scaled by DECIMAL_PRECISION\n}\n\n/**\n * @title DecimalMath\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\nlibrary DecimalMath {\n    // We'll use 6 decimal places for precision\n    uint256 public constant DECIMAL_PRECISION = 1e6;\n\n    // Convert a regular number to a Decimal\n    function fromNumber(uint256 value) internal pure returns (Decimal memory) {\n        return Decimal({ value: value * DECIMAL_PRECISION });\n    }\n\n    // Convert a Decimal to a regular number while keeping the remainder\n    function toNumber(Decimal memory d) internal pure returns (uint256, Decimal memory) {\n        return (d.value / DECIMAL_PRECISION, Decimal({ value: d.value % DECIMAL_PRECISION }));\n    }\n\n    // Floor division for Decimal\n    function floor(Decimal memory d) internal pure returns (uint256) {\n        return d.value / DECIMAL_PRECISION;\n    }\n\n    // Ceiling division for Decimal\n    function ceil(Decimal memory d) internal pure returns (uint256) {\n        return (d.value + DECIMAL_PRECISION - 1) / DECIMAL_PRECISION;\n    }\n\n    // Multiply two Decimals\n    function mul(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: (a.value * b.value) / DECIMAL_PRECISION });\n    }\n\n    // Multiply Decimal by a scalar\n    function mulScalar(Decimal memory a, uint256 scalar) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value * scalar });\n    }\n\n    // Divide two Decimals\n    function div(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: (a.value * DECIMAL_PRECISION) / b.value });\n    }\n\n    // Divide Decimal by a scalar\n    function divScalar(Decimal memory a, uint256 scalar) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value / scalar });\n    }\n\n    // Add two Decimals\n    function add(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value + b.value });\n    }\n\n    // Subtract two Decimals\n    function sub(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value - b.value });\n    }\n\n    // From ratio to Decimal\n    function fromRatio(uint256 num, uint256 denom) internal pure returns (Decimal memory) {\n        return Decimal({ value: (num * DECIMAL_PRECISION) / denom });\n    }\n\n    // > operator for Decimals\n    function gt(Decimal memory a, Decimal memory b) internal pure returns (bool) {\n        return a.value > b.value;\n    }\n\n    // < operator for Decimals\n    function lt(Decimal memory a, Decimal memory b) internal pure returns (bool) {\n        return a.value < b.value;\n    }\n}\n"
    },
    "src/lib/math/StreamMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title StreamMathLib\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Core mathematical engine powering StreamSwap's time-based distribution algorithm\n * @dev This library implements the mathematical model that enables StreamSwap's unique\n *      continuous token distribution mechanism. Unlike traditional AMMs or auction models,\n *      StreamSwap calculates distributions based on time progression and participation timing.\n *      \n *      Key Algorithms:\n *      - Time Differential Calculation: Determines distribution progress based on elapsed time\n *      - Share-based Distribution: Calculates proportional token allocation per participant\n *      - Dynamic Price Discovery: Computes real-time pricing based on participation\n *      - Position Synchronization: Updates user positions with accrued distributions\n *      - Exit Fee Computation: Applies configurable fees on successful stream exits\n *      \n *      Mathematical Precision:\n *      - Uses DecimalMath library for 6-decimal precision (1e6)\n *      - Handles edge cases like zero participation and boundary conditions\n *      - Prevents overflow/underflow through careful calculation ordering\n *      - Maintains accuracy across different time scales and token amounts\n */\n\nimport { StreamTypes } from \"../../types/StreamTypes.sol\";\nimport { DecimalMath, Decimal } from \"./DecimalMath.sol\";\nimport { PositionTypes } from \"../../types/PositionTypes.sol\";\nlibrary StreamMathLib {\n    /**\n     * @dev Calculates the time difference ratio between current time and last updated time\n     * @param currentTimestamp Current timestamp\n     * @param streamStartTime Timestamp when the stream starts\n     * @param streamEndTime Timestamp when the stream ends\n     * @param lastUpdated Timestamp when the stream was last updated\n     * @return The ratio of time elapsed since last update compared to total remaining time (scaled by 1e18)\n     */\n    function calculateDiff(\n        uint256 currentTimestamp,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 lastUpdated\n    ) internal pure returns (Decimal memory) {\n        // If the stream is not started yet or already ended, return 0\n        if (currentTimestamp < streamStartTime || lastUpdated >= streamEndTime) {\n            return DecimalMath.fromNumber(0);\n        }\n\n        // If lastUpdated is before start time, set it to start time\n        uint256 effectiveLastUpdated = lastUpdated;\n        if (effectiveLastUpdated < streamStartTime) {\n            effectiveLastUpdated = streamStartTime;\n        }\n\n        // If current time is past end time, use end time instead\n        uint256 effectiveNow = currentTimestamp;\n        if (effectiveNow > streamEndTime) {\n            effectiveNow = streamEndTime;\n        }\n\n        uint256 numerator = effectiveNow - effectiveLastUpdated;\n        uint256 denominator = streamEndTime - effectiveLastUpdated;\n\n        if (denominator == 0 || numerator == 0) {\n            return DecimalMath.fromNumber(0);\n        }\n        // Return ratio of time elapsed since last update compared to total remaining time\n        return DecimalMath.fromRatio(numerator, denominator);\n    }\n\n    /**\n     * @dev Calculates the stream status based on the current state and timestamp\n     * @param currentStatus Current status of the stream\n     * @param currentTime Current timestamp to check against\n     * @param bootstrappingStartTime Timestamp when bootstrapping phase starts\n     * @param streamStartTime Timestamp when active streaming starts\n     * @param streamEndTime Timestamp when streaming ends\n     * @return IStreamTypes.Status The calculated stream status\n     */\n    function calculateStreamStatus(\n        StreamTypes.Status currentStatus,\n        uint256 currentTime,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime\n    ) internal pure returns (StreamTypes.Status) {\n        // Don't update if stream is in a final state\n        if (\n            currentStatus == StreamTypes.Status.Cancelled ||\n            currentStatus == StreamTypes.Status.FinalizedRefunded ||\n            currentStatus == StreamTypes.Status.FinalizedStreamed\n        ) {\n            return currentStatus;\n        }\n\n        // Update status based on current timestamp\n        if (currentTime < bootstrappingStartTime) {\n            return StreamTypes.Status.Waiting;\n        } else if (currentTime >= bootstrappingStartTime && currentTime < streamStartTime) {\n            return StreamTypes.Status.Bootstrapping;\n        } else if (currentTime >= streamStartTime && currentTime < streamEndTime) {\n            return StreamTypes.Status.Active;\n        } else if (currentTime >= streamEndTime) {\n            return StreamTypes.Status.Ended;\n        }\n\n        // This should never be reached, but return current status as fallback\n        return currentStatus;\n    }\n\n    /**\n     * @dev Calculates updated stream state based on time difference\n     * @param state Current stream state\n     * @param diff Time difference in seconds\n     * @return Updated stream state\n     */\n    function calculateUpdatedState(\n        StreamTypes.StreamState memory state,\n        Decimal memory diff\n    ) internal pure returns (StreamTypes.StreamState memory) {\n        // Create a copy of the state to avoid modifying the input\n        StreamTypes.StreamState memory newState = state;\n\n        if (newState.shares > 0 && diff.value > 0) {\n            // Calculate new distribution balance and spent in amount\n            Decimal memory newDecimalDistributionBalance = DecimalMath.mul(\n                DecimalMath.fromNumber(newState.outRemaining),\n                diff\n            );\n            uint256 newDistributionBalance = DecimalMath.floor(newDecimalDistributionBalance);\n\n            Decimal memory newDecimalSpentIn = DecimalMath.mul(DecimalMath.fromNumber(newState.inSupply), diff);\n            uint256 spentIn = DecimalMath.floor(newDecimalSpentIn);\n\n            // Update state variables\n            newState.spentIn += spentIn;\n            newState.inSupply -= spentIn;\n\n            if (newDistributionBalance > 0) {\n                newState.outRemaining -= newDistributionBalance;\n                // Increment distribution index\n                Decimal memory distIndexIncrementAmount = DecimalMath.fromRatio(\n                    newDistributionBalance,\n                    newState.shares\n                );\n                newState.distIndex = DecimalMath.add(newState.distIndex, distIndexIncrementAmount);\n                // Update current streamed price\n                newState.currentStreamedPrice = DecimalMath.fromRatio(spentIn, newDistributionBalance);\n            }\n        }\n        return newState;\n    }\n\n    function computeSharesAmount(\n        uint256 amountIn,\n        bool roundUp,\n        uint256 inSupply,\n        uint256 totalShares\n    ) internal pure returns (uint256) {\n        if (totalShares == 0 || amountIn == 0) {\n            return amountIn;\n        }\n\n        uint256 totalSharesIn = totalShares * amountIn;\n\n        if (roundUp) {\n            return (totalSharesIn + inSupply - 1) / inSupply;\n        } else {\n            return totalSharesIn / inSupply;\n        }\n    }\n\n    /**\n     * @dev Calculates the exit fee amount based on the spent in amount\n     * @param spentInAmount Amount of tokens spent in the stream\n     * @return exitFeeAmount The calculated fee amount\n     * @return remainingAmount The remaining amount after fee deduction\n     */\n    function calculateExitFee(\n        uint256 spentInAmount,\n        Decimal memory exitFeeRatio\n    ) internal pure returns (uint256 exitFeeAmount, uint256 remainingAmount) {\n        Decimal memory decimalSpentIn = DecimalMath.fromNumber(spentInAmount);\n\n        // Calculate exit fee amount using DecimalMath\n        Decimal memory decimalExitFeeAmount = DecimalMath.mul(decimalSpentIn, exitFeeRatio);\n        exitFeeAmount = DecimalMath.floor(decimalExitFeeAmount);\n        remainingAmount = spentInAmount - exitFeeAmount;\n\n        return (exitFeeAmount, remainingAmount);\n    }\n\n    function syncPosition(\n        PositionTypes.Position memory position,\n        Decimal memory distIndex,\n        uint256 totalShares,\n        uint256 inSupply,\n        uint256 nowTime\n    ) internal pure returns (PositionTypes.Position memory) {\n        // Calculate index difference for distributions since last update\n        Decimal memory indexDiff = DecimalMath.sub(distIndex, position.index);\n        uint256 spent = 0;\n        uint256 purchased = 0;\n\n        // Only process if there are shares in the stream\n        if (position.shares > 0) {\n            // Calculate purchased amount based on position shares and index difference\n            Decimal memory positionSharesDecimal = DecimalMath.fromNumber(position.shares);\n            Decimal memory purchasedDecimal = DecimalMath.add(\n                DecimalMath.mul(positionSharesDecimal, indexDiff),\n                position.pendingReward\n            );\n            (purchased, purchasedDecimal) = DecimalMath.toNumber(purchasedDecimal);\n            position.purchased += purchased;\n            position.pendingReward = purchasedDecimal;\n\n            // Calculate remaining balance based on current shares ratio\n            uint256 inRemaining = (inSupply * position.shares) / totalShares;\n            // Calculate spent amount\n            spent = position.inBalance - inRemaining;\n            position.spentIn += spent;\n            position.inBalance = inRemaining;\n        }\n\n        // Update position tracking\n        position.index = distIndex;\n        position.lastUpdateTime = nowTime;\n\n        return position;\n    }\n}\n"
    },
    "src/lib/PoolOps.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IPoolRouter } from \"../interfaces/IPoolRouter.sol\";\nimport { PoolRouterTypes } from \"../types/PoolRouterTypes.sol\";\nimport { PoolWrapperTypes } from \"../types/PoolWrapperTypes.sol\";\nimport { StreamTypes } from \"../types/StreamTypes.sol\";\n\nlibrary PoolOps {\n    function sortTokensWithAmounts(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB\n    ) internal pure returns (address token0, address token1, uint256 amount0, uint256 amount1) {\n        if (tokenA < tokenB) {\n            return (tokenA, tokenB, amountA, amountB);\n        }\n        return (tokenB, tokenA, amountB, amountA);\n    }\n\n    function createPoolViaRouter(\n        address router,\n        address token0,\n        uint256 amount0Desired,\n        address token1,\n        uint256 amount1Desired,\n        StreamTypes.DexType dexType,\n        bytes memory extra,\n        address creator\n    ) internal returns (PoolWrapperTypes.CreatedPoolInfo memory) {\n        IPoolRouter poolRouter = IPoolRouter(router);\n        PoolRouterTypes.CreatePoolRequest memory req = PoolRouterTypes.CreatePoolRequest({\n            tokenA: token0,\n            tokenB: token1,\n            amountADesired: amount0Desired,\n            amountBDesired: amount1Desired,\n            dexType: dexType,\n            extra: extra,\n            creator: creator\n        });\n        return poolRouter.createPool(req);\n    }\n\n    function mapRefundsToInOut(\n        PoolWrapperTypes.CreatedPoolInfo memory createdPoolInfo,\n        address inToken,\n        address outToken\n    ) internal pure returns (uint256 refundedOut, uint256 refundedIn) {\n        uint256 refunded0 = createdPoolInfo.refundedAmount0;\n        uint256 refunded1 = createdPoolInfo.refundedAmount1;\n\n        refundedOut = createdPoolInfo.token0 == outToken ? refunded0 : refunded1;\n        refundedIn = createdPoolInfo.token0 == inToken ? refunded0 : refunded1;\n    }\n}\n\n\n"
    },
    "src/lib/TransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title TransferLib\n * @author Adnan Deniz\n * @notice Unified handling of ERC20 and native transfers.\n * @dev Supports both fresh ETH via msg.value and already-held ETH in contract.\n */\nlibrary TransferLib {\n    using SafeERC20 for IERC20;\n\n    /// @notice Native token address (zero address)\n    address public constant NATIVE_TOKEN = address(0);\n\n    /**\n     * @dev Transfer funds from `from` to `to`. Works with native token and ERC20.\n     * @param token Token address (zero address for native token)\n     * @param from Address providing funds (msg.sender or this for native, any for ERC20)\n     * @param to Address receiving funds\n     * @param amount Amount to transfer\n     */\n    function transferFunds(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) return;\n\n        if (token == NATIVE_TOKEN) {\n            if (from == msg.sender) {\n                // Pulling fresh ETH\n                if (msg.value != amount) revert IncorrectNativeAmount(amount, msg.value);\n                if (to == address(this)) return; // staying in contract\n                (bool ok, ) = payable(to).call{ value: amount }(\"\");\n                if (!ok) revert NativeTokenTransferFailed();\n            } else if (from == address(this)) {\n                // Sending ETH already held by contract\n                (bool ok, ) = payable(to).call{ value: amount }(\"\");\n                if (!ok) revert NativeTokenTransferFailed();\n            } else {\n                revert InvalidNativePayer(from);\n            }\n            return;\n        }\n\n        // ERC20 path\n        if (from == address(this)) {\n            IERC20(token).safeTransfer(to, amount);\n        } else {\n            IERC20(token).safeTransferFrom(from, to, amount);\n        }\n    }\n\n    // ============ Errors ============\n    error NativeTokenTransferFailed();\n    error IncorrectNativeAmount(uint256 expected, uint256 actual);\n    error InvalidNativePayer(address from);\n}\n"
    },
    "src/storage/PositionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title PositionStorage\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Secure, isolated storage for user participation data in StreamSwap streams\n * @dev PositionStorage implements a separation-of-concerns architecture where user data\n *      is isolated from stream logic for enhanced security and modularity. Each stream\n *      deploys its own PositionStorage instance, ensuring data isolation and preventing\n *      cross-stream interference.\n *      \n *      Security Features:\n *      - Single-stream access control: Only the deploying stream can modify data\n *      - Immutable stream address: Cannot be changed after deployment\n *      - Isolated storage: Each stream has its own position data\n *      - Comprehensive position tracking: Balances, shares, distributions, exit status\n *   \n */\n\nimport { PositionTypes } from \"../types/PositionTypes.sol\";\nimport { Decimal, DecimalMath } from \"../lib/math/DecimalMath.sol\";\n\ncontract PositionStorage {\n    using PositionTypes for PositionTypes.Position;\n\n    error UnauthorizedAccess();\n    error InvalidStreamContractAddress();\n\n    mapping(address => PositionTypes.Position) private positions;\n    address public immutable STREAM_CONTRACT_ADDRESS;\n\n    constructor(address contractAddress) {\n        if (contractAddress == address(0)) revert InvalidStreamContractAddress();\n        STREAM_CONTRACT_ADDRESS = contractAddress;\n    }\n\n    function getPosition(address owner) external view returns (PositionTypes.Position memory) {\n        return positions[owner];\n    }\n\n    modifier onlyStreamContract() {\n        if (msg.sender != STREAM_CONTRACT_ADDRESS) revert UnauthorizedAccess();\n        _;\n    }\n\n    function createPosition(\n        address owner,\n        uint256 inBalance,\n        uint256 shares,\n        Decimal memory index\n    ) external onlyStreamContract {\n        positions[owner] = PositionTypes.Position(\n            inBalance,\n            shares,\n            index,\n            block.timestamp,\n            DecimalMath.fromNumber(0),\n            0,\n            0,\n            0\n        );\n    }\n\n    function updatePosition(address owner, PositionTypes.Position memory position) external onlyStreamContract {\n        positions[owner] = position;\n    }\n\n    function setExitDate(address owner, uint256 exitDate) external onlyStreamContract {\n        positions[owner].exitDate = exitDate;\n    }\n}\n"
    },
    "src/StreamBasic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title StreamBasic\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Basic implementation of StreamCore with minimal features\n * @dev This contract provides the simplest streaming functionality without\n *      vesting or pool creation features. All hooks use default implementations\n *      from StreamCore (direct transfers).\n */\n\nimport { StreamCore } from \"./StreamCore.sol\";\n\ncontract StreamBasic is StreamCore {\n    /**\n     * @notice Contract version for tracking upgrades\n     */\n    string public constant VERSION = \"1.0.0\";\n\n    /**\n     * @notice Contract variant identifier\n     */\n    string public constant VARIANT = \"Basic\";\n\n    // ============ Constructor ============\n    // No constructor needed - proxy pattern uses initialize\n\n    // ============ Override Functions ============\n    // StreamBasic uses all default hook implementations from StreamCore\n    // No overrides needed - direct transfers for all cases\n\n    /**\n     * @dev Returns the implementation name for identification\n     * @return Implementation name and version\n     */\n    function implementation() external pure returns (string memory) {\n        return string(abi.encodePacked(\"StreamBasic v\", VERSION));\n    }\n}\n"
    },
    "src/StreamCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title StreamCore\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Abstract base contract for streaming functionality with extension hooks\n * @dev This contract contains the core streaming logic with virtual hook functions\n *      that can be overridden by implementation contracts to add features like\n *      vesting, pool creation, etc. All storage is defined here to ensure\n *      consistent layout across implementations for upgradeability.\n */\n\nimport { PositionTypes } from \"./types/PositionTypes.sol\";\nimport { IPositionStorage } from \"./interfaces/IPositionStorage.sol\";\nimport { IStreamEvents } from \"./interfaces/IStreamEvents.sol\";\nimport { IStreamErrors } from \"./interfaces/IStreamErrors.sol\";\nimport { StreamTypes } from \"./types/StreamTypes.sol\";\nimport { StreamFactoryTypes } from \"./types/StreamFactoryTypes.sol\";\nimport { IStreamFactoryParams } from \"./interfaces/IStreamFactoryParams.sol\";\nimport { DecimalMath, Decimal } from \"./lib/math/DecimalMath.sol\";\nimport { StreamMathLib } from \"./lib/math/StreamMathLib.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { TransferLib } from \"./lib/TransferLib.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { IPermit2 } from \"./interfaces/IPermit2.sol\";\n\nimport \"hardhat/console.sol\";\n\nabstract contract StreamCore is IStreamErrors, IStreamEvents, UUPSUpgradeable {\n    // ============ State Variables ============\n    // All storage must be defined here for upgrade compatibility\n    \n    /// @notice Address of the stream creator\n    address public creator;\n\n    /// @notice Address of the stream factory that deployed this stream\n    /// @dev Changed from immutable to storage for proxy compatibility\n    address public STREAM_FACTORY_ADDRESS;\n\n    /// @notice Address of the position storage contract\n    address public positionStorageAddress;\n\n    /// @notice Flag to ensure initialization happens only once\n    bool private initialized;\n\n    /// @notice Current state of the stream (distribution index, remaining tokens, etc.)\n    StreamTypes.StreamState public streamState;\n\n    /// @notice Token addresses for input and output tokens\n    StreamTypes.StreamTokens public streamTokens;\n\n    /// @notice Metadata associated with the stream\n    StreamTypes.StreamMetadata public streamMetadata;\n\n    /// @notice Current status of the stream (Waiting, Bootstrapping, Active, etc.)\n    StreamTypes.Status public streamStatus;\n\n    /// @notice Timing information for the stream phases\n    StreamTypes.StreamTimes public streamTimes;\n    \n\n    /// @notice Address of the Permit2 contract\n    address public constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /// @notice Storage gap for future upgrades\n    uint256[40] private __gap;\n\n    // ============ Modifiers ============\n\n    /**\n     * @dev Ensures the function can only be called once during initialization\n     */\n    modifier onlyOnce() {\n        if (initialized) revert Unauthorized();\n        _;\n        initialized = true;\n    }\n\n    /**\n     * @dev Ensures only the stream factory can call the function\n     */\n    modifier onlyStreamFactory() {\n        if (msg.sender != STREAM_FACTORY_ADDRESS) revert Unauthorized();\n        _;\n    }\n\n    /**\n     * @dev Ensures only the stream creator can call the function\n     */\n    modifier onlyCreator() {\n        if (msg.sender != creator) revert Unauthorized();\n        _;\n    }\n\n    /**\n     * @dev Ensures only the protocol admin can call the function\n     */\n    modifier onlyProtocolAdmin() {\n        IStreamFactoryParams factoryContract = IStreamFactoryParams(STREAM_FACTORY_ADDRESS);\n        address protocolAdmin = factoryContract.getParams().protocolAdmin;\n        if (msg.sender != protocolAdmin) revert Unauthorized();\n        _;\n    }\n\n    // ============ Initialization ============\n\n    /**\n     * @dev Initializes the stream with the provided configuration\n     * @param createStreamMessage Stream creation parameters\n     * @param storageAddress Address of the position storage contract\n     * @notice This function can only be called once and must be invoked by the factory\n     */\n    function initialize(\n        StreamTypes.CreateStreamMessage memory createStreamMessage,\n        address storageAddress\n    ) external virtual onlyOnce {\n        if (storageAddress == address(0)) revert InvalidPositionStorageAddress();\n        \n        // Set factory address from caller\n        STREAM_FACTORY_ADDRESS = msg.sender;\n        \n        // Save position storage address\n        positionStorageAddress = storageAddress;\n        \n        // Set creator\n        creator = createStreamMessage.creator;\n        \n        // Initialize stream state\n        streamState = StreamTypes.StreamState({\n            distIndex: DecimalMath.fromNumber(0),\n            outRemaining: createStreamMessage.streamOutAmount,\n            inSupply: 0,\n            spentIn: 0,\n            shares: 0,\n            currentStreamedPrice: DecimalMath.fromNumber(0),\n            threshold: createStreamMessage.threshold,\n            outSupply: createStreamMessage.streamOutAmount,\n            lastUpdated: block.timestamp\n        });\n        \n        // Initialize stream tokens\n        streamTokens = StreamTypes.StreamTokens({\n            inSupplyToken: createStreamMessage.inSupplyToken,\n            outSupplyToken: createStreamMessage.outSupplyToken\n        });\n        \n        // Initialize stream metadata\n        streamMetadata = createStreamMessage.metadata;\n        \n        // Initialize stream status\n        streamStatus = StreamTypes.Status.Waiting;\n        \n        // Initialize stream times\n        streamTimes = StreamTypes.StreamTimes({\n            bootstrappingStartTime: createStreamMessage.bootstrappingStartTime,\n            streamStartTime: createStreamMessage.streamStartTime,\n            streamEndTime: createStreamMessage.streamEndTime\n        });\n        \n        // Call initialization hook for extensions\n        _onInitialize(createStreamMessage);\n    }\n\n    // ============ Extension Hooks (Virtual Functions) ============\n\n    /**\n     * @dev Hook called during initialization for extensions to set up their state\n     * @param createStreamMessage Stream creation parameters\n     */\n    function _onInitialize(StreamTypes.CreateStreamMessage memory createStreamMessage) internal virtual {}\n\n    /**\n     * @dev Hook called after a subscription\n     * @param user Address of the subscriber\n     * @param amountIn Amount subscribed\n     */\n    function _onSubscribe(address user, uint256 amountIn) internal virtual {}\n\n    /**\n     * @dev Hook called after a withdrawal\n     * @param user Address of the withdrawer\n     * @param amountOut Amount withdrawn\n     */\n    function _onWithdraw(address user, uint256 amountOut) internal virtual {}\n\n    /**\n     * @dev Hook called when a user exits successfully (threshold met)\n     * @param user Address of the exiting user\n     * @param purchased Amount of output tokens purchased\n     * @param inRefunded Amount of input tokens refunded\n     */\n    function _onExitSuccess(address user, uint256 purchased, uint256 inRefunded) internal virtual {\n        TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), user, purchased);\n        \n        if (inRefunded > 0) {\n            TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), user, inRefunded);\n        }\n    }\n\n    /**\n     * @dev Hook called when a user exits with refund (threshold not met or cancelled)\n     * @param user Address of the exiting user\n     * @param totalRefund Amount of input tokens to refund\n     */\n    function _onExitRefund(address user, uint256 totalRefund) internal virtual {\n        TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), user, totalRefund);\n    }\n\n    /**\n     * @dev Hook called after finalizing a successful stream\n     * @param creatorRevenue Amount of input tokens for creator\n     * @param outRemaining Remaining output tokens\n     */\n    function _afterFinalizeSuccess(uint256 creatorRevenue, uint256 outRemaining) internal virtual returns (uint256 adjustedCreatorRevenue) {\n        TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), creator, creatorRevenue);\n        \n        if (outRemaining > 0) {\n            TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), creator, outRemaining);\n        }\n        return creatorRevenue;\n    }\n\n    /**\n     * @dev Hook called after finalizing a refunded stream\n     * @param outSupply Amount of output tokens to return\n     */\n    function _afterFinalizeRefund(uint256 outSupply) internal virtual {\n        TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), creator, outSupply);\n    }\n\n    // ============ Core Stream Functions ============\n\n    /**\n     * @dev Internal function containing the core subscription logic\n     * @param amountIn Amount of input tokens to subscribe with\n     */\n    function _subscribeCore(uint256 amountIn) internal {\n        if (amountIn == 0) revert InvalidAmount();\n\n        // Load and validate stream state\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Validate operation is allowed\n        if (status != StreamTypes.Status.Bootstrapping && status != StreamTypes.Status.Active) {\n            revert OperationNotAllowed();\n        }\n\n        // Load and sync stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        // Load and sync position\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // Calculate shares before any state changes\n        uint256 newShares = StreamMathLib.computeSharesAmount(amountIn, false, state.inSupply, state.shares);\n\n        // Update position\n        position.inBalance += amountIn;\n        position.shares += newShares;\n\n        // Update stream state\n        state.inSupply += amountIn;\n        state.shares += newShares;\n\n        // Save all states\n        saveStreamStatus(status);\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        emit Subscribed(\n            address(this),\n            msg.sender,\n            position.inBalance,\n            newShares,\n            position.lastUpdateTime,\n            position.spentIn,\n            position.purchased,\n            position.index.value,\n            state.inSupply,\n            state.shares\n        );\n\n        // Call subscription hook\n        _onSubscribe(msg.sender, amountIn);\n    }\n\n    /**\n     * @dev Allows users to subscribe to the stream by providing input tokens\n     * @param amountIn Amount of input tokens to subscribe with\n     */\n    function subscribe(uint256 amountIn) external {\n        if (streamTokens.inSupplyToken == address(0)) revert InvalidInputToken();\n        // Pull funds (ERC20)\n        TransferLib.transferFunds(streamTokens.inSupplyToken, msg.sender, address(this), amountIn);\n        _subscribeCore(amountIn);\n    }\n\n    /**\n     * @dev Allows users to subscribe with native tokens\n     * @param amountIn Amount of native tokens to subscribe with\n     */\n    function subscribeWithNativeToken(uint256 amountIn) external payable {\n        if (streamTokens.inSupplyToken != address(0)) revert InvalidInputToken();\n        // Pull funds (native)\n        TransferLib.transferFunds(address(0), msg.sender, address(this), amountIn);\n        _subscribeCore(amountIn);\n    }\n\n    /**\n     * @dev Allows users to subscribe using Uniswap Permit2 for ERC20 approvals\n     * @param amountIn Amount of input tokens to subscribe with\n     * @param owner Owner of tokens and signer\n     * @param permitSingle Permit2 Single permit data\n     * @param signature EIP-712 signature\n     */\n    function subscribeWithPermit(\n        uint256 amountIn,\n        address owner,\n        IPermit2.PermitSingle calldata permitSingle,\n        bytes calldata signature\n    ) external {\n        if (streamTokens.inSupplyToken == address(0)) revert InvalidInputToken();\n        if (permitSingle.details.token != streamTokens.inSupplyToken) revert InvalidAmount();\n        if (permitSingle.details.amount < uint160(amountIn)) revert InvalidAmount();\n        if (permitSingle.spender != address(this)) revert InvalidAmount();\n        if (permitSingle.sigDeadline < block.timestamp) revert InvalidAmount();\n\n        IPermit2 permit2 = IPermit2(PERMIT2);\n        permit2.permit(owner, permitSingle, signature);\n        permit2.transferFrom(owner, address(this), uint160(amountIn), streamTokens.inSupplyToken);\n        _subscribeCore(amountIn);\n    }\n\n    /**\n     * @dev Allows users to withdraw their input tokens from the stream\n     * @param cap Amount of input tokens to withdraw\n     */\n    function withdraw(uint256 cap) external {\n        // Load position once\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n\n        // Validate position\n        validatePosition(position, msg.sender);\n\n        // load stream times\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (status != StreamTypes.Status.Active && status != StreamTypes.Status.Bootstrapping) {\n            revert OperationNotAllowed();\n        }\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        // Sync position with the updated state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // If cap is 0, withdraw all available balance\n        uint256 withdrawAmount = (cap == 0) ? position.inBalance : cap;\n\n        // Check if withdrawal amount exceeds position balance\n        if (withdrawAmount > position.inBalance) revert WithdrawAmountExceedsBalance(withdrawAmount);\n\n        uint256 shareDeduction = 0;\n\n        if (withdrawAmount == position.inBalance) {\n            shareDeduction = position.shares;\n        } else {\n            shareDeduction = StreamMathLib.computeSharesAmount(withdrawAmount, true, state.inSupply, state.shares);\n        }\n\n        // Update position\n        position.shares = position.shares - shareDeduction;\n        position.inBalance = position.inBalance - withdrawAmount;\n\n        // Update stream state\n        state.inSupply = state.inSupply - withdrawAmount;\n        state.shares = state.shares - shareDeduction;\n\n        // Save all states first\n        saveStreamStatus(status);\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        // Emit events\n        emit Withdrawn(\n            address(this),\n            msg.sender,\n            position.inBalance,\n            position.shares,\n            position.lastUpdateTime,\n            position.spentIn,\n            position.purchased,\n            position.index.value,\n            state.inSupply,\n            state.shares\n        );\n\n        // Transfer tokens\n        TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), msg.sender, withdrawAmount);\n        \n        // Call withdrawal hook\n        _onWithdraw(msg.sender, withdrawAmount);\n    }\n\n    /**\n     * @dev Allows users to exit the stream and receive their tokens based on stream outcome\n     */\n    function exitStream() external {\n        // Load and validate position\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n        if (position.exitDate != 0) revert InvalidPosition(msg.sender, position.shares, position.exitDate, \"Position has already exited\");\n\n        // Load and sync stream state\n        StreamTypes.StreamState memory state = syncStream(loadStream());\n\n        // Sync position with updated stream state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // Load and sync stream status\n        StreamTypes.Status status = syncStreamStatus(loadStreamStatus(), loadStreamTimes(), block.timestamp);\n\n        // Store values for distribution before changing state\n        uint256 inBalance = position.inBalance;\n        uint256 purchased = position.purchased;\n        uint256 spentIn = position.spentIn;\n        position.exitDate = block.timestamp;\n\n        // Save updated state before making external calls\n        saveStreamStatus(status);\n        saveStream(state);\n        savePosition(msg.sender, position);\n\n        // Determine outcome\n        bool thresholdReached = (state.spentIn >= state.threshold);\n        bool isSuccess = (status == StreamTypes.Status.FinalizedStreamed ||\n            (status == StreamTypes.Status.Ended && thresholdReached));\n        bool isRefund = (status == StreamTypes.Status.FinalizedRefunded ||\n            status == StreamTypes.Status.Cancelled ||\n            (status == StreamTypes.Status.Ended && !thresholdReached));\n\n        if (isSuccess) {\n            // Case 1: Successful exit - use hook for distribution\n            emit ExitStreamed(address(this), msg.sender, purchased, spentIn, position.index.value, inBalance, block.timestamp);\n            _onExitSuccess(msg.sender, purchased, inBalance);\n        } else if (isRefund) {\n            // Case 2: Refund exit - use hook for refund\n            uint256 totalRefund = inBalance + spentIn;\n            position.purchased = 0;\n            position.spentIn = 0;\n            position.inBalance = totalRefund;\n            savePosition(msg.sender, position);\n            emit ExitRefunded(address(this), msg.sender, position.inBalance, position.spentIn, block.timestamp);\n            _onExitRefund(msg.sender, totalRefund);\n        } else {\n            // Case 3: No exit allowed\n            revert OperationNotAllowed();\n        }\n    }\n\n    /**\n     * @dev Allows the creator to finalize the stream after it has ended\n     */\n    function finalizeStream() external onlyCreator {\n        // Get factory params\n        IStreamFactoryParams factoryContract = IStreamFactoryParams(STREAM_FACTORY_ADDRESS);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (status != StreamTypes.Status.Ended) {\n            revert OperationNotAllowed();\n        }\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        bool thresholdReached = state.spentIn >= state.threshold;\n\n        // Store values needed for distribution before state changes\n        uint256 outRemaining = state.outRemaining;\n        uint256 outSupply = state.outSupply;\n        uint256 spentIn = state.spentIn;\n\n        if (thresholdReached) {\n            address feeCollector = params.feeCollector;\n            Decimal memory exitFeeRatio = params.exitFeeRatio;\n            // Calculate exit fee\n            (uint256 feeAmount, uint256 creatorRevenue) = StreamMathLib.calculateExitFee(spentIn, exitFeeRatio);\n\n            // Update status\n            status = StreamTypes.Status.FinalizedStreamed;\n            saveStreamStatus(status);\n            saveStream(state);\n\n            // External calls last\n            TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), feeCollector, feeAmount);\n            \n            // Call hook for final distribution\n            uint256 adjustedCreatorRevenue = _afterFinalizeSuccess(creatorRevenue, outRemaining);\n            emit FinalizedStreamed(address(this), creator, adjustedCreatorRevenue, feeAmount, outRemaining);\n        } else {\n            // Update status\n            status = StreamTypes.Status.FinalizedRefunded;\n            saveStreamStatus(status);\n            saveStream(state);\n\n            // Emit event before external call\n            emit FinalizedRefunded(address(this), creator, outSupply);\n\n            // Call hook for refund\n            _afterFinalizeRefund(outSupply);\n        }\n    }\n\n    /**\n     * @dev Allows the creator to cancel the stream during the Waiting phase\n     */\n    function cancelStream() external onlyCreator {\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (status != StreamTypes.Status.Waiting) {\n            revert OperationNotAllowed();\n        }\n\n        // Store amount to transfer before updating state\n        uint256 amountToTransfer = streamState.outSupply;\n\n        // Update status\n        status = StreamTypes.Status.Cancelled;\n        saveStreamStatus(status);\n\n        emit StreamCancelled(address(this), creator, amountToTransfer, uint8(status));\n        TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), creator, amountToTransfer);\n    }\n\n    /**\n     * @dev Allows the protocol admin to cancel the stream\n     */\n    function cancelWithAdmin() external onlyProtocolAdmin {\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (\n            status != StreamTypes.Status.Waiting &&\n            status != StreamTypes.Status.Bootstrapping &&\n            status != StreamTypes.Status.Active\n        ) {\n            revert OperationNotAllowed();\n        }\n\n        // Store amount to transfer before updating state\n        uint256 amountToTransfer = streamState.outSupply;\n\n        // Update status\n        status = StreamTypes.Status.Cancelled;\n        saveStreamStatus(status);\n\n        emit StreamCancelled(address(this), creator, amountToTransfer, uint8(status));\n\n        // External call last\n        TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), creator, amountToTransfer);\n    }\n\n    /**\n     * @dev Allows the creator to update the stream metadata\n     */\n    function updateStreamMetadata(string memory metadataIpfsHash) external onlyCreator {\n        streamMetadata.ipfsHash = metadataIpfsHash;\n        emit StreamMetadataUpdated(address(this), metadataIpfsHash);\n    }\n\n    // ============ External Sync Functions ============\n\n    /**\n     * @dev External function to sync the stream state and status\n     */\n    function syncStreamExternal() external {\n        // Load, update and save stream state\n        StreamTypes.StreamState memory state = loadStream();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        state = syncStream(state);\n        saveStream(state);\n\n        // Load, update and save status\n        StreamTypes.Status status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n        saveStreamStatus(status);\n\n        emit StreamSynced(\n            address(this),\n            state.lastUpdated,\n            uint8(status),\n            state.distIndex.value,\n            state.outRemaining,\n            state.inSupply,\n            state.spentIn,\n            state.currentStreamedPrice.value\n        );\n    }\n\n    /**\n     * @dev External function to sync a specific user's position\n     * @param user Address of the user whose position should be synced\n     */\n    function syncPositionExternal(address user) external {\n        PositionTypes.Position memory position = loadPosition(user);\n        validatePosition(position, user);\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n        savePosition(user, position);\n        saveStream(state);\n        emit PositionSynced(\n            address(this),\n            user,\n            position.inBalance,\n            position.shares,\n            position.lastUpdateTime,\n            position.spentIn,\n            position.purchased,\n            position.index.value\n        );\n    }\n\n    // ============ View Functions ============\n\n    function getStreamStatus() external view returns (StreamTypes.Status) {\n        return streamStatus;\n    }\n\n    function getStreamState() external view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    function getStreamMetadata() external view returns (StreamTypes.StreamMetadata memory) {\n        return streamMetadata;\n    }\n\n    function getPostStreamActions() external view virtual returns (StreamTypes.PostStreamActions memory) {\n        // Default empty actions in core; variants may override and return their own storage\n        StreamTypes.PostStreamActions memory emptyActions;\n        return emptyActions;\n    }\n\n    function getPosition(address user) external view returns (PositionTypes.Position memory) {\n        IPositionStorage positionStorage = IPositionStorage(positionStorageAddress);\n        return positionStorage.getPosition(user);\n    }\n\n    // ============ Internal Helper Functions ============\n\n    function syncStream(StreamTypes.StreamState memory state) internal returns (StreamTypes.StreamState memory) {\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        Decimal memory diff = StreamMathLib.calculateDiff(\n            block.timestamp,\n            times.streamStartTime,\n            times.streamEndTime,\n            state.lastUpdated\n        );\n\n        if (diff.value == 0) {\n            state.lastUpdated = block.timestamp;\n            return state;\n        }\n\n        state = StreamMathLib.calculateUpdatedState(state, diff);\n        state.lastUpdated = block.timestamp;\n\n        emit StreamStateUpdated(\n            address(this),\n            state.lastUpdated,\n            state.distIndex.value,\n            state.outRemaining,\n            state.inSupply,\n            state.spentIn,\n            state.currentStreamedPrice.value\n        );\n\n        return state;\n    }\n\n    function syncStreamStatus(\n        StreamTypes.Status status,\n        StreamTypes.StreamTimes memory times,\n        uint256 nowTime\n    ) internal pure returns (StreamTypes.Status) {\n        status = StreamMathLib.calculateStreamStatus(\n            status,\n            nowTime,\n            times.bootstrappingStartTime,\n            times.streamStartTime,\n            times.streamEndTime\n        );\n\n        return status;\n    }\n\n    // ============ Load Functions ============\n\n    function loadStream() internal view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    function loadStreamStatus() internal view returns (StreamTypes.Status) {\n        return streamStatus;\n    }\n\n    function loadPosition(address user) internal view returns (PositionTypes.Position memory) {\n        IPositionStorage positionStorage = IPositionStorage(positionStorageAddress);\n        return positionStorage.getPosition(user);\n    }\n\n    function loadStreamTimes() internal view returns (StreamTypes.StreamTimes memory) {\n        return streamTimes;\n    }\n\n    // ============ Save Functions ============\n\n    function saveStream(StreamTypes.StreamState memory state) internal {\n        streamState = state;\n    }\n\n    function saveStreamStatus(StreamTypes.Status status) internal {\n        streamStatus = status;\n    }\n\n    function savePosition(address user, PositionTypes.Position memory position) internal {\n        IPositionStorage positionStorage = IPositionStorage(positionStorageAddress);\n        positionStorage.updatePosition(user, position);\n    }\n\n    // ============ Validation Functions ============\n\n    function validatePosition(PositionTypes.Position memory position, address user) internal pure {\n        if (position.shares == 0) {\n            revert InvalidPosition(user, position.shares, position.exitDate, \"Position has no shares\");\n        }\n        if (position.exitDate != 0) {\n            revert InvalidPosition(user, position.shares, position.exitDate, \"Position has already exited\");\n        }\n    }\n\n    // ============ UUPS Upgrade Authorization ============\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract\n     * @param newImplementation Address of the new implementation\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyProtocolAdmin {\n        // Only protocol admin can upgrade\n        // Additional checks can be added here (e.g., timelock, phase restrictions)\n    }\n}\n"
    },
    "src/StreamFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title StreamFactory\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Factory with multi-implementation variants and per-stream UUPS proxies\n * @dev Deploys ERC1967 proxies pointing to selected implementations (Basic/Vesting/Pool/Full).\n *      Initialization is invoked after deploying PositionStorage in the same transaction.\n */\n\nimport { IStreamFactoryEvents } from \"./interfaces/IStreamFactoryEvents.sol\";\nimport { IStreamFactoryErrors } from \"./interfaces/IStreamFactoryErrors.sol\";\nimport { VestingFactory } from \"./VestingFactory.sol\";\nimport { StreamTypes } from \"./types/StreamTypes.sol\";\nimport { IStream } from \"./interfaces/IStream.sol\";\nimport { StreamFactoryTypes } from \"./types/StreamFactoryTypes.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { TransferLib } from \"./lib/TransferLib.sol\";\nimport { PositionStorage } from \"./storage/PositionStorage.sol\";\nimport { DecimalMath, Decimal } from \"./lib/math/DecimalMath.sol\";\nimport { ITokenFactory } from \"./interfaces/ITokenFactory.sol\";\nimport { ERC1967Proxy } from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport { IPoolRouter } from \"./interfaces/IPoolRouter.sol\";\n\ncontract StreamFactory is IStreamFactoryEvents, IStreamFactoryErrors {\n    using TransferLib for address;\n\n    enum StreamImplKind { Basic, PostActions }\n\n    address[] public acceptedInSupplyTokens;\n    uint16 public currentStreamId;\n    StreamFactoryTypes.Params public params;\n    mapping(uint16 => address) public streamAddresses;\n    bool public frozen;\n    bool public initialized;\n\n    mapping(StreamImplKind => address) public implementations;\n\n    modifier onlyOnce() {\n        if (initialized) revert AlreadyInitialized();\n        _;\n        initialized = true;\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != params.protocolAdmin) revert NotAdmin();\n        _;\n    }\n\n    constructor(address protocolAdmin) {\n        if (protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        params.protocolAdmin = protocolAdmin;\n    }\n\n    function initialize(\n        StreamFactoryTypes.InitializeStreamFactoryMessage memory initializeStreamFactoryMessage\n    ) external onlyAdmin onlyOnce {\n        if (DecimalMath.gt(initializeStreamFactoryMessage.exitFeeRatio, DecimalMath.fromNumber(1))) {\n            revert InvalidExitFeeRatio();\n        }\n        if (initializeStreamFactoryMessage.acceptedInSupplyTokens.length == 0) {\n            revert InvalidAcceptedInSupplyTokens();\n        }\n\n        VestingFactory vestingFactory = new VestingFactory();\n        emit VestingContractDeployed(address(this), address(vestingFactory));\n\n        params.streamCreationFee = initializeStreamFactoryMessage.streamCreationFee;\n        params.streamCreationFeeToken = initializeStreamFactoryMessage.streamCreationFeeToken;\n        params.exitFeeRatio = initializeStreamFactoryMessage.exitFeeRatio;\n        params.minWaitingDuration = initializeStreamFactoryMessage.minWaitingDuration;\n        params.minBootstrappingDuration = initializeStreamFactoryMessage.minBootstrappingDuration;\n        params.minStreamDuration = initializeStreamFactoryMessage.minStreamDuration;\n        params.feeCollector = initializeStreamFactoryMessage.feeCollector;\n        params.tosVersion = initializeStreamFactoryMessage.tosVersion;\n        params.vestingFactoryAddress = address(vestingFactory);\n        params.poolRouterAddress = initializeStreamFactoryMessage.poolRouterAddress;\n        params.tokenFactoryAddress = initializeStreamFactoryMessage.tokenFactoryAddress;\n\n        acceptedInSupplyTokens = initializeStreamFactoryMessage.acceptedInSupplyTokens;\n\n        implementations[StreamImplKind.Basic] = initializeStreamFactoryMessage.basicImplementationAddress;\n        implementations[StreamImplKind.PostActions] = initializeStreamFactoryMessage.postActionsImplementationAddress;\n\n        emit FactoryInitialized(\n            address(this),\n            initializeStreamFactoryMessage.basicImplementationAddress,\n            initializeStreamFactoryMessage.postActionsImplementationAddress,\n            initializeStreamFactoryMessage.poolRouterAddress,\n            initializeStreamFactoryMessage.feeCollector,\n            initializeStreamFactoryMessage.protocolAdmin,\n            initializeStreamFactoryMessage.streamCreationFeeToken,\n            initializeStreamFactoryMessage.acceptedInSupplyTokens,\n            initializeStreamFactoryMessage.streamCreationFee,\n            initializeStreamFactoryMessage.exitFeeRatio.value,\n            initializeStreamFactoryMessage.minWaitingDuration,\n            initializeStreamFactoryMessage.minBootstrappingDuration,\n            initializeStreamFactoryMessage.minStreamDuration,\n            initializeStreamFactoryMessage.tosVersion,\n            address(vestingFactory)\n        );\n    }\n\n    function updateAcceptedTokens(address[] calldata tokensToAdd, address[] calldata tokensToRemove) external onlyAdmin {\n        for (uint256 i = 0; i < tokensToAdd.length; i++) {\n            address token = tokensToAdd[i];\n            if (!_isAcceptedToken(token)) {\n                acceptedInSupplyTokens.push(token);\n            }\n        }\n        for (uint256 i = 0; i < tokensToRemove.length; i++) {\n            _removeAcceptedToken(tokensToRemove[i]);\n        }\n        emit AcceptedTokensUpdated(address(this), tokensToAdd, tokensToRemove);\n    }\n\n    function setFrozen(bool isFrozen) external onlyAdmin {\n        frozen = isFrozen;\n        emit FrozenStateUpdated(address(this), isFrozen);\n    }\n\n    function updateFeeCollector(address feeCollector) external onlyAdmin {\n        if (feeCollector == address(0)) revert InvalidFeeCollector();\n        address oldFeeCollector = params.feeCollector;\n        params.feeCollector = feeCollector;\n        emit FeeCollectorUpdated(address(this), oldFeeCollector, feeCollector);\n    }\n\n    function updateProtocolAdmin(address protocolAdmin) external onlyAdmin {\n        if (protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        address oldProtocolAdmin = params.protocolAdmin;\n        params.protocolAdmin = protocolAdmin;\n        emit ProtocolAdminUpdated(address(this), oldProtocolAdmin, protocolAdmin);\n    }\n\n    function updateStreamFeeParameters(uint256 streamCreationFee, address streamCreationFeeToken) external onlyAdmin {\n        uint256 oldFee = params.streamCreationFee;\n        address oldFeeToken = params.streamCreationFeeToken;\n        params.streamCreationFee = streamCreationFee;\n        params.streamCreationFeeToken = streamCreationFeeToken;\n        emit StreamFeeParametersUpdated(address(this), oldFee, streamCreationFee, oldFeeToken, streamCreationFeeToken);\n    }\n\n    function updateTimingParameters(\n        uint256 minWaitingDuration,\n        uint256 minBootstrappingDuration,\n        uint256 minStreamDuration\n    ) external onlyAdmin {\n        uint256 oldWaiting = params.minWaitingDuration;\n        uint256 oldBootstrapping = params.minBootstrappingDuration;\n        uint256 oldStream = params.minStreamDuration;\n        params.minWaitingDuration = minWaitingDuration;\n        params.minBootstrappingDuration = minBootstrappingDuration;\n        params.minStreamDuration = minStreamDuration;\n        emit TimingParametersUpdated(\n            address(this), oldWaiting, minWaitingDuration, oldBootstrapping, minBootstrappingDuration, oldStream, minStreamDuration\n        );\n    }\n\n    function updateImplementationParameters(\n        address basicImplementation,\n        address postActionsImplementation\n    ) external onlyAdmin {\n        address oldBasic = implementations[StreamImplKind.Basic];\n        address oldPostActions = implementations[StreamImplKind.PostActions];\n\n        implementations[StreamImplKind.Basic] = basicImplementation;\n        implementations[StreamImplKind.PostActions] = postActionsImplementation;\n\n        emit ImplementationParametersUpdated(\n            address(this),\n            oldBasic,\n            basicImplementation,\n            oldPostActions,\n            postActionsImplementation\n        );\n    }\n\n    function updatePoolRouterAddress(address newPoolRouter) external onlyAdmin {\n        address oldRouter = params.poolRouterAddress;\n        params.poolRouterAddress = newPoolRouter;\n        emit PoolRouterUpdated(address(this), oldRouter, newPoolRouter);\n    }\n\n    function updateExitFeeRatio(Decimal memory exitFeeRatio) external onlyAdmin {\n        if (DecimalMath.gt(exitFeeRatio, DecimalMath.fromNumber(1))) {\n            revert InvalidExitFeeRatio();\n        }\n        uint256 oldRatio = params.exitFeeRatio.value;\n        params.exitFeeRatio = exitFeeRatio;\n        emit ExitFeeRatioUpdated(address(this), oldRatio, exitFeeRatio.value);\n    }\n\n    function updateTosVersion(string memory tosVersion) external onlyAdmin {\n        string memory oldVersion = params.tosVersion;\n        params.tosVersion = tosVersion;\n        emit TosVersionUpdated(address(this), oldVersion, tosVersion);\n    }\n\n    function createStream(StreamTypes.CreateStreamMessage memory createStreamMessage) external payable {\n        if (createStreamMessage.outSupplyToken == address(0)) revert InvalidOutSupplyToken();\n        TransferLib.transferFunds(params.streamCreationFeeToken, msg.sender, params.feeCollector, params.streamCreationFee);\n        uint256 totalOut = createStreamMessage.streamOutAmount + createStreamMessage.poolInfo.poolOutSupplyAmount;\n        TransferLib.transferFunds(createStreamMessage.outSupplyToken, msg.sender, address(this), totalOut);\n        _createStream(createStreamMessage);\n    }\n\n    function createStreamWithTokenCreation(\n        StreamTypes.CreateStreamMessage memory createStreamMessage,\n        StreamTypes.TokenCreationInfo memory tokenCreationInfo\n    ) external payable {\n        uint256 totalNeeded = createStreamMessage.streamOutAmount + createStreamMessage.poolInfo.poolOutSupplyAmount;\n        if (tokenCreationInfo.totalSupply < totalNeeded) revert InvalidTokenTotalSupply();\n        TransferLib.transferFunds(params.streamCreationFeeToken, msg.sender, params.feeCollector, params.streamCreationFee);\n\n        uint256 creatorBalance = tokenCreationInfo.totalSupply - totalNeeded;\n        address[] memory holders = new address[](2);\n        uint256[] memory balances = new uint256[](2);\n        holders[0] = createStreamMessage.creator;\n        balances[0] = creatorBalance;\n        holders[1] = address(this);\n        balances[1] = totalNeeded;\n\n        address tokenAddress = ITokenFactory(params.tokenFactoryAddress).createToken(tokenCreationInfo, holders, balances);\n        createStreamMessage.outSupplyToken = tokenAddress;\n        emit TokenCreated(tokenAddress, tokenCreationInfo.name, tokenCreationInfo.symbol, tokenCreationInfo.decimals, tokenCreationInfo.totalSupply);\n        _createStream(createStreamMessage);\n    }\n\n    function _createStream(StreamTypes.CreateStreamMessage memory msg_) internal {\n        if (frozen) revert ContractFrozen();\n        if (msg_.streamOutAmount == 0) revert ZeroOutSupplyNotAllowed();\n        if (msg_.creator == address(0)) revert InvalidCreator();\n        if (!_isAcceptedToken(msg_.inSupplyToken)) revert StreamInputTokenNotAccepted();\n        if (msg_.inSupplyToken == msg_.outSupplyToken) revert SameInputAndOutputToken();\n        if (keccak256(abi.encodePacked(msg_.tosVersion)) != keccak256(abi.encodePacked(params.tosVersion))) {\n            revert InvalidToSVersion();\n        }\n        if (msg_.poolInfo.poolOutSupplyAmount > 0) {\n            if (params.poolRouterAddress == address(0)) revert PoolRouterNotSet();\n            IPoolRouter(params.poolRouterAddress).validatePoolParams(msg_.poolInfo);\n        }\n        _validateVesting(msg_.creatorVesting);\n        _validateVesting(msg_.beneficiaryVesting);\n        _validateStreamTimes(block.timestamp, msg_.bootstrappingStartTime, msg_.streamStartTime, msg_.streamEndTime);\n        \n\n        StreamImplKind kind = _determineKind(msg_);\n        address impl = implementations[kind];\n        if (impl == address(0)) revert ImplementationNotSet(uint8(kind));\n\n        ERC1967Proxy proxy = new ERC1967Proxy(impl, \"\");\n        address streamAddr = address(proxy);\n\n        PositionStorage positionStorage = new PositionStorage(streamAddr);\n        IStream(streamAddr).initialize(msg_, address(positionStorage));\n\n        uint256 totalOut = msg_.streamOutAmount + msg_.poolInfo.poolOutSupplyAmount;\n        TransferLib.transferFunds(msg_.outSupplyToken, address(this), streamAddr, totalOut);\n\n        uint16 streamId = currentStreamId;\n        currentStreamId++;\n        streamAddresses[streamId] = streamAddr;\n\n        emit StreamCreated(\n            address(this),\n            msg_.outSupplyToken,\n            msg_.inSupplyToken,\n            streamAddr,\n            msg_.creator,\n            address(positionStorage),\n            msg_.streamOutAmount,\n            msg_.poolInfo.poolOutSupplyAmount,\n            msg_.poolInfo.dexType == StreamTypes.DexType.V2 ? \"V2\" : (msg_.poolInfo.dexType == StreamTypes.DexType.V3 ? \"V3\" : \"AERO\"),\n            msg_.creatorVesting.isVestingEnabled,\n            msg_.beneficiaryVesting.isVestingEnabled,\n            msg_.creatorVesting.vestingDuration,\n            msg_.beneficiaryVesting.vestingDuration,\n            msg_.bootstrappingStartTime,\n            msg_.streamStartTime,\n            msg_.streamEndTime,\n            msg_.threshold,\n            msg_.metadata.ipfsHash,\n            params.tosVersion,\n            streamId\n        );\n    }\n\n    function _determineKind(StreamTypes.CreateStreamMessage memory msg_) internal pure returns (StreamImplKind) {\n        bool hasVesting = msg_.creatorVesting.isVestingEnabled || msg_.beneficiaryVesting.isVestingEnabled;\n        bool hasPool = msg_.poolInfo.poolOutSupplyAmount > 0;\n        if (hasVesting || hasPool) return StreamImplKind.PostActions;\n        return StreamImplKind.Basic;\n    }\n\n    // ============ View ============\n    function getStreams() external view returns (address[] memory) {\n        address[] memory streams = new address[](currentStreamId);\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            streams[i] = streamAddresses[i];\n        }\n        return streams;\n    }\n\n    function getStream(uint16 streamId) external view returns (address) {\n        return streamAddresses[streamId];\n    }\n\n    function isStream(address streamAddress) external view returns (bool) {\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            if (streamAddresses[i] == streamAddress) return true;\n        }\n        return false;\n    }\n\n    function getParams() external view returns (StreamFactoryTypes.Params memory) {\n        return params;\n    }\n\n    function getImplementation(StreamImplKind kind) external view returns (address) {\n        return implementations[kind];\n    }\n\n    function isAcceptedInSupplyToken(address token) external view returns (bool) {\n        return _isAcceptedToken(token);\n    }\n\n    function getAcceptedInSupplyTokens() external view returns (address[] memory) {\n        return acceptedInSupplyTokens;\n    }\n\n    // ============ Internal Helpers ============\n    function _isAcceptedToken(address token) internal view returns (bool) {\n        for (uint256 i = 0; i < acceptedInSupplyTokens.length; i++) {\n            if (acceptedInSupplyTokens[i] == token) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _removeAcceptedToken(address token) internal {\n        for (uint256 i = 0; i < acceptedInSupplyTokens.length; i++) {\n            if (acceptedInSupplyTokens[i] == token) {\n                acceptedInSupplyTokens[i] = acceptedInSupplyTokens[acceptedInSupplyTokens.length - 1];\n                acceptedInSupplyTokens.pop();\n                return;\n            }\n        }\n    }\n\n    function _validateStreamTimes(\n        uint256 nowTime,\n        uint256 bootstrappingStartTime,\n        uint256 startTime,\n        uint256 endTime\n    ) internal view {\n        if (nowTime > bootstrappingStartTime) revert InvalidBootstrappingStartTime();\n        if (bootstrappingStartTime > startTime) revert InvalidStreamStartTime();\n        if (startTime > endTime) revert InvalidStreamEndTime();\n        if (endTime - startTime < params.minStreamDuration) revert StreamDurationTooShort();\n        if (startTime - bootstrappingStartTime < params.minBootstrappingDuration) revert BootstrappingDurationTooShort();\n        if (bootstrappingStartTime - nowTime < params.minWaitingDuration) revert WaitingDurationTooShort();\n    }\n\n    function _validateVesting(StreamTypes.VestingInfo memory vesting) internal pure {\n        if (vesting.isVestingEnabled && vesting.vestingDuration == 0) {\n            revert InvalidVestingDuration();\n        }\n    }\n}\n\n\n"
    },
    "src/StreamPostActions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title StreamPostActions\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Stream implementation that supports both vesting and pool creation\n * @dev Consolidates logic formerly split across StreamWithVesting/StreamWithPool/StreamFull.\n */\n\nimport { StreamCore } from \"./StreamCore.sol\";\nimport { StreamTypes } from \"./types/StreamTypes.sol\";\nimport { StreamFactoryTypes } from \"./types/StreamFactoryTypes.sol\";\nimport { IStreamFactoryParams } from \"./interfaces/IStreamFactoryParams.sol\";\nimport { IVestingFactory } from \"./interfaces/IVestingFactory.sol\";\nimport { PoolWrapperTypes } from \"./types/PoolWrapperTypes.sol\";\nimport { DecimalMath, Decimal } from \"./lib/math/DecimalMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { TransferLib } from \"./lib/TransferLib.sol\";\nimport { PoolOps } from \"./lib/PoolOps.sol\";\n\ncontract StreamPostActions is StreamCore {\n    using PoolOps for *;\n\n    string public constant VERSION = \"1.0.0\";\n    string public constant VARIANT = \"PostActions\";\n\n    // ============ State ============\n    /// @notice Post-stream actions like vesting and pool creation (variant-specific)\n    StreamTypes.PostStreamActions public postStreamActions;\n    \n    // ============ Getters ============\n    function getPostStreamActions() external view override returns (StreamTypes.PostStreamActions memory) {\n        return postStreamActions;\n    }\n\n    // ============ Override Hooks ============\n\n    function _onInitialize(StreamTypes.CreateStreamMessage memory createStreamMessage) internal override {\n        // Validate vesting configurations\n        if (createStreamMessage.creatorVesting.isVestingEnabled) {\n            if (createStreamMessage.creatorVesting.vestingDuration == 0) {\n                revert InvalidVestingDuration();\n            }\n        }\n        if (createStreamMessage.beneficiaryVesting.isVestingEnabled) {\n            if (createStreamMessage.beneficiaryVesting.vestingDuration == 0) {\n                revert InvalidVestingDuration();\n            }\n        }\n\n        // Validate pool config if enabled\n        if (createStreamMessage.poolInfo.poolOutSupplyAmount > 0) {\n            if (createStreamMessage.poolInfo.poolOutSupplyAmount > createStreamMessage.streamOutAmount) {\n                revert InvalidPoolOutSupplyAmount();\n            }\n            if (\n                createStreamMessage.poolInfo.dexType != StreamTypes.DexType.V2\n                    && createStreamMessage.poolInfo.dexType != StreamTypes.DexType.V3\n                    && createStreamMessage.poolInfo.dexType != StreamTypes.DexType.Aerodrome\n            ) {\n                revert InvalidPoolType();\n            }\n        }\n\n        // Store post-stream actions for this variant\n        postStreamActions = StreamTypes.PostStreamActions({\n            poolInfo: createStreamMessage.poolInfo,\n            creatorVesting: createStreamMessage.creatorVesting,\n            beneficiaryVesting: createStreamMessage.beneficiaryVesting\n        });\n    }\n\n    function _afterFinalizeSuccess(uint256 creatorRevenue, uint256 outRemaining) internal override returns (uint256 adjustedCreatorRevenue) {\n        adjustedCreatorRevenue = creatorRevenue;\n\n        if (postStreamActions.poolInfo.poolOutSupplyAmount > 0) {\n            // Compute pool in-supply allocation proportional to out-supply allocation\n            Decimal memory poolRatio = DecimalMath.div(\n                DecimalMath.fromNumber(postStreamActions.poolInfo.poolOutSupplyAmount),\n                DecimalMath.fromNumber(streamState.outSupply)\n            );\n            uint256 poolInSupplyAmount = DecimalMath.floor(DecimalMath.mul(DecimalMath.fromNumber(creatorRevenue), poolRatio));\n            uint256 poolOutSupplyAmount = postStreamActions.poolInfo.poolOutSupplyAmount;\n\n            if (poolInSupplyAmount > 0) {\n                _createPoolAndAddLiquidity(\n                    streamTokens.inSupplyToken,\n                    streamTokens.outSupplyToken,\n                    poolInSupplyAmount,\n                    poolOutSupplyAmount,\n                    postStreamActions.poolInfo.dexType,\n                    creator\n                );\n                adjustedCreatorRevenue = creatorRevenue - poolInSupplyAmount;\n            }\n        }\n\n        // Transfer or vest the adjusted creator revenue\n        if (postStreamActions.creatorVesting.isVestingEnabled && adjustedCreatorRevenue > 0) {\n            _createCreatorVesting(adjustedCreatorRevenue);\n        } else if (adjustedCreatorRevenue > 0) {\n            TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), creator, adjustedCreatorRevenue);\n        }\n\n        // Transfer any remaining output tokens to creator\n        if (outRemaining > 0) {\n            TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), creator, outRemaining);\n        }\n        return adjustedCreatorRevenue;\n    }\n\n    /**\n     * @dev Hook called when a user exits successfully (threshold met)\n     */\n    function _onExitSuccess(address user, uint256 purchased, uint256 inRefunded) internal override {\n        // Refund unused input tokens\n        if (inRefunded > 0) {\n            TransferLib.transferFunds(streamTokens.inSupplyToken, address(this), user, inRefunded);\n        }\n\n        // Vest or transfer purchased output tokens\n        if (postStreamActions.beneficiaryVesting.isVestingEnabled && purchased > 0) {\n            _createBeneficiaryVesting(user, purchased);\n        } else if (purchased > 0) {\n            TransferLib.transferFunds(streamTokens.outSupplyToken, address(this), user, purchased);\n        }\n    }\n\n    // ============ Internal Helper Functions ============\n\n    function _createPoolAndAddLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        StreamTypes.DexType dexType,\n        address streamCreator\n    ) internal {\n        IStreamFactoryParams factoryContract = IStreamFactoryParams(STREAM_FACTORY_ADDRESS);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n        address router = params.poolRouterAddress;\n        if (router == address(0)) revert InvalidDexType();\n\n        // Pre-fund router\n        TransferLib.transferFunds(tokenA, address(this), router, amountADesired);\n        TransferLib.transferFunds(tokenB, address(this), router, amountBDesired);\n\n        (address token0, address token1, uint256 amount0Desired, uint256 amount1Desired) =\n            PoolOps.sortTokensWithAmounts(tokenA, tokenB, amountADesired, amountBDesired);\n\n        PoolWrapperTypes.CreatedPoolInfo memory createdPoolInfo = PoolOps.createPoolViaRouter(\n            router, token0, amount0Desired, token1, amount1Desired, dexType, postStreamActions.poolInfo.extra, streamCreator\n        );\n\n        (uint256 refundedOut, uint256 refundedIn) =\n            PoolOps.mapRefundsToInOut(createdPoolInfo, streamTokens.inSupplyToken, streamTokens.outSupplyToken);\n\n        emit PoolCreated(\n            address(this),\n            createdPoolInfo.poolAddress,\n            createdPoolInfo.token0,\n            createdPoolInfo.token1,\n            createdPoolInfo.amount0,\n            createdPoolInfo.amount1,\n            refundedOut,\n            refundedIn,\n            createdPoolInfo.creator\n        );\n    }\n\n    function _createBeneficiaryVesting(address beneficiary, uint256 amount) internal {\n        IStreamFactoryParams factoryContract = IStreamFactoryParams(STREAM_FACTORY_ADDRESS);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n        IVestingFactory vestingFactory = IVestingFactory(params.vestingFactoryAddress);\n        IERC20(streamTokens.outSupplyToken).approve(params.vestingFactoryAddress, amount);\n        address vestingAddress = vestingFactory.createVestingWalletWithTokens(\n            beneficiary, uint64(block.timestamp), postStreamActions.beneficiaryVesting.vestingDuration, streamTokens.outSupplyToken, amount\n        );\n        emit BeneficiaryVestingCreated(beneficiary, vestingAddress, postStreamActions.beneficiaryVesting.vestingDuration, streamTokens.outSupplyToken, amount);\n    }\n\n    function _createCreatorVesting(uint256 amount) internal {\n        IStreamFactoryParams factoryContract = IStreamFactoryParams(STREAM_FACTORY_ADDRESS);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n        IVestingFactory vestingFactory = IVestingFactory(params.vestingFactoryAddress);\n        IERC20(streamTokens.inSupplyToken).approve(params.vestingFactoryAddress, amount);\n        address vestingAddress = vestingFactory.createVestingWalletWithTokens(\n            creator, uint64(block.timestamp), postStreamActions.creatorVesting.vestingDuration, streamTokens.inSupplyToken, amount\n        );\n        emit CreatorVestingCreated(creator, vestingAddress, postStreamActions.creatorVesting.vestingDuration, streamTokens.inSupplyToken, amount);\n    }\n}\n\n\n"
    },
    "src/types/PoolRouterTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { StreamTypes } from \"./StreamTypes.sol\";\n\nlibrary PoolRouterTypes {\n    struct V3Extra {\n        uint24 fee;\n    }\n\n    struct AerodromeExtra {\n        bool stable;\n    }\n\n    struct CreatePoolRequest {\n        address tokenA;\n        address tokenB;\n        uint256 amountADesired;\n        uint256 amountBDesired;\n        StreamTypes.DexType dexType;\n        bytes extra;        // abi-encoded per-dex extra params\n        address creator;    // LP recipient/refund target\n    }\n}\n\n\n"
    },
    "src/types/PoolWrapperTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nlibrary PoolWrapperTypes {\n    struct CreatePoolMsg {\n        address token0;\n        address token1;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        address creator;\n        bytes extra; // abi-encoded per-dex parameters (optional)\n    }\n\n    struct CreatedPoolInfo {\n        address poolAddress;\n        address token0;\n        address token1;\n        uint256 amount0;\n        uint256 amount1;\n        address creator;\n        uint256 refundedAmount0;\n        uint256 refundedAmount1;\n    }\n}\n"
    },
    "src/types/PositionTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\nlibrary PositionTypes {\n    struct Position {\n        uint256 inBalance;\n        uint256 shares;\n        Decimal index;\n        uint256 lastUpdateTime;\n        Decimal pendingReward;\n        uint256 spentIn;\n        uint256 purchased;\n        uint256 exitDate;\n    }\n}\n"
    },
    "src/types/StreamFactoryTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\nlibrary StreamFactoryTypes {\n    struct Params {\n        uint256 streamCreationFee;\n        address streamCreationFeeToken;\n        Decimal exitFeeRatio;\n        uint256 minWaitingDuration;\n        uint256 minBootstrappingDuration;\n        uint256 minStreamDuration;\n        address feeCollector;\n        address protocolAdmin;\n        string tosVersion;\n        address vestingFactoryAddress;\n        address poolRouterAddress;\n        address tokenFactoryAddress;\n    }\n\n    struct InitializeStreamFactoryMessage {\n        uint256 streamCreationFee;\n        address streamCreationFeeToken;\n        Decimal exitFeeRatio;\n        uint256 minWaitingDuration;\n        uint256 minBootstrappingDuration;\n        uint256 minStreamDuration;\n        address feeCollector;\n        address protocolAdmin;\n        string tosVersion;\n        address poolRouterAddress;\n        // Variant implementations\n        address basicImplementationAddress;\n        address postActionsImplementationAddress;\n        address[] acceptedInSupplyTokens;\n        address tokenFactoryAddress;\n    }\n}\n"
    },
    "src/types/StreamTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\nlibrary StreamTypes {\n    enum Status {\n        Waiting,\n        Bootstrapping,\n        Active,\n        Ended,\n        FinalizedRefunded,\n        FinalizedStreamed,\n        Cancelled\n    }\n\n    enum DexType {\n            V2,\n            V3,\n            Aerodrome\n    }\n\n    struct CreateStreamMessage {\n        address creator;\n        address inSupplyToken;\n        address outSupplyToken;\n        uint256 streamOutAmount;\n        uint256 threshold;\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n        StreamMetadata metadata;\n        VestingInfo creatorVesting;\n        VestingInfo beneficiaryVesting;\n        PoolInfo poolInfo;\n        string tosVersion;\n    }\n    struct StreamTimes {\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n    }\n\n    struct StreamMetadata {\n        string ipfsHash;\n    }\n\n    struct StreamState {\n        uint256 outRemaining;\n        Decimal distIndex;\n        uint256 spentIn;\n        uint256 shares;\n        Decimal currentStreamedPrice;\n        uint256 threshold;\n        uint256 inSupply;\n        uint256 outSupply;\n        uint256 lastUpdated;\n    }\n\n    struct StreamTokens {\n        address inSupplyToken;\n        address outSupplyToken;\n    }\n\n    struct VestingInfo {\n        bool isVestingEnabled;\n        uint64 vestingDuration;\n    }\n\n    struct PoolInfo {\n        uint256 poolOutSupplyAmount;\n        DexType dexType;\n        bytes extra; // abi-encoded dex-specific params (see PoolRouterTypes)\n    }\n\n \n    struct PostStreamActions {\n        PoolInfo poolInfo;\n        VestingInfo creatorVesting;\n        VestingInfo beneficiaryVesting;\n    }\n\n    struct TokenCreationInfo {\n        string name;\n        string symbol;\n        uint8 decimals;\n        uint256 totalSupply;\n    }\n}\n"
    },
    "src/VestingFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title VestingFactory\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Factory for creating OpenZeppelin VestingWallet instances for stream participants\n * @dev This contract creates vesting wallets for post-stream token distribution:\n *      - Creates VestingWallet instances using OpenZeppelin's audited implementation\n *      - Handles token transfers to newly created vesting contracts\n *      - Used for both creator and beneficiary vesting scenarios\n *      - Ensures secure and standardized vesting functionality\n */\n\nimport { VestingWallet } from \"@openzeppelin/contracts/finance/VestingWallet.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { TransferLib } from \"./lib/TransferLib.sol\";\n\n/**\n * @title VestingFactory\n * @dev Factory contract for creating OpenZeppelin VestingWallet instances\n */\ncontract VestingFactory {\n    using SafeERC20 for IERC20;\n\n    // Custom errors\n    error InvalidBeneficiary();\n    error InvalidStartTime();\n    error InvalidDuration();\n    error InvalidAmount();\n    error TokenTransferFailed();\n\n    event VestingWalletCreated(\n        address indexed beneficiary,\n        address indexed vestingWallet,\n        uint64 startTime,\n        uint64 duration,\n        address token,\n        uint256 amount\n    );\n\n    /**\n     * @dev Creates a VestingWallet and transfers tokens to it in one transaction\n     * @param beneficiary address of the beneficiary\n     * @param startTime the time (as Unix time) at which point vesting begins\n     * @param duration duration in seconds of the period in which the tokens will vest\n     * @param token the token to transfer to the vesting wallet (zero address for native token)\n     * @param amount the amount of tokens to transfer\n     * @return vestingWallet the address of the created VestingWallet\n     * @notice When token is address(0), native tokens are sent via msg.value. For ERC20 tokens, \n     *         the caller must approve this contract first.\n     */\n    function createVestingWalletWithTokens(\n        address beneficiary,\n        uint64 startTime,\n        uint64 duration,\n        address token,\n        uint256 amount\n    ) external payable returns (address vestingWallet) {\n        if (beneficiary == address(0)) revert InvalidBeneficiary();\n        if (startTime == 0) revert InvalidStartTime();\n        if (startTime < block.timestamp) revert InvalidStartTime();\n        if (duration == 0) revert InvalidDuration();\n        if (amount == 0) revert InvalidAmount();\n\n        // Create the vesting wallet\n        vestingWallet = address(new VestingWallet(beneficiary, startTime, duration));\n\n        // Transfer tokens (native or ERC20) to the vesting wallet using shared lib\n        // For native, this enforces msg.value == amount and handles sending safely.\n        TransferLib.transferFunds(token, msg.sender, vestingWallet, amount);\n\n        emit VestingWalletCreated(beneficiary, vestingWallet, startTime, duration, token, amount);\n        return vestingWallet;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}