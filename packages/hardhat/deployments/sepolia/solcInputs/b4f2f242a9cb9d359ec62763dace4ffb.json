{
  "language": "Solidity",
  "sources": {
    "contracts/DecimalMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title DecimalMath\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\nlibrary DecimalMath {\n    // We'll use 6 decimal places for precision\n    uint256 public constant DECIMAL_PRECISION = 1e6;\n\n    // Convert a regular number to a decimal representation\n    function fromNumber(uint256 value) internal pure returns (uint256) {\n        return value * DECIMAL_PRECISION;\n    }\n\n    function floor(uint256 value) internal pure returns (uint256) {\n        return value / DECIMAL_PRECISION;\n    }\n\n    function ceil(uint256 value) internal pure returns (uint256) {\n        return (value + DECIMAL_PRECISION - 1) / DECIMAL_PRECISION;\n    }\n\n    // Multiply two decimal numbers\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * b) / DECIMAL_PRECISION;\n    }\n\n    // Divide two decimal numbers\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * DECIMAL_PRECISION) / b;\n    }\n\n    // Add two decimal numbers\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    // Subtract two decimal numbers\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n}\n"
    },
    "contracts/PositionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./PositionTypes.sol\";   \n\ncontract PositionStorage {\n    using PositionTypes for PositionTypes.Position;\n\n    mapping(address => PositionTypes.Position) private positions;\n    address public immutable streamContractAddress;\n\n    constructor() {\n        streamContractAddress = msg.sender;\n    }\n\n    function getPosition(address _owner) external view returns (PositionTypes.Position memory) {\n        return positions[_owner];\n    }\n\n    modifier onlySender() {\n        require(msg.sender == streamContractAddress, \"Position can only be set by the stream contract\");\n        _;\n    }\n\n    function createPosition(\n        address owner,\n        uint256 inBalance,\n        uint256 shares,\n        uint256 index\n    ) external onlySender {\n        positions[owner] = PositionTypes.Position(inBalance, shares, index, block.timestamp, 0, 0, 0, 0);\n    }\n\n    function updatePosition(\n        address owner,\n        PositionTypes.Position memory position\n    ) external onlySender {\n        positions[owner] = position;\n    }\n\n    function setExitDate(address owner, uint256 exitDate) external onlySender {\n        positions[owner].exitDate = exitDate;\n    }\n}\n"
    },
    "contracts/PositionTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary PositionTypes {\n    struct Position {\n        uint256 inBalance;\n        uint256 shares;\n        uint256 index;\n        uint256 lastUpdateTime;\n        uint256 pendingReward;\n        uint256 spentIn;\n        uint256 purchased;\n        uint256 exitDate;\n    }\n} "
    },
    "contracts/Stream.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./PositionStorage.sol\";\nimport \"./PositionTypes.sol\";\nimport \"./StreamEvents.sol\";\nimport \"./StreamErrors.sol\";\nimport \"./StreamTypes.sol\";\nimport \"./StreamFactory.sol\";\nimport \"./DecimalMath.sol\";\nimport \"./StreamMathLib.sol\";\n\nimport \"hardhat/console.sol\";\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract Stream is IStreamErrors, IStreamEvents {\n    address public creator;\n    address public positionStorageAddress;\n    string public name;\n\n    IStreamTypes.StreamState public streamState;\n    IStreamTypes.StreamTokens public streamTokens;\n    IStreamTypes.StreamMetadata public streamMetadata;\n    IStreamTypes.StatusInfo public streamStatus;\n    IStreamTypes.StreamTimes public streamTimes;\n    address public factory;\n\n    PositionStorage public positionStorage;\n\n    // constructor should return its address\n    constructor(\n        uint256 _streamOutAmount,\n        address _outSupplyToken,\n        uint256 _bootstrappingStartTime,\n        uint256 _streamStartTime,\n        uint256 _streamEndTime,\n        uint256 _threshold,\n        string memory _name,\n        address _inSupplyToken,\n        address _creator\n    ) {\n        // Validate that output token is a valid ERC20\n        if (!isValidERC20(_outSupplyToken, msg.sender)) {\n            revert InvalidOutSupplyToken();\n        }\n\n        // Check if the contract has enough balance of output token\n        if (!hasEnoughBalance(_outSupplyToken, address(this), _streamOutAmount)) {\n            revert InsufficientOutAmount();\n        }\n\n        // Validate that in token is a valid ERC20\n        if (!isValidERC20(_inSupplyToken, msg.sender)) {\n            revert InvalidInSupplyToken();\n        }\n\n        creator = _creator;\n        positionStorage = new PositionStorage();\n        positionStorageAddress = address(positionStorage);\n\n        streamState = IStreamTypes.StreamState({\n            distIndex: 0,\n            outRemaining: _streamOutAmount,\n            inSupply: 0,\n            spentIn: 0,\n            shares: 0,\n            currentStreamedPrice: 0,\n            threshold: _threshold,\n            outSupply: _streamOutAmount,\n            lastUpdated: block.timestamp\n        });\n\n        streamTokens = IStreamTypes.StreamTokens({ inSupplyToken: _inSupplyToken, outSupplyToken: _outSupplyToken });\n\n        streamMetadata = IStreamTypes.StreamMetadata({ name: _name });\n\n        streamStatus.status = IStreamTypes.Status.Waiting;\n\n        streamTimes = IStreamTypes.StreamTimes({\n            bootstrappingStartTime: _bootstrappingStartTime,\n            streamStartTime: _streamStartTime,\n            streamEndTime: _streamEndTime\n        });\n\n        // Store the factory address\n        factory = msg.sender;\n    }\n\n    function syncStream(\n        IStreamTypes.StreamState memory state,\n        IStreamTypes.StreamTimes memory times,\n        uint256 nowTime\n    ) internal pure returns (IStreamTypes.StreamState memory) {\n        uint256 diff = StreamMathLib.calculateDiff(\n            nowTime,\n            times.streamStartTime,\n            times.streamEndTime,\n            state.lastUpdated\n        );\n\n        if (diff > 0) {\n            IStreamTypes.StreamState memory updatedState = StreamMathLib.calculateUpdatedState(state, diff);\n            return updatedState;\n        }\n\n        return state;\n    }\n\n    function saveStreamState(IStreamTypes.StreamState memory state) internal {\n        streamState = state;\n    }\n\n    function loadStreamState() internal view returns (IStreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    /**\n     * @dev Validates if an operation is allowed based on the current stream status\n     * @param allowedStatuses Array of allowed statuses for the operation\n     * @return bool True if the operation is allowed, false otherwise\n     */\n    function isOperationAllowed(\n        IStreamTypes.Status currentStatus,\n        IStreamTypes.Status[] memory allowedStatuses\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < allowedStatuses.length; i++) {\n            if (currentStatus == allowedStatuses[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Safely transfers tokens from the contract to a recipient\n     * @param tokenAddress Address of the token to transfer\n     * @param recipient Address of the recipient\n     * @param amount Amount of tokens to transfer\n     * @return bool True if the transfer was successful\n     */\n    function safeTokenTransfer(address tokenAddress, address recipient, uint256 amount) internal returns (bool) {\n        if (amount == 0 || recipient == address(0)) {\n            return true;\n        }\n\n        IERC20 token = IERC20(tokenAddress);\n        bool success = token.transfer(recipient, amount);\n        if (!success) {\n            revert PaymentFailed();\n        }\n        return true;\n    }\n\n    /**\n     * @dev Checks if the threshold has been reached for stream finalization\n     * @return bool True if the threshold has been reached, false otherwise\n     */\n    function isThresholdReached(IStreamTypes.StreamState memory state) internal pure returns (bool) {\n        return state.spentIn >= state.threshold;\n    }\n\n    /**\n     * @dev Validates a position exists and is active\n     * @param position The position to validate\n     * @return bool True if the position is valid and active\n     */\n    function isValidActivePosition(PositionTypes.Position memory position) internal pure returns (bool) {\n        return position.shares > 0 && position.exitDate == 0;\n    }\n\n    function withdraw(uint256 cap) external {\n        if (cap == 0) {\n            revert InvalidWithdrawAmount();\n        }\n\n        // Load position once\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n        if (position.shares == 0) {\n            revert OperationNotAllowed();\n        }\n\n        if (cap > position.inBalance) {\n            revert WithdrawAmountExceedsBalance(cap);\n        }\n\n        // load stream times\n        IStreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        // Load and update status\n        IStreamTypes.StatusInfo memory status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        IStreamTypes.Status[] memory allowedStatuses = new IStreamTypes.Status[](2);\n        allowedStatuses[0] = IStreamTypes.Status.Active;\n        allowedStatuses[1] = IStreamTypes.Status.Bootstrapping;\n        isOperationAllowed(status.status, allowedStatuses);\n\n        // Save the updated status\n        saveStreamStatus(status);\n\n        // Load and update stream state\n        IStreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state, times, block.timestamp);\n\n        // Sync position with the updated state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        if (cap == position.inBalance) {\n            position.shares = 0;\n            position.inBalance = 0;\n        } else {\n            position.shares =\n                position.shares -\n                StreamMathLib.computeSharesAmount(cap, true, state.inSupply, position.shares);\n            position.inBalance = position.inBalance - cap;\n        }\n\n        // Update stream state\n        state.inSupply = state.inSupply - cap;\n        state.shares = state.shares - StreamMathLib.computeSharesAmount(cap, true, state.inSupply, state.shares);\n\n        // Save everything at the end\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        // Token transfer\n        safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, cap);\n        emit Withdrawn(msg.sender, cap);\n    }\n\n    function subscribe(uint256 amountIn) external payable {\n        // Load status once\n        IStreamTypes.StatusInfo memory status = loadStreamStatus();\n        IStreamTypes.StreamTimes memory times = loadStreamTimes();\n        // Update the loaded status\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed with the updated status\n        IStreamTypes.Status[] memory allowedStatuses = new IStreamTypes.Status[](2);\n        allowedStatuses[0] = IStreamTypes.Status.Bootstrapping;\n        allowedStatuses[1] = IStreamTypes.Status.Active;\n        isOperationAllowed(status.status, allowedStatuses);\n        // Save the updated status\n        saveStreamStatus(status);\n\n        // Validate if sender has enough tokens\n        IERC20 streamInToken = IERC20(streamTokens.inSupplyToken);\n        uint256 streamInTokenBalance = streamInToken.balanceOf(msg.sender);\n        if (streamInTokenBalance < amountIn) {\n            revert InsufficientTokenPayment(amountIn, streamInTokenBalance);\n        }\n\n        // Transfer tokens from sender to this contract\n        bool success = streamInToken.transferFrom(msg.sender, address(this), amountIn);\n        if (!success) {\n            revert PaymentFailed();\n        }\n\n        // Load position once\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n\n        // Load stream state once\n        IStreamTypes.StreamState memory state = loadStream();\n\n        // Update the stream state\n        state = syncStream(state);\n\n        uint256 newShares = 0;\n\n        if (position.shares == 0) {\n            // New position case\n            newShares = StreamMathLib.computeSharesAmount(amountIn, false, state.inSupply, state.shares);\n            position = PositionTypes.Position({\n                inBalance: amountIn,\n                shares: newShares,\n                index: state.distIndex,\n                lastUpdateTime: block.timestamp,\n                pendingReward: 0,\n                spentIn: 0,\n                purchased: 0,\n                exitDate: 0\n            });\n        } else {\n            // Update existing position\n            newShares = StreamMathLib.computeSharesAmount(amountIn, false, state.inSupply, state.shares);\n            position = StreamMathLib.syncPosition(\n                position,\n                state.distIndex,\n                state.shares,\n                state.inSupply,\n                block.timestamp\n            );\n            position.inBalance += amountIn;\n            position.shares += newShares;\n        }\n\n        // Update StreamState\n        state.inSupply += amountIn;\n        state.shares += newShares;\n\n        // Save everything once we're done modifying\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        // Emit event\n        emit Subscribed(msg.sender, amountIn, newShares);\n    }\n\n    function exitStream() external {\n        // Load position\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n\n        // Check if position is valid and active\n        if (!isValidActivePosition(position)) {\n            revert OperationNotAllowed();\n        }\n\n        // Load and update stream state\n        IStreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        // Sync position with updated state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // Load and update status\n        IStreamTypes.StatusInfo memory status = loadStreamStatus();\n        IStreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        bool thresholdReached = isThresholdReached(state);\n\n        if (\n            (status.status == IStreamTypes.Status.Ended && thresholdReached) ||\n            (status.status == IStreamTypes.Status.FinalizedStreamed)\n        ) {\n            // Normal exit\n            // Refund in_amount remaining if any in position\n            if (position.inBalance > 0) {\n                safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, position.inBalance);\n            }\n            // send out_amount earned to position owner\n            safeTokenTransfer(streamTokens.outSupplyToken, msg.sender, position.purchased);\n        } else {\n            // Refund total in_amount\n            uint256 total_amount = position.inBalance + position.spentIn;\n            safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, total_amount);\n        }\n\n        // Set exit date\n        position.exitDate = block.timestamp;\n\n        // Save everything\n        saveStreamStatus(status);\n        saveStream(state);\n        savePosition(msg.sender, position);\n\n        emit Exited(msg.sender, position.purchased);\n    }\n\n    function finalizeStream() external {\n        assertIsCreator();\n\n        // Load and update status\n        IStreamTypes.StatusInfo memory status = loadStreamStatus();\n        IStreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        IStreamTypes.Status[] memory allowedStatuses = new IStreamTypes.Status[](1);\n        allowedStatuses[0] = IStreamTypes.Status.Ended;\n        isOperationAllowed(status.status, allowedStatuses);\n\n        // Load and update stream state\n        IStreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state, times, block.timestamp);\n\n        bool thresholdReached = isThresholdReached(state);\n\n        if (thresholdReached) {\n            // Get fee collector from factory\n            StreamFactory factoryContract = StreamFactory(factory);\n            StreamFactory.Params memory params = factoryContract.getParams();\n            address feeCollector = params.feeCollector;\n            uint256 exitFeePercent = params.exitFeePercent;\n            console.log(\"exitFeePercent: %s\", exitFeePercent);\n            console.log(\"state.spentIn: %s\", state.spentIn);\n\n            // Calculate exit fee\n            (uint256 feeAmount, uint256 creatorRevenue) = StreamMathLib.calculateExitFee(state.spentIn, exitFeePercent);\n            console.log(\"feeAmount: %s\", feeAmount);\n            console.log(\"creatorRevenue: %s\", creatorRevenue);\n\n            // Transfer fee to fee collector if needed\n            if (feeAmount > 0) {\n                safeTokenTransfer(streamTokens.inSupplyToken, feeCollector, feeAmount);\n            }\n\n            // Send revenue to creator\n            safeTokenTransfer(streamTokens.inSupplyToken, creator, creatorRevenue);\n\n            // Update status\n            status.status = IStreamTypes.Status.FinalizedStreamed;\n\n            // Refund out tokens to creator if left any\n            if (state.outRemaining > 0) {\n                safeTokenTransfer(streamTokens.outSupplyToken, creator, state.outRemaining);\n            }\n        } else {\n            // Update status\n            status.status = IStreamTypes.Status.FinalizedRefunded;\n\n            // Refund out tokens to creator\n            safeTokenTransfer(streamTokens.outSupplyToken, creator, state.outSupply);\n        }\n\n        // Save everything\n        saveStreamStatus(status);\n        saveStream(state);\n\n        emit StreamFinalized(creator, state.spentIn, state.outRemaining, status.status);\n    }\n\n    function syncStreamExternal() external {\n        // Load, update and save stream state\n        IStreamTypes.StreamState memory state = loadStream();\n        IStreamTypes.StreamTimes memory times = loadStreamTimes();\n        state = syncStream(state, times, block.timestamp);\n        saveStream(state);\n\n        // Load, update and save status\n        IStreamTypes.StatusInfo memory status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n        saveStreamStatus(status);\n    }\n\n    /**\n     * @dev Checks if an address is a valid ERC20 token\n     * @param tokenAddress The token address to validate\n     * @param testAccount The account to use for testing the token interface\n     * @return isValid True if the address implements the ERC20 interface\n     */\n    function isValidERC20(address tokenAddress, address testAccount) internal view returns (bool isValid) {\n        if (tokenAddress == address(0)) {\n            return false;\n        }\n\n        try IERC20(tokenAddress).balanceOf(testAccount) returns (uint256) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Checks if an account has sufficient token balance\n     * @param tokenAddress The ERC20 token address\n     * @param account The account to check balance for\n     * @param requiredAmount The minimum required balance\n     * @return hasEnoughBalance True if the account has sufficient balance\n     */\n    function hasEnoughBalance(\n        address tokenAddress,\n        address account,\n        uint256 requiredAmount\n    ) internal view returns (bool) {\n        IERC20 token = IERC20(tokenAddress);\n        uint256 balance = token.balanceOf(account);\n        return balance >= requiredAmount;\n    }\n\n    // Load helpers\n    function loadStream() internal view returns (IStreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    function loadStreamStatus() internal view returns (IStreamTypes.StatusInfo memory) {\n        return streamStatus;\n    }\n\n    function loadPosition(address user) internal view returns (PositionTypes.Position memory) {\n        return positionStorage.getPosition(user);\n    }\n\n    function loadStreamTimes() internal view returns (IStreamTypes.StreamTimes memory) {\n        return streamTimes;\n    }\n\n    // Save helpers\n    function saveStream(IStreamTypes.StreamState memory state) internal {\n        streamState = state;\n    }\n\n    function saveStreamStatus(IStreamTypes.StatusInfo memory status) internal {\n        streamStatus = status;\n    }\n\n    function savePosition(address user, PositionTypes.Position memory position) internal {\n        positionStorage.updatePosition(user, position);\n    }\n\n    // Refactored syncStream to work directly with a provided memory object\n    function syncStream(IStreamTypes.StreamState memory state) internal view returns (IStreamTypes.StreamState memory) {\n        IStreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        uint256 diff = StreamMathLib.calculateDiff(\n            block.timestamp,\n            times.streamStartTime,\n            times.streamEndTime,\n            state.lastUpdated\n        );\n\n        if (diff > 0) {\n            state = StreamMathLib.calculateUpdatedState(state, diff);\n            state.lastUpdated = block.timestamp;\n        }\n\n        return state;\n    }\n\n    // Refactored syncStreamStatus to work directly with a provided memory object\n    function syncStreamStatus(\n        IStreamTypes.StatusInfo memory status,\n        IStreamTypes.StreamTimes memory times,\n        uint256 nowTime\n    ) internal pure returns (IStreamTypes.StatusInfo memory) {\n        status.status = StreamMathLib.calculateStreamStatus(\n            status.status,\n            nowTime,\n            times.bootstrappingStartTime,\n            times.streamStartTime,\n            times.streamEndTime\n        );\n\n        return status;\n    }\n\n    /**\n     * @dev Ensure value is non-zero\n     * @param value The value to check\n     * @param errorMessage The error message to revert with\n     */\n    function assertNonZero(uint256 value, string memory errorMessage) internal pure {\n        if (value == 0) revert(errorMessage);\n    }\n\n    /**\n     * @dev Ensure sender is the creator\n     */\n    function assertIsCreator() internal view {\n        if (msg.sender != creator) revert Unauthorized();\n    }\n\n    /**\n     * @dev Ensure status matches expected value\n     * @param status Current status to check\n     * @param expectedStatus Status that is expected\n     */\n    function assertStatus(IStreamTypes.Status status, IStreamTypes.Status expectedStatus) internal pure {\n        if (status != expectedStatus) revert OperationNotAllowed();\n    }\n\n    /**\n     * @dev Assert that the cap does not exceed balance\n     * @param cap Amount to withdraw\n     * @param balance Available balance\n     */\n    function assertWithinBalance(uint256 cap, uint256 balance) internal pure {\n        if (cap > balance) revert WithdrawAmountExceedsBalance(cap);\n    }\n}\n"
    },
    "contracts/StreamErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IStreamErrors {\n    // Stream errors\n    error InvalidBootstrappingStartTime();\n    error InvalidStreamStartTime();\n    error InvalidStreamEndTime();\n    error StreamDurationTooShort();\n    error BootstrappingDurationTooShort();\n    error WaitingDurationTooShort();\n    error InsufficientTokenPayment(uint256 requiredTokenAmount, uint256 tokenBalance);\n    error InvalidOutSupplyToken();\n    error InvalidInSupplyToken();\n    error PaymentFailed();\n    error OperationNotAllowed();\n    error Unauthorized();\n    error InvalidWithdrawAmount();\n    error WithdrawAmountExceedsBalance(uint256 cap);\n    error InsufficientOutAmount();\n    // StreamFactory errors\n    error ContractFrozen();\n    error ZeroOutSupplyNotAllowed();\n    error StreamInputTokenNotAccepted();\n    error InvalidBootstrappingTime();\n    error StreamStartMustBeAfterBootstrapping();\n    error StreamEndMustBeAfterStart();\n    error InvalidToSVersion();\n    error InsufficientNativeToken();\n    error FeeTransferFailed();\n    error TokenTransferFailed();\n    error StreamAddressPredictionFailed();\n    error InvalidFeeCollector();\n    error InvalidProtocolAdmin();\n    error NotAdmin();\n} "
    },
    "contracts/StreamEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./StreamTypes.sol\";\n\ninterface IStreamEvents {\n    event StreamCreated(\n        uint256 indexed streamOutAmount,\n        uint256 indexed bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        address indexed streamAddress\n    );\n\n    event StreamSynced(IStreamTypes.Status mainStatus, uint256 lastUpdated);\n\n    event Subscribed(address indexed subscriber, uint256 amountIn, uint256 newShares);\n    event Withdrawn(address indexed subscriber, uint256 amountIn);\n    event Exited(address indexed subscriber, uint256 purchased);\n    event StreamFinalized(address indexed creator, uint256 spentIn, uint256 outRemaining, IStreamTypes.Status status);\n    event ParamsUpdated();\n    event FeeCollectorUpdated(address newFeeCollector);\n    event ProtocolAdminUpdated(address newProtocolAdmin);\n    event FrozenStateUpdated(bool frozen);\n}\n"
    },
    "contracts/StreamFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./Stream.sol\";\nimport \"./StreamEvents.sol\";\nimport \"./StreamErrors.sol\";\n\ncontract StreamFactory is IStreamEvents, IStreamErrors {\n    struct Params {\n        uint256 streamCreationFee;    // Fixed fee to create a stream\n        address streamCreationFeeToken; // Token used for creation fee,\n        uint256 exitFeePercent;       // Fee percentage when exiting a stream\n        uint256 minWaitingDuration;   // Minimum waiting period\n        uint256 minBootstrappingDuration;  // Minimum bootstrapping period\n        uint256 minStreamDuration;    // Minimum duration for a stream\n        address feeCollector;         // Address where fees are collected\n        address protocolAdmin;        // Admin address for protocol\n        string tosVersion;          // Terms of service version\n    }\n\n    mapping(address => bool) public acceptedInSupplyTokens;\n    \n    address public constant NATIVE_TOKEN = address(0);\n\n    uint16 public currentStreamId;\n    \n    Params public params;\n    mapping( uint16 => address) public streamAddresses;\n\n    bool public frozen;\n\n    constructor(\n        uint256 _streamCreationFee,\n        address _streamCreationFeeToken,\n        uint256 _exitFeePercent,\n        uint256 _minWaitingDuration,\n        uint256 _minBootstrappingDuration,\n        uint256 _minStreamDuration,\n        address[] memory _acceptedInSupplyTokens,\n        address _feeCollector,\n        address _protocolAdmin,\n        string memory _tosVersion\n    ) {\n        if (_feeCollector == address(0)) revert InvalidFeeCollector();\n        if (_protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        \n        params = Params({\n            streamCreationFee: _streamCreationFee,\n            streamCreationFeeToken: _streamCreationFeeToken,\n            exitFeePercent: _exitFeePercent,\n            minWaitingDuration: _minWaitingDuration,\n            minBootstrappingDuration: _minBootstrappingDuration,\n            minStreamDuration: _minStreamDuration,\n            feeCollector: _feeCollector,\n            protocolAdmin: _protocolAdmin,\n            tosVersion: _tosVersion\n        });\n\n        // Set accepted tokens\n        for (uint i = 0; i < _acceptedInSupplyTokens.length; i++) {\n            acceptedInSupplyTokens[_acceptedInSupplyTokens[i]] = true;\n        }\n        currentStreamId = 0;\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != params.protocolAdmin) revert NotAdmin();\n        _;\n    }\n\n    function updateParams(\n        uint256 _streamCreationFee,\n        uint256 _exitFeePercent,\n        uint256 _minWaitingDuration,\n        uint256 _minBootstrappingDuration,\n        uint256 _minStreamDuration,\n        string memory _tosVersion\n    ) external onlyAdmin {\n        params.streamCreationFee = _streamCreationFee;\n        params.exitFeePercent = _exitFeePercent;\n        params.minWaitingDuration = _minWaitingDuration;\n        params.minBootstrappingDuration = _minBootstrappingDuration;\n        params.minStreamDuration = _minStreamDuration;\n        params.tosVersion = _tosVersion;\n        \n        emit ParamsUpdated();\n    }\n\n    function updateFeeCollector(address _feeCollector) external onlyAdmin {\n        if (_feeCollector == address(0)) revert InvalidFeeCollector();\n        params.feeCollector = _feeCollector;\n        emit FeeCollectorUpdated(_feeCollector);\n    }\n\n    function updateProtocolAdmin(address _protocolAdmin) external onlyAdmin {\n        if (_protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        params.protocolAdmin = _protocolAdmin;\n        emit ProtocolAdminUpdated(_protocolAdmin);\n    }\n\n    function updateAcceptedTokens(address[] calldata tokens_to_add, address[] calldata tokens_to_remove) external onlyAdmin {\n        for (uint i = 0; i < tokens_to_add.length; i++) {\n            acceptedInSupplyTokens[tokens_to_add[i]] = true;\n        }\n        for (uint i = 0; i < tokens_to_remove.length; i++) {\n            acceptedInSupplyTokens[tokens_to_remove[i]] = false;\n        }\n    }\n\n    function isAcceptedInSupplyToken(address token) public view returns (bool) {\n        return acceptedInSupplyTokens[token];\n    }\n\n    function createStream(\n        uint256 _streamOutAmount,\n        address _outSupplyToken,\n        uint256 _bootstrappingStartTime,\n        uint256 _streamStartTime,\n        uint256 _streamEndTime,\n        uint256 _threshold,\n        string memory _name,\n        address _inSupplyToken,\n        string memory _tosVersion,\n        bytes32 _salt\n    ) external payable {\n        // Check if contract is accepting new streams (not frozen)\n        if (frozen) revert ContractFrozen();\n        \n        // Validate input parameters\n        if (_streamOutAmount == 0) revert ZeroOutSupplyNotAllowed();\n        if (!acceptedInSupplyTokens[_inSupplyToken]) revert StreamInputTokenNotAccepted();\n        \n        // Validate time parameters using validateStreamTimes\n        validateStreamTimes(\n            block.timestamp,\n            _bootstrappingStartTime,\n            _streamStartTime,\n            _streamEndTime\n        );\n        \n        // Validate TOS version\n        if (keccak256(abi.encodePacked(_tosVersion)) != keccak256(abi.encodePacked(params.tosVersion)))\n            revert InvalidToSVersion();\n\n        // Load creation fee\n        uint256 creationFee = params.streamCreationFee;\n        if (creationFee > 0) {\n            if (params.streamCreationFeeToken == address(0)) {\n                // Native token\n                if (msg.value < creationFee) revert InsufficientNativeToken();\n                // Transfer fee to fee collector\n                if (!payable(params.feeCollector).send(creationFee)) revert FeeTransferFailed();\n            } else {\n                // ERC20 token\n                if (!IERC20(params.streamCreationFeeToken).transferFrom(msg.sender, address(params.feeCollector), creationFee)) revert TokenTransferFailed();\n            }\n        }\n        // Increment stream id\n        currentStreamId++;\n        // Predict stream address\nbytes32 bytecodeHash = keccak256(abi.encodePacked(\n    type(Stream).creationCode,\n    abi.encode(\n        _streamOutAmount,\n        _outSupplyToken,\n        _bootstrappingStartTime,\n        _streamStartTime,\n        _streamEndTime,\n        _threshold,\n        _name,\n        _inSupplyToken,\n        msg.sender\n    )\n        ));\n\n        address predictedAddress = predictAddress(address(this), _salt, bytecodeHash);\n        // Transfer out denom to stream contract\n        if (!IERC20(_outSupplyToken).transferFrom(msg.sender, predictedAddress, _streamOutAmount)) revert TokenTransferFailed();\n        // Deploy new stream contract with all parameters\n        Stream newStream = new Stream{salt: _salt}(\n            _streamOutAmount,\n            _outSupplyToken,\n            _bootstrappingStartTime,\n            _streamStartTime,\n            _streamEndTime,\n            _threshold,\n            _name,\n            _inSupplyToken,\n            msg.sender\n            );\n\n        if (address(newStream) != predictedAddress) revert StreamAddressPredictionFailed();\n            \n\n        emit StreamCreated(\n            _streamOutAmount,\n            _bootstrappingStartTime,\n            _streamStartTime,\n            _streamEndTime,\n            address(newStream)\n        );\n    }\n\n    function getStreams() external view returns (address[] memory) {\n        address[] memory streams = new address[](currentStreamId);\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            streams[i] = streamAddresses[i];\n        }\n        return streams;\n    }\n\n    function getStream(uint16 _streamId) external view returns (address) {\n        return streamAddresses[_streamId];\n    }\n\n    function isStream(address _streamAddress) external view returns (bool) {\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            if (streamAddresses[i] == _streamAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getParams() external view returns (Params memory) {\n        return params;\n    }\n\n    // Optional: Add ability to transfer ownership\n    function transferOwnership(address newOwner) external onlyAdmin {\n        if (newOwner == address(0)) revert InvalidProtocolAdmin();\n        params.protocolAdmin = newOwner;\n    }\n\n    function setFrozen(bool _frozen) external onlyAdmin {\n        frozen = _frozen;\n        emit FrozenStateUpdated(_frozen);\n    }\n\n    function predictAddress(address creator, bytes32 _salt, bytes32 bytecodeHash) public pure returns (address) {\n        return address(uint160(uint(keccak256(abi.encodePacked(\n            bytes1(0xff),\n            creator,\n            _salt,\n            bytecodeHash\n        )))));\n    }\n\n    function validateStreamTimes(\n        uint256 nowTime,\n        uint256 _bootstrappingStartTime,\n        uint256 _startTime,\n        uint256 _endTime\n    ) internal view {\n        if (nowTime > _bootstrappingStartTime) revert InvalidBootstrappingStartTime();\n        if (_bootstrappingStartTime > _startTime) revert InvalidStreamStartTime();\n        if (_startTime > _endTime) revert InvalidStreamEndTime();\n        if (_endTime - _startTime < params.minStreamDuration) revert StreamDurationTooShort();\n        if (_startTime - _bootstrappingStartTime < params.minBootstrappingDuration) revert BootstrappingDurationTooShort();\n        if (_bootstrappingStartTime - nowTime < params.minWaitingDuration) revert WaitingDurationTooShort();\n    }\n\n} "
    },
    "contracts/StreamMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./StreamTypes.sol\";\nimport \"./DecimalMath.sol\";\nimport \"./PositionTypes.sol\";\n\nlibrary StreamMathLib {\n    /**\n     * @dev Calculates the time difference ratio between current time and last updated time\n     * @param currentTimestamp Current timestamp\n     * @param streamStartTime Timestamp when the stream starts\n     * @param streamEndTime Timestamp when the stream ends\n     * @param lastUpdated Timestamp when the stream was last updated\n     * @return The ratio of time elapsed since last update compared to total remaining time (scaled by 1e18)\n     */\n    function calculateDiff(\n        uint256 currentTimestamp,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 lastUpdated\n    ) internal pure returns (uint256) {\n        // If the stream is not started yet or already ended, return 0\n        if (currentTimestamp < streamStartTime || lastUpdated >= streamEndTime) {\n            return 0;\n        }\n\n        // If lastUpdated is before start time, set it to start time\n        uint256 effectiveLastUpdated = lastUpdated;\n        if (effectiveLastUpdated < streamStartTime) {\n            effectiveLastUpdated = streamStartTime;\n        }\n\n        // If current time is past end time, use end time instead\n        uint256 effectiveNow = currentTimestamp;\n        if (effectiveNow > streamEndTime) {\n            effectiveNow = streamEndTime;\n        }\n\n        uint256 numerator = effectiveNow - effectiveLastUpdated;\n        uint256 denominator = streamEndTime - effectiveLastUpdated;\n\n        if (denominator == 0 || numerator == 0) {\n            return 0;\n        }\n        // Return ratio of time elapsed since last update compared to total remaining time\n        return (numerator * 1e18) / denominator;\n    }\n\n    /**\n     * @dev Calculates the stream status based on the current state and timestamp\n     * @param currentStatus Current status of the stream\n     * @param currentTime Current timestamp to check against\n     * @param bootstrappingStartTime Timestamp when bootstrapping phase starts\n     * @param streamStartTime Timestamp when active streaming starts\n     * @param streamEndTime Timestamp when streaming ends\n     * @return IStreamTypes.Status The calculated stream status\n     */\n    function calculateStreamStatus(\n        IStreamTypes.Status currentStatus,\n        uint256 currentTime,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime\n    ) internal pure returns (IStreamTypes.Status) {\n        // Don't update if stream is in a final state\n        if (\n            currentStatus == IStreamTypes.Status.Cancelled ||\n            currentStatus == IStreamTypes.Status.FinalizedRefunded ||\n            currentStatus == IStreamTypes.Status.FinalizedStreamed\n        ) {\n            return currentStatus;\n        }\n\n        // Update status based on current timestamp\n        if (currentTime < bootstrappingStartTime) {\n            return IStreamTypes.Status.Waiting;\n        } else if (currentTime >= bootstrappingStartTime && currentTime < streamStartTime) {\n            return IStreamTypes.Status.Bootstrapping;\n        } else if (currentTime >= streamStartTime && currentTime < streamEndTime) {\n            return IStreamTypes.Status.Active;\n        } else if (currentTime >= streamEndTime) {\n            return IStreamTypes.Status.Ended;\n        }\n\n        // This should never be reached, but return current status as fallback\n        return currentStatus;\n    }\n\n    /**\n     * @dev Calculates updated stream state based on time difference\n     * @param state Current stream state\n     * @param diff Time difference in seconds\n     * @return Updated stream state\n     */\n    function calculateUpdatedState(\n        IStreamTypes.StreamState memory state,\n        uint256 diff\n    ) internal pure returns (IStreamTypes.StreamState memory) {\n        // Create a copy of the state to avoid modifying the input\n        IStreamTypes.StreamState memory newState = state;\n\n        if (newState.shares > 0 && diff > 0) {\n            // Calculate new distribution balance and spent in amount\n            uint256 newDistributionBalance = (newState.outRemaining * diff) / 1e18;\n            uint256 spentIn = (newState.inSupply * diff) / 1e18;\n\n            // Update state variables\n            newState.spentIn += spentIn;\n            newState.inSupply -= spentIn;\n\n            if (newDistributionBalance > 0) {\n                newState.outRemaining -= newDistributionBalance;\n                // Update distribution index (shares are in base units, multiply by 1e18 for precision)\n                newState.distIndex += (newDistributionBalance * 1e18) / newState.shares;\n                // Update current streamed price\n                newState.currentStreamedPrice = (spentIn * 1e18) / newDistributionBalance;\n            }\n        }\n\n        return newState;\n    }\n\n    function computeSharesAmount(\n        uint256 amountIn,\n        bool roundUp,\n        uint256 inSupply,\n        uint256 totalShares\n    ) internal pure returns (uint256) {\n        if (totalShares == 0 || amountIn == 0) {\n            return amountIn;\n        }\n\n        uint256 totalSharesIn = totalShares * amountIn;\n        if (roundUp) {\n            return (totalSharesIn + inSupply - 1) / inSupply;\n        } else {\n            return totalSharesIn / inSupply;\n        }\n    }\n\n    /**\n     * @dev Calculates the exit fee amount based on the spent in amount\n     * @param spentInAmount Amount of tokens spent in the stream\n     * @return feeAmount The calculated fee amount\n     * @return remainingAmount The remaining amount after fee deduction\n     */\n    function calculateExitFee(\n        uint256 spentInAmount,\n        uint256 exitFeePercent\n    ) internal pure returns (uint256 feeAmount, uint256 remainingAmount) {\n        uint256 decimalExitFee = exitFeePercent;\n        uint256 decimalSpentIn = DecimalMath.fromNumber(spentInAmount);\n\n        // Calculate exit fee amount using DecimalMath\n        uint256 exitFeeAmount = DecimalMath.mul(decimalSpentIn, decimalExitFee);\n        feeAmount = DecimalMath.floor(exitFeeAmount);\n        remainingAmount = spentInAmount - feeAmount;\n\n        return (feeAmount, remainingAmount);\n    }\n\n    function syncPosition(\n        PositionTypes.Position memory position,\n        uint256 distIndex,\n        uint256 shares,\n        uint256 inSupply,\n        uint256 nowTime\n    ) internal pure returns (PositionTypes.Position memory) {\n        // Create a new position in memory to store the updated values\n        PositionTypes.Position memory updatedPosition = PositionTypes.Position({\n            inBalance: position.inBalance,\n            shares: position.shares,\n            index: position.index,\n            lastUpdateTime: position.lastUpdateTime,\n            pendingReward: position.pendingReward,\n            spentIn: position.spentIn,\n            purchased: position.purchased,\n            exitDate: position.exitDate\n        });\n\n        // Calculate index difference for distributions since last update\n        uint256 indexDiff = distIndex - updatedPosition.index;\n        uint256 spent = 0;\n        uint256 purchased = 0;\n\n        // Only process if there are shares in the stream\n        if (shares > 0) {\n            // Calculate purchased amount based on position shares and index difference\n            uint256 positionPurchased = (updatedPosition.shares * indexDiff) / 1e18 + updatedPosition.pendingReward;\n            // Calculate remaining balance based on current shares ratio\n            uint256 inRemaining = (inSupply * updatedPosition.shares) / shares;\n            // Calculate spent amount\n            spent = updatedPosition.inBalance - inRemaining;\n            updatedPosition.spentIn += spent;\n            updatedPosition.inBalance = inRemaining;\n\n            // Update purchased amount\n            purchased = positionPurchased;\n            updatedPosition.purchased += purchased;\n        }\n\n        // Update position tracking\n        updatedPosition.index = distIndex;\n        updatedPosition.lastUpdateTime = nowTime;\n\n        return updatedPosition;\n    }\n}\n"
    },
    "contracts/StreamTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IStreamTypes {\n    enum Status {\n        Waiting,\n        Bootstrapping,\n        Active,\n        Ended,\n        FinalizedRefunded,\n        FinalizedStreamed,\n        Cancelled\n    }\n\n    struct StatusInfo {\n        Status status;\n    }\n\n    struct StreamTimes {\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n    }\n\n    struct StreamMetadata {\n        string name;\n    }\n\n    struct StreamState {\n        uint256 outRemaining;\n        uint256 distIndex;\n        uint256 spentIn;\n        uint256 shares;\n        uint256 currentStreamedPrice;\n        uint256 threshold;\n        uint256 inSupply;\n        uint256 outSupply;\n        uint256 lastUpdated;\n    }\n\n    struct StreamTokens {\n        address inSupplyToken;\n        address outSupplyToken;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}