{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/finance/VestingWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (finance/VestingWallet.sol)\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/utils/SafeERC20.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @title VestingWallet\n * @dev This contract handles the vesting of Eth and ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract VestingWallet is Context {\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n    address private immutable _beneficiary;\n    uint64 private immutable _start;\n    uint64 private immutable _duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(address beneficiaryAddress, uint64 startTimestamp, uint64 durationSeconds) payable {\n        require(beneficiaryAddress != address(0), \"VestingWallet: beneficiary is zero address\");\n        _beneficiary = beneficiaryAddress;\n        _start = startTimestamp;\n        _duration = durationSeconds;\n    }\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable virtual {}\n\n    /**\n     * @dev Getter for the beneficiary address.\n     */\n    function beneficiary() public view virtual returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Getter for the start timestamp.\n     */\n    function start() public view virtual returns (uint256) {\n        return _start;\n    }\n\n    /**\n     * @dev Getter for the vesting duration.\n     */\n    function duration() public view virtual returns (uint256) {\n        return _duration;\n    }\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view virtual returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view virtual returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /**\n     * @dev Getter for the amount of releasable eth.\n     */\n    function releasable() public view virtual returns (uint256) {\n        return vestedAmount(uint64(block.timestamp)) - released();\n    }\n\n    /**\n     * @dev Getter for the amount of releasable `token` tokens. `token` should be the address of an\n     * IERC20 contract.\n     */\n    function releasable(address token) public view virtual returns (uint256) {\n        return vestedAmount(token, uint64(block.timestamp)) - released(token);\n    }\n\n    /**\n     * @dev Release the native token (ether) that have already vested.\n     *\n     * Emits a {EtherReleased} event.\n     */\n    function release() public virtual {\n        uint256 amount = releasable();\n        _released += amount;\n        emit EtherReleased(amount);\n        Address.sendValue(payable(beneficiary()), amount);\n    }\n\n    /**\n     * @dev Release the tokens that have already vested.\n     *\n     * Emits a {ERC20Released} event.\n     */\n    function release(address token) public virtual {\n        uint256 amount = releasable(token);\n        _erc20Released[token] += amount;\n        emit ERC20Released(token, amount);\n        SafeERC20.safeTransfer(IERC20(token), beneficiary(), amount);\n    }\n\n    /**\n     * @dev Calculates the amount of ether that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(address(this).balance + released(), timestamp);\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(IERC20(token).balanceOf(address(this)) + released(token), timestamp);\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp) internal view virtual returns (uint256) {\n        if (timestamp < start()) {\n            return 0;\n        } else if (timestamp > start() + duration()) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start())) / duration();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "src/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title IPermit2\n * @notice Minimal interface for Uniswap Permit2 used by Stream contract\n * @dev We only include the single-permit allowance flow (PermitSingle) and basic transferFrom\n *      as those are sufficient for subscribeWithPermit. Additional Permit2 functions can be\n *      added later if the protocol needs them.\n */\ninterface IPermit2 {\n    /// @notice Data for a single token allowance\n    struct PermitDetails {\n        address token;       // ERC20 token address\n        uint160 amount;      // allowance amount\n        uint48 expiration;   // timestamp at which allowance expires\n        uint48 nonce;        // unique nonce to prevent replay\n    }\n\n    /// @notice Full permit message for a single token allowance\n    struct PermitSingle {\n        PermitDetails details; // allowance details\n        address spender;       // address being approved to spend the tokens\n        uint256 sigDeadline;   // deadline for the signature (timestamp)\n    }\n\n    /**\n     * @notice Approve token allowance via EIP-712 signature\n     * @param owner The owner of the tokens and signer of the permit\n     * @param permitSingle Full permit data\n     * @param signature Signature over the permit data\n     */\n    function permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature) external;\n\n    /**\n     * @notice Transfer tokens using an existing Permit2 allowance\n     * @param from Token owner\n     * @param to Recipient\n     * @param amount Amount to transfer (uint160 per Permit2 spec)\n     * @param token ERC20 token address\n     */\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n} "
    },
    "src/interfaces/IPoolWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { PoolWrapperTypes } from \"../types/PoolWrapperTypes.sol\";\n\ninterface IPoolWrapper {\n    function createPool(\n        PoolWrapperTypes.CreatePoolMsg calldata createPoolMsg\n    ) external returns (PoolWrapperTypes.CreatedPoolInfo memory);\n\n    function getPoolInfo(address stream) external view returns (PoolWrapperTypes.CreatedPoolInfo memory);\n}\n"
    },
    "src/interfaces/IPositionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { PositionTypes } from \"../types/PositionTypes.sol\";\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\ninterface IPositionStorage {\n    function getPosition(address _owner) external view returns (PositionTypes.Position memory);\n\n    function createPosition(address owner, uint256 inBalance, uint256 shares, Decimal memory index) external;\n\n    function updatePosition(address owner, PositionTypes.Position memory position) external;\n\n    function setExitDate(address owner, uint256 exitDate) external;\n}\n"
    },
    "src/interfaces/IStream.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { StreamTypes } from \"../types/StreamTypes.sol\";\nimport { PositionTypes } from \"../types/PositionTypes.sol\";\n\ninterface IStream {\n    function initialize(\n        StreamTypes.CreateStreamMessage memory createStreamMessage,\n        address positionStorageAddress\n    ) external;\n\n    function withdraw(uint256 cap) external;\n\n    function subscribe(uint256 amountIn) external;\n\n    function exitStream() external;\n\n    function finalizeStream() external;\n\n    function syncStreamExternal() external;\n\n    function syncPositionExternal(address user) external;\n\n    function cancelStream() external;\n\n    function cancelWithAdmin() external;\n\n    // View functions\n    function getStreamStatus() external view returns (StreamTypes.Status);\n\n    function getStreamState() external view returns (StreamTypes.StreamState memory);\n\n    function getPosition(address user) external view returns (PositionTypes.Position memory);\n\n    // State variables getters (since they're public)\n    function creator() external view returns (address);\n\n    function positionStorageAddress() external view returns (address);\n\n    function streamFactoryAddress() external view returns (address);\n\n    function updateStreamMetadata(string memory metadataIpfsHash) external;\n}\n"
    },
    "src/interfaces/IStreamErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IStreamErrors {\n    // Stream errors\n    error InsufficientTokenPayment(uint256 requiredTokenAmount, uint256 tokenBalance);\n    error InvalidOutSupplyToken();\n    error InvalidInSupplyToken();\n    error PaymentFailed();\n    error OperationNotAllowed();\n    error Unauthorized();\n    error InvalidWithdrawAmount();\n    error WithdrawAmountExceedsBalance(uint256 cap);\n    error InsufficientOutAmount();\n    error InvalidPosition(address user, uint256 shares, uint256 exitDate, string reason);\n    error InvalidExitCondition();\n    error InvalidVestingDuration();\n    error InvalidVestingCliffDuration();\n    error InvalidPoolOutSupplyAmount();\n    error InvalidAmount();\n    error StreamFactoryAddressAlreadySet();\n    error InvalidStreamFactoryAddress();\n    error InvalidPositionStorageAddress();\n    error InvalidImplementationAddress();\n    error InvalidInputToken();\n    error SameInputAndOutputToken();\n}\n"
    },
    "src/interfaces/IStreamEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n\n\ninterface IStreamEvents {\n    event StreamCreated(\n        address indexed streamFactoryAddress,\n        address streamOutToken,\n        address streamInToken,\n        address streamAddress,\n        address creator,\n        address positionStorageAddress,\n        uint256 streamOutAmount,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 threshold,\n        string metadataIpfsHash,\n        string tosVersion,\n        uint16 streamId\n    );\n\n    event StreamStateUpdated(\n        address indexed streamAddress,\n        uint256 lastUpdated,\n        uint256 distIndex,\n        uint256 outRemaining,\n        uint256 inSupply,\n        uint256 spentIn,\n        uint256 currentStreamedPrice\n    );\n\n    event Subscribed(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 positionInBalance,\n        uint256 positionShares,\n        uint256 positionLastUpdateTime,\n        uint256 positionSpentIn,\n        uint256 positionPurchased,\n        uint256 positionIndex,\n        uint256 streamInSupply,\n        uint256 streamShares\n    );\n\n    event StreamSynced(\n        address indexed streamAddress,\n        uint256 lastUpdated,\n        uint8 newStatus,\n        uint256 distIndex,\n        uint256 outRemaining,\n        uint256 inSupply,\n        uint256 spentIn,\n        uint256 currentStreamedPrice\n    );\n\n    event PositionSynced(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 positionInBalance,\n        uint256 positionShares,\n        uint256 positionLastUpdateTime,\n        uint256 positionSpentIn,\n        uint256 positionPurchased,\n        uint256 positionIndex\n    );\n\n    event Withdrawn(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 positionInBalance,\n        uint256 positionShares,\n        uint256 positionLastUpdateTime,\n        uint256 positionSpentIn,\n        uint256 positionPurchased,\n        uint256 positionIndex,\n        uint256 streamInSupply,\n        uint256 streamShares\n    );\n\n    event ExitRefunded(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 inBalance,\n        uint256 spentIn,\n        uint256 exitTimestamp\n    );\n    event ExitStreamed(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 purchased,\n        uint256 spentIn,\n        uint256 index,\n        uint256 inBalance,\n        uint256 exitTimestamp\n    );\n\n    event FinalizedStreamed(\n        address indexed streamAddress,\n        address indexed creator,\n        uint256 creatorRevenue,\n        uint256 exitFeeAmount,\n        uint256 refundedOutAmount\n    );\n\n    event FinalizedRefunded(address indexed streamAddress, address indexed creator, uint256 refundedOutAmount);\n\n    event FactoryInitialized(\n        address indexed factory,\n        address streamImplementationAddress,\n        address poolWrapperAddress,\n        address feeCollector,\n        address protocolAdmin,\n        address streamCreationFeeToken,\n        address[] acceptedInSupplyTokens,\n        uint256 streamCreationFee,\n        uint256 exitFeeRatio,\n        uint256 minWaitingDuration,\n        uint256 minBootstrappingDuration,\n        uint256 minStreamDuration,\n        string tosVersion,\n        address vestingAddress\n    );\n\n    event ParamsUpdated(\n        address indexed factory,\n        uint256 streamCreationFee,\n        uint256 exitFeeRatio,\n        uint256 minWaitingDuration,\n        uint256 minBootstrappingDuration,\n        uint256 minStreamDuration,\n        string tosVersion\n    );\n\n    event FeeCollectorUpdated(address indexed factory, address newFeeCollector);\n\n    event ProtocolAdminUpdated(address indexed factory, address newProtocolAdmin);\n\n    event FrozenStateUpdated(address indexed factory, bool frozen);\n\n    event AcceptedTokensUpdated(address indexed factory, address[] tokensAdded, address[] tokensRemoved);\n\n    event StreamCancelled(address indexed streamAddress, address creator, uint256 outSupply, uint8 status);\n\n    event VestingContractDeployed(address indexed factoryAddress, address vestingContract);\n\n    event PoolWrapperUpdated(address indexed factoryAddress, address poolWrapper);\n\n    event StreamMetadataUpdated(address indexed streamAddress, string metadataIpfsHash);\n}\n"
    },
    "src/interfaces/IStreamFactoryErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n// StreamFactory errors\ninterface IStreamFactoryErrors {\n    // StreamFactory errors\n    error InvalidBootstrappingStartTime();\n    error InvalidStreamStartTime();\n    error InvalidStreamEndTime();\n    error StreamDurationTooShort();\n    error BootstrappingDurationTooShort();\n    error WaitingDurationTooShort();\n    error ContractFrozen();\n    error InvalidExitFeeRatio();\n    error ZeroOutSupplyNotAllowed();\n    error StreamInputTokenNotAccepted();\n    error InvalidBootstrappingTime();\n    error StreamStartMustBeAfterBootstrapping();\n    error StreamEndMustBeAfterStart();\n    error InvalidToSVersion();\n    error TokenTransferFailed();\n    error StreamAddressPredictionFailed();\n    error InvalidFeeCollector();\n    error InvalidProtocolAdmin();\n    error NotAdmin();\n    error InvalidPoolWrapper();\n    error InvalidImplementationAddress();\n    error InvalidStreamCreationFeeToken();\n    error AlreadyInitialized();\n    error InvalidAcceptedInSupplyTokens();\n    error InvalidStreamImplementationAddress();\n    error InvalidOutSupplyToken();\n    error InvalidCreator();\n    error InvalidVestingDuration();\n    error SameInputAndOutputToken();\n}\n"
    },
    "src/interfaces/IVestingFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title IVestingFactory\n * @dev Interface for the VestingFactory contract that creates OpenZeppelin VestingWallet instances\n */\ninterface IVestingFactory {\n    /**\n     * @dev Creates a VestingWallet and transfers tokens to it in one transaction\n     * @param beneficiary address of the beneficiary\n     * @param startTime the time (as Unix time) at which point vesting begins\n     * @param duration duration in seconds of the period in which the tokens will vest\n     * @param token the ERC20 token to transfer to the vesting wallet\n     * @param amount the amount of tokens to transfer\n     * @return vestingWallet the address of the created VestingWallet\n     */\n    function createVestingWalletWithTokens(\n        address beneficiary,\n        uint64 startTime,\n        uint64 duration,\n        address token,\n        uint256 amount\n    ) external returns (address vestingWallet);\n\n    /**\n     * @dev Event emitted when a new VestingWallet is created\n     */\n    event VestingWalletCreated(\n        address indexed beneficiary,\n        address indexed vestingWallet,\n        uint64 startTime,\n        uint64 duration,\n        address token,\n        uint256 amount\n    );\n}\n"
    },
    "src/lib/math/DecimalMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title DecimalMath\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Library for high-precision decimal arithmetic operations\n * @dev Provides decimal arithmetic with 6 decimal places precision (1e6):\n *      - Supports basic arithmetic operations (add, sub, mul, div)\n *      - Includes comparison operations (gt, lt)\n *      - Provides conversion between decimals and integers\n *      - Used throughout the protocol for precise calculations\n */\n\n/**\n * @title Decimal type and math operations\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\n\nstruct Decimal {\n    uint256 value; // Value scaled by DECIMAL_PRECISION\n}\n\n/**\n * @title DecimalMath\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\nlibrary DecimalMath {\n    // We'll use 6 decimal places for precision\n    uint256 public constant DECIMAL_PRECISION = 1e6;\n\n    // Convert a regular number to a Decimal\n    function fromNumber(uint256 value) internal pure returns (Decimal memory) {\n        return Decimal({ value: value * DECIMAL_PRECISION });\n    }\n\n    // Convert a Decimal to a regular number while keeping the remainder\n    function toNumber(Decimal memory d) internal pure returns (uint256, Decimal memory) {\n        return (d.value / DECIMAL_PRECISION, Decimal({ value: d.value % DECIMAL_PRECISION }));\n    }\n\n    // Floor division for Decimal\n    function floor(Decimal memory d) internal pure returns (uint256) {\n        return d.value / DECIMAL_PRECISION;\n    }\n\n    // Ceiling division for Decimal\n    function ceil(Decimal memory d) internal pure returns (uint256) {\n        return (d.value + DECIMAL_PRECISION - 1) / DECIMAL_PRECISION;\n    }\n\n    // Multiply two Decimals\n    function mul(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: (a.value * b.value) / DECIMAL_PRECISION });\n    }\n\n    // Multiply Decimal by a scalar\n    function mulScalar(Decimal memory a, uint256 scalar) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value * scalar });\n    }\n\n    // Divide two Decimals\n    function div(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: (a.value * DECIMAL_PRECISION) / b.value });\n    }\n\n    // Divide Decimal by a scalar\n    function divScalar(Decimal memory a, uint256 scalar) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value / scalar });\n    }\n\n    // Add two Decimals\n    function add(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value + b.value });\n    }\n\n    // Subtract two Decimals\n    function sub(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value - b.value });\n    }\n\n    // From ratio to Decimal\n    function fromRatio(uint256 num, uint256 denom) internal pure returns (Decimal memory) {\n        return Decimal({ value: (num * DECIMAL_PRECISION) / denom });\n    }\n\n    // > operator for Decimals\n    function gt(Decimal memory a, Decimal memory b) internal pure returns (bool) {\n        return a.value > b.value;\n    }\n\n    // < operator for Decimals\n    function lt(Decimal memory a, Decimal memory b) internal pure returns (bool) {\n        return a.value < b.value;\n    }\n}\n"
    },
    "src/lib/math/StreamMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title StreamMathLib\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Core mathematical engine powering StreamSwap's time-based distribution algorithm\n * @dev This library implements the mathematical model that enables StreamSwap's unique\n *      continuous token distribution mechanism. Unlike traditional AMMs or auction models,\n *      StreamSwap calculates distributions based on time progression and participation timing.\n *      \n *      Key Algorithms:\n *      - Time Differential Calculation: Determines distribution progress based on elapsed time\n *      - Share-based Distribution: Calculates proportional token allocation per participant\n *      - Dynamic Price Discovery: Computes real-time pricing based on participation\n *      - Position Synchronization: Updates user positions with accrued distributions\n *      - Exit Fee Computation: Applies configurable fees on successful stream exits\n *      \n *      Mathematical Precision:\n *      - Uses DecimalMath library for 6-decimal precision (1e6)\n *      - Handles edge cases like zero participation and boundary conditions\n *      - Prevents overflow/underflow through careful calculation ordering\n *      - Maintains accuracy across different time scales and token amounts\n */\n\nimport { StreamTypes } from \"../../types/StreamTypes.sol\";\nimport { DecimalMath, Decimal } from \"./DecimalMath.sol\";\nimport { PositionTypes } from \"../../types/PositionTypes.sol\";\nlibrary StreamMathLib {\n    /**\n     * @dev Calculates the time difference ratio between current time and last updated time\n     * @param currentTimestamp Current timestamp\n     * @param streamStartTime Timestamp when the stream starts\n     * @param streamEndTime Timestamp when the stream ends\n     * @param lastUpdated Timestamp when the stream was last updated\n     * @return The ratio of time elapsed since last update compared to total remaining time (scaled by 1e18)\n     */\n    function calculateDiff(\n        uint256 currentTimestamp,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 lastUpdated\n    ) internal pure returns (Decimal memory) {\n        // If the stream is not started yet or already ended, return 0\n        if (currentTimestamp < streamStartTime || lastUpdated >= streamEndTime) {\n            return DecimalMath.fromNumber(0);\n        }\n\n        // If lastUpdated is before start time, set it to start time\n        uint256 effectiveLastUpdated = lastUpdated;\n        if (effectiveLastUpdated < streamStartTime) {\n            effectiveLastUpdated = streamStartTime;\n        }\n\n        // If current time is past end time, use end time instead\n        uint256 effectiveNow = currentTimestamp;\n        if (effectiveNow > streamEndTime) {\n            effectiveNow = streamEndTime;\n        }\n\n        uint256 numerator = effectiveNow - effectiveLastUpdated;\n        uint256 denominator = streamEndTime - effectiveLastUpdated;\n\n        if (denominator == 0 || numerator == 0) {\n            return DecimalMath.fromNumber(0);\n        }\n        // Return ratio of time elapsed since last update compared to total remaining time\n        return DecimalMath.fromRatio(numerator, denominator);\n    }\n\n    /**\n     * @dev Calculates the stream status based on the current state and timestamp\n     * @param currentStatus Current status of the stream\n     * @param currentTime Current timestamp to check against\n     * @param bootstrappingStartTime Timestamp when bootstrapping phase starts\n     * @param streamStartTime Timestamp when active streaming starts\n     * @param streamEndTime Timestamp when streaming ends\n     * @return IStreamTypes.Status The calculated stream status\n     */\n    function calculateStreamStatus(\n        StreamTypes.Status currentStatus,\n        uint256 currentTime,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime\n    ) internal pure returns (StreamTypes.Status) {\n        // Don't update if stream is in a final state\n        if (\n            currentStatus == StreamTypes.Status.Cancelled ||\n            currentStatus == StreamTypes.Status.FinalizedRefunded ||\n            currentStatus == StreamTypes.Status.FinalizedStreamed\n        ) {\n            return currentStatus;\n        }\n\n        // Update status based on current timestamp\n        if (currentTime < bootstrappingStartTime) {\n            return StreamTypes.Status.Waiting;\n        } else if (currentTime >= bootstrappingStartTime && currentTime < streamStartTime) {\n            return StreamTypes.Status.Bootstrapping;\n        } else if (currentTime >= streamStartTime && currentTime < streamEndTime) {\n            return StreamTypes.Status.Active;\n        } else if (currentTime >= streamEndTime) {\n            return StreamTypes.Status.Ended;\n        }\n\n        // This should never be reached, but return current status as fallback\n        return currentStatus;\n    }\n\n    /**\n     * @dev Calculates updated stream state based on time difference\n     * @param state Current stream state\n     * @param diff Time difference in seconds\n     * @return Updated stream state\n     */\n    function calculateUpdatedState(\n        StreamTypes.StreamState memory state,\n        Decimal memory diff\n    ) internal pure returns (StreamTypes.StreamState memory) {\n        // Create a copy of the state to avoid modifying the input\n        StreamTypes.StreamState memory newState = state;\n\n        if (newState.shares > 0 && diff.value > 0) {\n            // Calculate new distribution balance and spent in amount\n            Decimal memory newDecimalDistributionBalance = DecimalMath.mul(\n                DecimalMath.fromNumber(newState.outRemaining),\n                diff\n            );\n            uint256 newDistributionBalance = DecimalMath.floor(newDecimalDistributionBalance);\n\n            Decimal memory newDecimalSpentIn = DecimalMath.mul(DecimalMath.fromNumber(newState.inSupply), diff);\n            uint256 spentIn = DecimalMath.floor(newDecimalSpentIn);\n\n            // Update state variables\n            newState.spentIn += spentIn;\n            newState.inSupply -= spentIn;\n\n            if (newDistributionBalance > 0) {\n                newState.outRemaining -= newDistributionBalance;\n                // Increment distribution index\n                Decimal memory distIndexIncrementAmount = DecimalMath.fromRatio(\n                    newDistributionBalance,\n                    newState.shares\n                );\n                newState.distIndex = DecimalMath.add(newState.distIndex, distIndexIncrementAmount);\n                // Update current streamed price\n                newState.currentStreamedPrice = DecimalMath.fromRatio(spentIn, newDistributionBalance);\n            }\n        }\n        return newState;\n    }\n\n    function computeSharesAmount(\n        uint256 amountIn,\n        bool roundUp,\n        uint256 inSupply,\n        uint256 totalShares\n    ) internal pure returns (uint256) {\n        if (totalShares == 0 || amountIn == 0) {\n            return amountIn;\n        }\n\n        uint256 totalSharesIn = totalShares * amountIn;\n\n        if (roundUp) {\n            return (totalSharesIn + inSupply - 1) / inSupply;\n        } else {\n            return totalSharesIn / inSupply;\n        }\n    }\n\n    /**\n     * @dev Calculates the exit fee amount based on the spent in amount\n     * @param spentInAmount Amount of tokens spent in the stream\n     * @return exitFeeAmount The calculated fee amount\n     * @return remainingAmount The remaining amount after fee deduction\n     */\n    function calculateExitFee(\n        uint256 spentInAmount,\n        Decimal memory exitFeeRatio\n    ) internal pure returns (uint256 exitFeeAmount, uint256 remainingAmount) {\n        Decimal memory decimalSpentIn = DecimalMath.fromNumber(spentInAmount);\n\n        // Calculate exit fee amount using DecimalMath\n        Decimal memory decimalExitFeeAmount = DecimalMath.mul(decimalSpentIn, exitFeeRatio);\n        exitFeeAmount = DecimalMath.floor(decimalExitFeeAmount);\n        remainingAmount = spentInAmount - exitFeeAmount;\n\n        return (exitFeeAmount, remainingAmount);\n    }\n\n    function syncPosition(\n        PositionTypes.Position memory position,\n        Decimal memory distIndex,\n        uint256 totalShares,\n        uint256 inSupply,\n        uint256 nowTime\n    ) internal pure returns (PositionTypes.Position memory) {\n        // Calculate index difference for distributions since last update\n        Decimal memory indexDiff = DecimalMath.sub(distIndex, position.index);\n        uint256 spent = 0;\n        uint256 purchased = 0;\n\n        // Only process if there are shares in the stream\n        if (position.shares > 0) {\n            // Calculate purchased amount based on position shares and index difference\n            Decimal memory positionSharesDecimal = DecimalMath.fromNumber(position.shares);\n            Decimal memory purchasedDecimal = DecimalMath.add(\n                DecimalMath.mul(positionSharesDecimal, indexDiff),\n                position.pendingReward\n            );\n            (purchased, purchasedDecimal) = DecimalMath.toNumber(purchasedDecimal);\n            position.purchased += purchased;\n            position.pendingReward = purchasedDecimal;\n\n            // Calculate remaining balance based on current shares ratio\n            uint256 inRemaining = (inSupply * position.shares) / totalShares;\n            // Calculate spent amount\n            spent = position.inBalance - inRemaining;\n            position.spentIn += spent;\n            position.inBalance = inRemaining;\n        }\n\n        // Update position tracking\n        position.index = distIndex;\n        position.lastUpdateTime = nowTime;\n\n        return position;\n    }\n}\n"
    },
    "src/lib/TransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title TransferLib\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Library for handling both ERC20 and native token transfers\n * @dev Provides a unified interface for token transfers, automatically detecting\n *      whether to use ERC20 transfers or native ETH transfers based on token address\n */\nlibrary TransferLib {\n    using SafeERC20 for IERC20;\n\n    /// @notice Native token address (zero address)\n    address public constant NATIVE_TOKEN = address(0);\n\n    // Deprecated helpers removed: transferFrom, transfer, balanceOf, allowance\n\n    /**\n     * @dev Pull funds into this contract. Supports native token and ERC20.\n     * @param token Token address (zero address for native token)\n     * @param payer Address that pays the funds (ignored for native token)\n     * @param amount Amount to pull\n     */\n    function pullFunds(\n        address token,\n        address payer,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (token == NATIVE_TOKEN) {\n            if (msg.value != amount) revert IncorrectNativeAmount(amount, msg.value);\n            // For native tokens, ETH is already transferred with this call\n            return;\n        }\n\n        // ERC20\n        IERC20(token).safeTransferFrom(payer, address(this), amount);\n    }\n\n    /**\n     * @dev Push funds from this contract to a recipient. Supports native token and ERC20.\n     * @param token Token address (zero address for native token)\n     * @param to Recipient address\n     * @param amount Amount to push\n     */\n    function pushFunds(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) return;\n\n        if (token == NATIVE_TOKEN) {\n            (bool success, ) = to.call{ value: amount }(\"\");\n            if (!success) revert NativeTokenTransferFailed();\n            return;\n        }\n\n        // ERC20\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    // ============ Errors ============\n\n    error NativeTokenTransferFailed();\n    error IncorrectNativeAmount(uint256 expected, uint256 actual);\n}\n"
    },
    "src/storage/PositionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title PositionStorage\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Secure, isolated storage for user participation data in StreamSwap streams\n * @dev PositionStorage implements a separation-of-concerns architecture where user data\n *      is isolated from stream logic for enhanced security and modularity. Each stream\n *      deploys its own PositionStorage instance, ensuring data isolation and preventing\n *      cross-stream interference.\n *      \n *      Security Features:\n *      - Single-stream access control: Only the deploying stream can modify data\n *      - Immutable stream address: Cannot be changed after deployment\n *      - Isolated storage: Each stream has its own position data\n *      - Comprehensive position tracking: Balances, shares, distributions, exit status\n *   \n */\n\nimport { PositionTypes } from \"../types/PositionTypes.sol\";\nimport { Decimal, DecimalMath } from \"../lib/math/DecimalMath.sol\";\n\ncontract PositionStorage {\n    using PositionTypes for PositionTypes.Position;\n\n    error UnauthorizedAccess();\n    error InvalidStreamContractAddress();\n\n    mapping(address => PositionTypes.Position) private positions;\n    address public immutable STREAM_CONTRACT_ADDRESS;\n\n    constructor(address contractAddress) {\n        if (contractAddress == address(0)) revert InvalidStreamContractAddress();\n        STREAM_CONTRACT_ADDRESS = contractAddress;\n    }\n\n    function getPosition(address owner) external view returns (PositionTypes.Position memory) {\n        return positions[owner];\n    }\n\n    modifier onlyStreamContract() {\n        if (msg.sender != STREAM_CONTRACT_ADDRESS) revert UnauthorizedAccess();\n        _;\n    }\n\n    function createPosition(\n        address owner,\n        uint256 inBalance,\n        uint256 shares,\n        Decimal memory index\n    ) external onlyStreamContract {\n        positions[owner] = PositionTypes.Position(\n            inBalance,\n            shares,\n            index,\n            block.timestamp,\n            DecimalMath.fromNumber(0),\n            0,\n            0,\n            0\n        );\n    }\n\n    function updatePosition(address owner, PositionTypes.Position memory position) external onlyStreamContract {\n        positions[owner] = position;\n    }\n\n    function setExitDate(address owner, uint256 exitDate) external onlyStreamContract {\n        positions[owner].exitDate = exitDate;\n    }\n}\n"
    },
    "src/Stream.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title Stream\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Core streaming contract implementing time-based token distribution with dynamic pricing\n * @dev StreamSwap enables continuous token swaps where price is determined by community participation\n *      over time. Unlike traditional ICOs or Dutch auctions, StreamSwap uses a streaming mechanism\n *      where tokens are distributed continuously based on subscription timing and amounts.\n *      \n *      Key Features:\n *      - Dynamic pricing based on total participation and time\n *      - Threshold mechanism to ensure minimum viable participation\n *      - Bootstrapping phase for early commitment without immediate distribution\n *      - Proportional withdrawal and exit mechanisms\n *      - Post-stream vesting and automated liquidity pool creation\n *      - Emergency controls for creator and protocol admin\n *      \n *      Stream Lifecycle:\n *      1. Waiting: Stream created, no interactions allowed\n *      2. Bootstrapping: Users can subscribe, no distribution yet\n *      3. Active: Live streaming with continuous token distribution\n *      4. Ended: Stream concluded, users can exit, creator can finalize\n *      5. FinalizedStreamed: Stream finalized and streamed\n *      6. FinalizedRefunded: Stream finalized and refunded\n *      7. Cancelled: Emergency state, full refunds available\n */\n\n\nimport { PositionTypes } from \"./types/PositionTypes.sol\";\nimport { IPositionStorage } from \"./interfaces/IPositionStorage.sol\";\nimport { IStreamEvents } from \"./interfaces/IStreamEvents.sol\";\nimport { IStreamErrors } from \"./interfaces/IStreamErrors.sol\";\nimport { StreamTypes } from \"./types/StreamTypes.sol\";\nimport { StreamFactory } from \"./StreamFactory.sol\";\nimport { StreamFactoryTypes } from \"./types/StreamFactoryTypes.sol\";\nimport { DecimalMath, Decimal } from \"./lib/math/DecimalMath.sol\";\nimport { StreamMathLib } from \"./lib/math/StreamMathLib.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IPoolWrapper } from \"./interfaces/IPoolWrapper.sol\";\nimport { IVestingFactory } from \"./interfaces/IVestingFactory.sol\";\nimport { PoolWrapperTypes } from \"./types/PoolWrapperTypes.sol\";\nimport { IPermit2 } from \"./interfaces/IPermit2.sol\";\nimport { TransferLib } from \"./lib/TransferLib.sol\";\n\n    \n/**\n * @title Stream\n * @dev Main contract for managing token streaming with vesting and pool creation capabilities\n * @notice This contract handles the core streaming logic including subscriptions, withdrawals, exits, and finalization\n */\ncontract Stream is IStreamErrors, IStreamEvents {\n\n    // ============ State Variables ============\n\n    /// @notice Address of the stream creator\n    address public creator;\n\n    /// @notice Immutable address of the stream factory that deployed this stream\n    address public immutable STREAM_FACTORY_ADDRESS;\n\n    /// @notice Address of the position storage contract\n    address public positionStorageAddress;\n\n    /// @notice Flag to ensure initialization happens only once\n    bool private initialized;\n\n    /// @notice Current state of the stream (distribution index, remaining tokens, etc.)\n    StreamTypes.StreamState public streamState;\n\n    /// @notice Token addresses for input and output tokens\n    StreamTypes.StreamTokens public streamTokens;\n\n    /// @notice Metadata associated with the stream\n    StreamTypes.StreamMetadata public streamMetadata;\n\n    /// @notice Current status of the stream (Waiting, Bootstrapping, Active, etc.)\n    StreamTypes.Status public streamStatus;\n\n    /// @notice Timing information for the stream phases\n    StreamTypes.StreamTimes public streamTimes;\n\n    /// @notice Post-stream actions like vesting and pool creation\n    StreamTypes.PostStreamActions public postStreamActions;\n\n    /// @notice Address of the Permit2 contract\n    address public constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    // ============ Modifiers ============\n\n    /**\n     * @dev Ensures the function can only be called once during initialization\n     */\n    modifier onlyOnce() {\n        if (initialized) revert Unauthorized();\n        _;\n        initialized = true;\n    }\n\n    /**\n     * @dev Ensures only the stream factory can call the function\n     */\n    modifier onlyStreamFactory() {\n        if (msg.sender != STREAM_FACTORY_ADDRESS) revert Unauthorized();\n        _;\n    }\n\n    /**\n     * @dev Ensures only the stream creator can call the function\n     */\n    modifier onlyCreator() {\n        if (msg.sender != creator) revert Unauthorized();\n        _;\n    }\n\n    /**\n     * @dev Ensures only the protocol admin can call the function\n     */\n    modifier onlyProtocolAdmin() {\n        StreamFactory factoryContract = StreamFactory(STREAM_FACTORY_ADDRESS);\n        address protocolAdmin = factoryContract.getParams().protocolAdmin;\n        if (msg.sender != protocolAdmin) revert Unauthorized();\n        _;\n    }\n\n    // ============ Constructor ============\n\n    /**\n     * @dev Constructor to set the stream factory address\n     * @param factoryAddress Address of the stream factory\n     */\n    constructor(address factoryAddress) {\n        if (factoryAddress == address(0)) revert InvalidStreamFactoryAddress();\n        STREAM_FACTORY_ADDRESS = factoryAddress;\n    }\n\n    // ============ Initialization ============\n\n    /**\n     * @dev Initializes the stream with the provided configuration\n     * @param createStreamMessage Stream creation parameters\n     * @param storageAddress Address of the position storage contract\n     * @notice This function can only be called once by the stream factory\n     */\n    function initialize(\n        StreamTypes.CreateStreamMessage memory createStreamMessage,\n        address storageAddress\n    ) external onlyOnce onlyStreamFactory {\n        if (storageAddress == address(0)) revert InvalidPositionStorageAddress();\n\n        // Validate and set creator vesting info\n        if (createStreamMessage.creatorVesting.isVestingEnabled) {\n            postStreamActions.creatorVesting = createStreamMessage.creatorVesting;\n        }\n        \n        // Validate and set beneficiary vesting info\n        if (createStreamMessage.beneficiaryVesting.isVestingEnabled) {\n            postStreamActions.beneficiaryVesting = createStreamMessage.beneficiaryVesting;\n        }\n        \n        // Validate pool config\n        if (createStreamMessage.poolInfo.poolOutSupplyAmount > 0) {\n            // Validate pool amount is less than or equal to out amount\n            if (createStreamMessage.poolInfo.poolOutSupplyAmount > createStreamMessage.streamOutAmount) {\n                revert InvalidPoolOutSupplyAmount();\n            }\n            postStreamActions.poolInfo = createStreamMessage.poolInfo;\n        }\n        \n        // Save position storage address\n        positionStorageAddress = storageAddress;\n        \n        // Set creator\n        creator = createStreamMessage.creator;\n        \n        // Initialize stream state\n        streamState = StreamTypes.StreamState({\n            distIndex: DecimalMath.fromNumber(0),\n            outRemaining: createStreamMessage.streamOutAmount,\n            inSupply: 0,\n            spentIn: 0,\n            shares: 0,\n            currentStreamedPrice: DecimalMath.fromNumber(0),\n            threshold: createStreamMessage.threshold,\n            outSupply: createStreamMessage.streamOutAmount,\n            lastUpdated: block.timestamp\n        });\n        \n        // Initialize stream tokens\n        streamTokens = StreamTypes.StreamTokens({\n            inSupplyToken: createStreamMessage.inSupplyToken,\n            outSupplyToken: createStreamMessage.outSupplyToken\n        });\n        \n        // Initialize stream metadata\n        streamMetadata = createStreamMessage.metadata;\n        \n        // Initialize stream status\n        streamStatus = StreamTypes.Status.Waiting;\n        \n        // Initialize stream times\n        streamTimes = StreamTypes.StreamTimes({\n            bootstrappingStartTime: createStreamMessage.bootstrappingStartTime,\n            streamStartTime: createStreamMessage.streamStartTime,\n            streamEndTime: createStreamMessage.streamEndTime\n        });\n    }\n\n    // ============ Core Stream Functions ============\n\n    /**\n     * @dev Internal function containing the core subscription logic\n     *      Assumes `amountIn` tokens have already been transferred to this contract.\n     * @param amountIn Amount of input tokens to subscribe with\n     * @notice Business logic for updating positions and stream state.\n     */\n    function _subscribeCore(uint256 amountIn) internal {\n        if (amountIn == 0) revert InvalidAmount();\n\n        // Load and validate stream state\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Validate operation is allowed\n        if (status != StreamTypes.Status.Bootstrapping && status != StreamTypes.Status.Active) {\n            revert OperationNotAllowed();\n        }\n\n        // Load and sync stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        // Load and sync position\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // Calculate shares before any state changes\n        uint256 newShares = StreamMathLib.computeSharesAmount(amountIn, false, state.inSupply, state.shares);\n\n        // Update position\n        position.inBalance += amountIn;\n        position.shares += newShares;\n\n        // Update stream state\n        state.inSupply += amountIn;\n        state.shares += newShares;\n\n        // Save all states\n        saveStreamStatus(status);\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        emit Subscribed(\n            address(this),\n            msg.sender,\n            position.inBalance,\n            newShares,\n            position.lastUpdateTime,\n            position.spentIn,\n            position.purchased,\n            position.index.value,\n            state.inSupply,\n            state.shares\n        );\n    }\n\n    /**\n     * @dev Allows users to subscribe to the stream by providing input tokens\n     * @param amountIn Amount of input tokens to subscribe with\n     * @notice Users can subscribe during Bootstrapping or Active phases\n     */\n    function subscribe(uint256 amountIn) external {\n        if (streamTokens.inSupplyToken == address(0)) revert InvalidInputToken();\n        // Pull funds (ERC20)\n        TransferLib.pullFunds(streamTokens.inSupplyToken, msg.sender, amountIn);\n        _subscribeCore(amountIn);\n    }\n\n    function subscribeWithNativeToken(uint256 amountIn) external payable {\n        if (streamTokens.inSupplyToken != address(0)) revert InvalidInputToken();\n        // Pull funds (native)\n        TransferLib.pullFunds(address(0), msg.sender, amountIn);\n        _subscribeCore(amountIn);\n    }\n\n    /**\n     * @dev Allows users to subscribe using Permit2 signature-based allowance.\n     *      The Permit2 signature (PermitSingle) is verified and consumed, then the\n     *      tokens are pulled from `owner` to this Stream contract. The rest of the\n     *      logic mirrors the regular `subscribe` flow.\n     * @param amountIn      Amount of input tokens user wants to contribute\n     * @param owner         Address that actually holds the tokens (signer of permit)\n     * @param permitSingle  Full Permit2 data struct describing the allowance\n     * @param signature     EIP-712 signature over `permitSingle`\n     */\n    function subscribeWithPermit(\n        uint256 amountIn,\n        address owner,\n        IPermit2.PermitSingle calldata permitSingle,\n        bytes calldata signature\n    ) external {\n        // Validate the permit matches the stream requirements\n        if (permitSingle.details.token != streamTokens.inSupplyToken) revert InvalidAmount();\n        if (permitSingle.details.amount < uint160(amountIn)) revert InvalidAmount();\n        if (permitSingle.spender != address(this)) revert InvalidAmount();\n        if (permitSingle.sigDeadline < block.timestamp) revert InvalidAmount();\n\n        // Execute Permit2 flow\n        IPermit2 permit2 = IPermit2(PERMIT2);\n        // 1. Validate & store allowance via signature\n        permit2.permit(owner, permitSingle, signature);\n        // 2. Pull tokens from owner to the stream contract\n        permit2.transferFrom(owner, address(this), uint160(amountIn), streamTokens.inSupplyToken);\n\n        // Tokens are now in this contract  proceed with core logic\n        _subscribeCore(amountIn);\n    }\n\n    /**\n     * @dev Allows users to withdraw their input tokens from the stream\n     * @param cap Amount of input tokens to withdraw\n     * @notice Users can withdraw during Active or Bootstrapping phases\n     * @dev If cap is 0, the user will withdraw all their input tokens\n     */\n    function withdraw(uint256 cap) external {\n        // Load position once\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n\n        // Validate position\n        validatePosition(position, msg.sender);\n\n        // load stream times\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (status != StreamTypes.Status.Active && status != StreamTypes.Status.Bootstrapping) {\n            revert OperationNotAllowed();\n        }\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        // Sync position with the updated state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // If cap is 0, withdraw all available balance\n        uint256 withdrawAmount = (cap == 0) ? position.inBalance : cap;\n\n        // Check if withdrawal amount exceeds position balance\n        if (withdrawAmount > position.inBalance) revert WithdrawAmountExceedsBalance(withdrawAmount);\n\n        uint256 shareDeduction = 0;\n\n        if (withdrawAmount == position.inBalance) {\n            shareDeduction = position.shares;\n        } else {\n            shareDeduction = StreamMathLib.computeSharesAmount(withdrawAmount, true, state.inSupply, state.shares);\n        }\n\n        // Update position\n        position.shares = position.shares - shareDeduction;\n        position.inBalance = position.inBalance - withdrawAmount;\n\n        // Update stream state\n        state.inSupply = state.inSupply - withdrawAmount;\n        state.shares = state.shares - shareDeduction;\n\n        // Save all states first\n        saveStreamStatus(status);\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        // Emit events\n        emit Withdrawn(\n            address(this),\n            msg.sender,\n            position.inBalance,\n            position.shares,\n            position.lastUpdateTime,\n            position.spentIn,\n            position.purchased,\n            position.index.value,\n            state.inSupply,\n            state.shares\n        );\n\n        // Transfer tokens\n        TransferLib.pushFunds(streamTokens.inSupplyToken, msg.sender, withdrawAmount);\n    }\n\n    /**\n     * @dev Allows users to exit the stream and receive their tokens based on stream outcome\n     * @notice Users can exit after the stream has ended or been cancelled\n     */\n    function exitStream() external {\n        // Load and validate position\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n        if (position.exitDate != 0) revert InvalidPosition(msg.sender, position.shares, position.exitDate, \"Position has already exited\");\n\n        // Load and sync stream state\n        StreamTypes.StreamState memory state = syncStream(loadStream());\n\n        // Sync position with updated stream state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // Load and sync stream status\n        StreamTypes.Status status = syncStreamStatus(loadStreamStatus(), loadStreamTimes(), block.timestamp);\n\n        // Store values for distribution before changing state\n        uint256 inBalance = position.inBalance;\n        uint256 purchased = position.purchased;\n        uint256 spentIn = position.spentIn;\n        position.exitDate = block.timestamp;\n\n        // Save updated state before making external calls\n        saveStreamStatus(status);\n        saveStream(state);\n        savePosition(msg.sender, position);\n        \n\n        // Determine outcome\n        bool thresholdReached = (state.spentIn >= state.threshold);\n        bool isSuccess = (status == StreamTypes.Status.FinalizedStreamed ||\n            (status == StreamTypes.Status.Ended && thresholdReached));\n        bool isRefund = (status == StreamTypes.Status.FinalizedRefunded ||\n            status == StreamTypes.Status.Cancelled ||\n            (status == StreamTypes.Status.Ended && !thresholdReached));\n\n        if (isSuccess) {\n            // Case 1: Successful exit - return unused input tokens and deliver output\n            // This case is highly unlikely to happen because the stream is designed to spend all input tokens if stream is ended\n            if (inBalance > 0) {\n                TransferLib.pushFunds(streamTokens.inSupplyToken, msg.sender, inBalance);\n            }\n\n            if (postStreamActions.beneficiaryVesting.isVestingEnabled) {\n                StreamFactory factoryContract = StreamFactory(STREAM_FACTORY_ADDRESS);\n                StreamFactoryTypes.Params memory params = factoryContract.getParams();\n                IVestingFactory vestingFactory = IVestingFactory(params.vestingFactoryAddress);\n\n                IERC20(streamTokens.outSupplyToken).approve(params.vestingFactoryAddress, purchased);\n                vestingFactory.createVestingWalletWithTokens(\n                    msg.sender,\n                    uint64(block.timestamp),\n                    postStreamActions.beneficiaryVesting.vestingDuration,\n                    streamTokens.outSupplyToken,\n                    purchased\n                );\n            } else {\n                TransferLib.pushFunds(streamTokens.outSupplyToken, msg.sender, purchased);\n            }\n\n            emit ExitStreamed(address(this), msg.sender, purchased, spentIn, position.index.value, inBalance, block.timestamp);\n        } else if (isRefund) {\n            // Case 2: Refund exit - return all input tokens\n            uint256 totalRefund = inBalance + spentIn;\n            position.purchased = 0;\n            position.spentIn = 0;\n            position.inBalance = totalRefund;\n            savePosition(msg.sender, position);\n            TransferLib.pushFunds(streamTokens.inSupplyToken, msg.sender, totalRefund);\n            emit ExitRefunded(address(this), msg.sender, position.inBalance, position.spentIn, block.timestamp);\n        } else {\n            // Case 3: No exit allowed\n            revert OperationNotAllowed();\n        }\n      \n    }\n\n    // ============ Stream Management Functions ============\n\n    /**\n     * @dev Allows the creator to finalize the stream after it has ended\n     * @notice Only the creator can call this function when stream status is Ended\n     */\n    function finalizeStream() external onlyCreator {\n        // Get factory params\n        StreamFactory factoryContract = StreamFactory(STREAM_FACTORY_ADDRESS);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (status != StreamTypes.Status.Ended) {\n            revert OperationNotAllowed();\n        }\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        bool thresholdReached = state.spentIn >= state.threshold;\n\n        // Store values needed for distribution before state changes\n        uint256 outRemaining = state.outRemaining;\n        uint256 outSupply = state.outSupply;\n        uint256 spentIn = state.spentIn;\n\n        if (thresholdReached) {\n            address feeCollector = params.feeCollector;\n            Decimal memory exitFeeRatio = params.exitFeeRatio;\n\n            // Calculate exit fee\n            (uint256 feeAmount, uint256 creatorRevenue) = StreamMathLib.calculateExitFee(spentIn, exitFeeRatio);\n\n            // Handle pool creation if configured\n            uint256 poolInSupplyAmount = 0;\n            uint256 poolOutSupplyAmount = 0;\n            if (postStreamActions.poolInfo.poolOutSupplyAmount > 0) {\n                // Calculate pool ratio\n                Decimal memory poolRatio = DecimalMath.div(\n                    DecimalMath.fromNumber(postStreamActions.poolInfo.poolOutSupplyAmount),\n                    DecimalMath.fromNumber(streamState.outSupply)\n                );\n\n                Decimal memory decimalCreatorRevenue = DecimalMath.fromNumber(creatorRevenue);\n                Decimal memory decimalPoolAmount = DecimalMath.mul(decimalCreatorRevenue, poolRatio);\n\n                poolInSupplyAmount = DecimalMath.floor(decimalPoolAmount);\n                poolOutSupplyAmount = postStreamActions.poolInfo.poolOutSupplyAmount;\n                // Calculate remaining revenue\n                creatorRevenue = creatorRevenue - poolInSupplyAmount;\n            }\n\n            // Update status\n            status = StreamTypes.Status.FinalizedStreamed;\n            saveStreamStatus(status);\n            saveStream(state);\n\n            // Emit event before external calls\n            emit FinalizedStreamed(address(this), creator, creatorRevenue, feeAmount, outRemaining);\n\n            // External calls last\n            TransferLib.pushFunds(streamTokens.inSupplyToken, feeCollector, feeAmount);\n\n            if (poolOutSupplyAmount > 0) {\n                createPoolAndAddLiquidity(\n                    streamTokens.inSupplyToken,\n                    streamTokens.outSupplyToken,\n                    poolInSupplyAmount,\n                    poolOutSupplyAmount\n                );\n            }\n\n            if (postStreamActions.creatorVesting.isVestingEnabled) {\n                IVestingFactory vestingFactory = IVestingFactory(params.vestingFactoryAddress);\n                IERC20(streamTokens.inSupplyToken).approve(params.vestingFactoryAddress, creatorRevenue);\n                vestingFactory.createVestingWalletWithTokens(\n                    creator,\n                    uint64(block.timestamp),\n                    postStreamActions.creatorVesting.vestingDuration,\n                    streamTokens.inSupplyToken,\n                    creatorRevenue\n                );\n            } else {\n                TransferLib.pushFunds(streamTokens.inSupplyToken, creator, creatorRevenue);\n            }\n\n            if (outRemaining > 0) {\n                TransferLib.pushFunds(streamTokens.outSupplyToken, creator, outRemaining);\n            }\n        } else {\n            // Update status\n            status = StreamTypes.Status.FinalizedRefunded;\n            saveStreamStatus(status);\n            saveStream(state);\n\n            // Emit event before external call\n            emit FinalizedRefunded(address(this), creator, outSupply);\n\n            // External call last\n            TransferLib.pushFunds(streamTokens.outSupplyToken, creator, outSupply);\n        }\n    }\n\n    /**\n     * @dev Allows the creator to cancel the stream during the Waiting phase\n     * @notice Only the creator can cancel during Waiting phase\n     */\n    function cancelStream() external onlyCreator {\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (status != StreamTypes.Status.Waiting) {\n            revert OperationNotAllowed();\n        }\n\n        // Store amount to transfer before updating state\n        uint256 amountToTransfer = streamState.outSupply;\n\n        // Update status\n        status = StreamTypes.Status.Cancelled;\n        saveStreamStatus(status);\n\n        emit StreamCancelled(address(this), creator, amountToTransfer, uint8(status));\n        TransferLib.pushFunds(streamTokens.outSupplyToken, creator, amountToTransfer);\n    }\n\n    /**\n     * @dev Allows the protocol admin to cancel the stream during Waiting, Bootstrapping, or Active phases\n     * @notice Only the protocol admin can call this function\n     */\n    function cancelWithAdmin() external onlyProtocolAdmin {\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        if (\n            status != StreamTypes.Status.Waiting &&\n            status != StreamTypes.Status.Bootstrapping &&\n            status != StreamTypes.Status.Active\n        ) {\n            revert OperationNotAllowed();\n        }\n\n        // Store amount to transfer before updating state\n        uint256 amountToTransfer = streamState.outSupply;\n\n        // Update status\n        status = StreamTypes.Status.Cancelled;\n        saveStreamStatus(status);\n\n        emit StreamCancelled(address(this), creator, amountToTransfer, uint8(status));\n\n        // External call last\n        TransferLib.pushFunds(streamTokens.outSupplyToken, creator, amountToTransfer);\n    }\n\n    /**\n     * @dev Allows the creator to update the stream metadata\n     * @notice Only the creator can call this function\n     */\n    function updateStreamMetadata(string memory metadataIpfsHash) external onlyCreator {\n        streamMetadata.ipfsHash = metadataIpfsHash;\n        emit StreamMetadataUpdated(address(this), metadataIpfsHash);\n    }\n\n    // ============ External Sync Functions ============\n\n    /**\n     * @dev External function to sync the stream state and status\n     * @notice Anyone can call this to update the stream state based on current time\n     */\n    function syncStreamExternal() external {\n        // Load, update and save stream state\n        StreamTypes.StreamState memory state = loadStream();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        state = syncStream(state);\n        saveStream(state);\n\n        // Load, update and save status\n        StreamTypes.Status status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n        saveStreamStatus(status);\n\n        emit StreamSynced(\n            address(this),\n            state.lastUpdated,\n            uint8(status),\n            state.distIndex.value,\n            state.outRemaining,\n            state.inSupply,\n            state.spentIn,\n            state.currentStreamedPrice.value\n        );\n    }\n\n    /**\n     * @dev External function to sync a specific user's position\n     * @param user Address of the user whose position should be synced\n     * @notice Anyone can call this to update a user's position based on current stream state\n     */\n    function syncPositionExternal(address user) external {\n        PositionTypes.Position memory position = loadPosition(user);\n        validatePosition(position, user);\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n        savePosition(user, position);\n        saveStream(state);\n        emit PositionSynced(\n            address(this),\n            user,\n            position.inBalance,\n            position.shares,\n            position.lastUpdateTime,\n            position.spentIn,\n            position.purchased,\n            position.index.value\n        );\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @dev Get the current stream status\n     * @return The current stream status\n     */\n    function getStreamStatus() external view returns (StreamTypes.Status) {\n        return streamStatus;\n    }\n\n    /**\n     * @dev Get the current stream state\n     * @return The current stream state\n     */\n    function getStreamState() external view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    /**\n     * @dev Get a user's position information\n     * @param user Address of the user\n     * @return The user's position\n     */\n    function getPosition(address user) external view returns (PositionTypes.Position memory) {\n        IPositionStorage positionStorage = IPositionStorage(positionStorageAddress);\n        return positionStorage.getPosition(user);\n    }\n\n    // ============ Internal Helper Functions ============\n\n    // ============ State Management ============\n\n    /**\n     * @dev Synchronizes the stream state based on the current timestamp\n     * @param state The current stream state to update\n     * @return The updated stream state\n     */\n    function syncStream(StreamTypes.StreamState memory state) internal returns (StreamTypes.StreamState memory) {\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        Decimal memory diff = StreamMathLib.calculateDiff(\n            block.timestamp,\n            times.streamStartTime,\n            times.streamEndTime,\n            state.lastUpdated\n        );\n\n        if (diff.value == 0) {\n            state.lastUpdated = block.timestamp;\n            return state;\n        }\n\n        state = StreamMathLib.calculateUpdatedState(state, diff);\n        state.lastUpdated = block.timestamp;\n\n        emit StreamStateUpdated(\n            address(this),\n            state.lastUpdated,\n            state.distIndex.value,\n            state.outRemaining,\n            state.inSupply,\n            state.spentIn,\n            state.currentStreamedPrice.value\n        );\n\n        return state;\n    }\n\n    /**\n     * @dev Syncs the stream status based on current time and stream times\n     * @param status Current stream status\n     * @param times Stream timing information\n     * @param nowTime Current timestamp\n     * @return Updated stream status\n     */\n    function syncStreamStatus(\n        StreamTypes.Status status,\n        StreamTypes.StreamTimes memory times,\n        uint256 nowTime\n    ) internal pure returns (StreamTypes.Status) {\n        status = StreamMathLib.calculateStreamStatus(\n            status,\n            nowTime,\n            times.bootstrappingStartTime,\n            times.streamStartTime,\n            times.streamEndTime\n        );\n\n        return status;\n    }\n\n    // ============ Load Functions ============\n\n    /**\n     * @dev Loads the current stream state\n     * @return Current stream state\n     */\n    function loadStream() internal view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    /**\n     * @dev Loads the current stream status\n     * @return Current stream status\n     */\n    function loadStreamStatus() internal view returns (StreamTypes.Status) {\n        return streamStatus;\n    }\n\n    /**\n     * @dev Loads a user's position from storage\n     * @param user Address of the user\n     * @return User's position\n     */\n    function loadPosition(address user) internal view returns (PositionTypes.Position memory) {\n        IPositionStorage positionStorage = IPositionStorage(positionStorageAddress);\n        return positionStorage.getPosition(user);\n    }\n\n    /**\n     * @dev Loads the stream timing information\n     * @return Stream timing information\n     */\n    function loadStreamTimes() internal view returns (StreamTypes.StreamTimes memory) {\n        return streamTimes;\n    }\n\n    // ============ Save Functions ============\n\n    /**\n     * @dev Saves the stream state\n     * @param state Stream state to save\n     */\n    function saveStream(StreamTypes.StreamState memory state) internal {\n        streamState = state;\n    }\n\n    /**\n     * @dev Saves the stream status\n     * @param status Stream status to save\n     */\n    function saveStreamStatus(StreamTypes.Status status) internal {\n        streamStatus = status;\n    }\n\n    /**\n     * @dev Saves a user's position to storage\n     * @param user Address of the user\n     * @param position Position to save\n     */\n    function savePosition(address user, PositionTypes.Position memory position) internal {\n        IPositionStorage positionStorage = IPositionStorage(positionStorageAddress);\n        positionStorage.updatePosition(user, position);\n    }\n\n    // ============ Validation Functions ============\n\n    /**\n     * @dev Validates a position and reverts if invalid\n     * @param position The position to validate\n     * @param user The address of the user whose position is being validated\n     * @custom:error InvalidPosition if position is invalid or inactive\n     */\n    function validatePosition(PositionTypes.Position memory position, address user) internal pure {\n        if (position.shares == 0) {\n            revert InvalidPosition(user, position.shares, position.exitDate, \"Position has no shares\");\n        }\n        if (position.exitDate != 0) {\n            revert InvalidPosition(user, position.shares, position.exitDate, \"Position has already exited\");\n        }\n    }\n\n    // ============ Pool Management ============\n\n    /**\n     * @dev Creates a pool and adds liquidity using the pool wrapper\n     * @param tokenA First token address\n     * @param tokenB Second token address\n     * @param amountADesired Amount of token A to add\n     * @param amountBDesired Amount of token B to add\n     */\n    function createPoolAndAddLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    ) internal {\n        StreamFactory factoryContract = StreamFactory(STREAM_FACTORY_ADDRESS);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n\n        address poolWrapperAddress = params.poolWrapperAddress;\n        IPoolWrapper poolWrapper = IPoolWrapper(poolWrapperAddress);\n\n        // Transfer pool tokens to the pool wrapper contract first\n        TransferLib.pushFunds(tokenA, poolWrapperAddress, amountADesired);\n        TransferLib.pushFunds(tokenB, poolWrapperAddress, amountBDesired);\n\n        PoolWrapperTypes.CreatePoolMsg memory createPoolMsg = PoolWrapperTypes.CreatePoolMsg({\n            token0: tokenA,\n            token1: tokenB,\n            amount0: amountADesired,\n            amount1: amountBDesired\n        });\n        \n        // Now, call createPool\n        poolWrapper.createPool(createPoolMsg);\n    }\n}\n"
    },
    "src/StreamFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title StreamFactory\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Central factory managing StreamSwap protocol operations and stream creation\n * @dev The StreamFactory serves as the protocol's control center, handling stream creation,\n *      parameter management, and protocol governance. It uses minimal proxy clones for\n *      gas-efficient stream deployment and maintains protocol-wide configurations.\n *      \n *      Core Responsibilities:\n *      - Stream Creation: Deploy new streams with validation and fee collection\n *      - Protocol Parameters: Manage fees, durations, and accepted tokens\n *      - Access Control: Admin functions for protocol governance\n *      - Emergency Powers: Freeze stream creation and cancel active streams\n *      - Integration Management: Deploy and coordinate with VestingFactory\n */\nimport { IStreamEvents } from \"./interfaces/IStreamEvents.sol\";\nimport { IStreamFactoryErrors } from \"./interfaces/IStreamFactoryErrors.sol\";\nimport { VestingFactory } from \"./VestingFactory.sol\";\nimport { StreamTypes } from \"./types/StreamTypes.sol\";\nimport { IStream } from \"./interfaces/IStream.sol\";\nimport { StreamFactoryTypes } from \"./types/StreamFactoryTypes.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { TransferLib } from \"./lib/TransferLib.sol\";\nimport { PositionStorage } from \"./storage/PositionStorage.sol\";\nimport { DecimalMath, Decimal } from \"./lib/math/DecimalMath.sol\";\n\n/**\n * @title StreamFactory\n * @dev Factory contract for creating and managing token streams\n * @notice Handles stream creation, parameter management, and accepted token management\n */\ncontract StreamFactory is IStreamEvents, IStreamFactoryErrors {\n    using TransferLib for address;\n\n    // ============ State Variables ============\n\n    /// @notice Mapping of accepted input supply tokens\n    mapping(address => bool) public acceptedInSupplyTokens;\n\n    /// @notice Current stream ID counter\n    uint16 public currentStreamId;\n\n    /// @notice Factory parameters\n    StreamFactoryTypes.Params public params;\n\n    /// @notice Mapping of stream ID to stream address\n    mapping(uint16 => address) public streamAddresses;\n\n    /// @notice Flag to freeze stream creation\n    bool public frozen;\n\n    /// @notice Flag to ensure initialization happens only once\n    bool public initialized;\n\n    // ============ Modifiers ============\n\n    /**\n     * @dev Ensures the function can only be called once during initialization\n     */\n    modifier onlyOnce() {\n        if (initialized) revert AlreadyInitialized();\n        _;\n        initialized = true;\n    }\n\n    /**\n     * @dev Ensures only the protocol admin can call the function\n     */\n    modifier onlyAdmin() {\n        if (msg.sender != params.protocolAdmin) revert NotAdmin();\n        _;\n    }\n\n    // ============ Constructor ============\n\n    /**\n     * @dev Constructor to set the protocol admin\n     * @param protocolAdmin Address of the protocol admin\n     */\n    constructor(address protocolAdmin) {\n        if (protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        params.protocolAdmin = protocolAdmin;\n    }\n\n    // ============ Initialization ============\n\n    /**\n     * @dev Initializes the factory with the provided configuration\n     * @param initializeStreamMessage Factory initialization parameters\n     * @notice This function can only be called once by the admin\n     */\n    function initialize(\n        StreamFactoryTypes.InitializeStreamMessage memory initializeStreamMessage\n    ) external onlyAdmin onlyOnce {\n        if (DecimalMath.gt(initializeStreamMessage.exitFeeRatio, DecimalMath.fromNumber(1)))\n            revert InvalidExitFeeRatio();\n\n        if (initializeStreamMessage.acceptedInSupplyTokens.length == 0) revert InvalidAcceptedInSupplyTokens();\n\n        // Allow zero address for native token support\n        // if (initializeStreamMessage.streamCreationFeeToken == address(0)) revert InvalidStreamCreationFeeToken();\n\n        if (initializeStreamMessage.streamImplementationAddress == address(0))\n            revert InvalidStreamImplementationAddress();\n\n        if (initializeStreamMessage.poolWrapperAddress == address(0)) revert InvalidPoolWrapper();\n\n        // Deploy vesting factory\n        VestingFactory vestingFactory = new VestingFactory();\n        emit VestingContractDeployed(address(this), address(vestingFactory));\n\n        // Set factory parameters\n        params.streamCreationFee = initializeStreamMessage.streamCreationFee;\n        params.streamCreationFeeToken = initializeStreamMessage.streamCreationFeeToken;\n        params.exitFeeRatio = initializeStreamMessage.exitFeeRatio;\n        params.minWaitingDuration = initializeStreamMessage.minWaitingDuration;\n        params.minBootstrappingDuration = initializeStreamMessage.minBootstrappingDuration;\n        params.minStreamDuration = initializeStreamMessage.minStreamDuration;\n        params.feeCollector = initializeStreamMessage.feeCollector;\n        params.tosVersion = initializeStreamMessage.tosVersion;\n        params.vestingFactoryAddress = address(vestingFactory);\n        params.poolWrapperAddress = initializeStreamMessage.poolWrapperAddress;\n        params.streamImplementationAddress = initializeStreamMessage.streamImplementationAddress;\n\n        // Set accepted tokens (including zero address for native token)\n        for (uint256 i = 0; i < initializeStreamMessage.acceptedInSupplyTokens.length; i++) {\n            // Allow zero address for native token support\n            // if (initializeStreamMessage.acceptedInSupplyTokens[i] == address(0)) revert InvalidAcceptedInSupplyTokens();\n            acceptedInSupplyTokens[initializeStreamMessage.acceptedInSupplyTokens[i]] = true;\n        }\n\n        emit FactoryInitialized(\n            address(this),\n            initializeStreamMessage.streamImplementationAddress,\n            initializeStreamMessage.poolWrapperAddress,\n            initializeStreamMessage.feeCollector,\n            initializeStreamMessage.protocolAdmin,\n            initializeStreamMessage.streamCreationFeeToken,\n            initializeStreamMessage.acceptedInSupplyTokens,\n            initializeStreamMessage.streamCreationFee,\n            initializeStreamMessage.exitFeeRatio.value,\n            initializeStreamMessage.minWaitingDuration,\n            initializeStreamMessage.minBootstrappingDuration,\n            initializeStreamMessage.minStreamDuration,\n            initializeStreamMessage.tosVersion,\n            address(vestingFactory)\n        );\n    }\n\n    // ============ Stream Creation ============\n\n    /**\n     * @dev Creates a new stream with the provided configuration\n     * @param createStreamMessage Stream creation parameters\n     * @notice Anyone can create a stream if they provide the required tokens and fees\n     */\n    function createStream(StreamTypes.CreateStreamMessage memory createStreamMessage) external payable {\n        // Check if contract is accepting new streams (not frozen)\n        if (frozen) revert ContractFrozen();\n\n        // Validate input parameters\n        if (createStreamMessage.streamOutAmount == 0) revert ZeroOutSupplyNotAllowed();\n        if (createStreamMessage.outSupplyToken == address(0)) revert InvalidOutSupplyToken();\n        if (createStreamMessage.creator == address(0)) revert InvalidCreator();\n        if (!acceptedInSupplyTokens[createStreamMessage.inSupplyToken]) revert StreamInputTokenNotAccepted();\n        if (createStreamMessage.inSupplyToken == createStreamMessage.outSupplyToken) revert SameInputAndOutputToken();\n    \n\n        // Validate vesting configurations\n        validateVesting(createStreamMessage.creatorVesting);\n        validateVesting(createStreamMessage.beneficiaryVesting);\n\n        // Validate time parameters\n        validateStreamTimes(\n            block.timestamp,\n            createStreamMessage.bootstrappingStartTime,\n            createStreamMessage.streamStartTime,\n            createStreamMessage.streamEndTime\n        );\n\n        // Validate TOS version\n        if (\n            keccak256(abi.encodePacked(createStreamMessage.tosVersion)) !=\n            keccak256(abi.encodePacked(params.tosVersion))\n        ) revert InvalidToSVersion();\n\n        // Handle creation fee (can be native or ERC20) BEFORE any cloning/deployment\n        // Pull the fee into the factory. msg.value must be handled by callee via checks.\n        TransferLib.pullFunds(\n            params.streamCreationFeeToken,\n            msg.sender,\n            params.streamCreationFee\n        );\n        TransferLib.pushFunds(\n            params.streamCreationFeeToken,\n            params.feeCollector,\n            params.streamCreationFee\n        );\n\n        // Clone stream contract\n        address clone = Clones.clone(params.streamImplementationAddress);\n        IStream stream = IStream(clone);\n\n        // Deploy PositionStorage\n        PositionStorage positionStorage = new PositionStorage(address(stream));\n\n        uint16 streamId = currentStreamId;\n        currentStreamId++;\n        streamAddresses[streamId] = address(stream);\n\n        // Transfer output tokens to stream (output tokens cannot be native)\n        uint256 totalOut = createStreamMessage.streamOutAmount + createStreamMessage.poolInfo.poolOutSupplyAmount;\n        TransferLib.pullFunds(createStreamMessage.outSupplyToken, msg.sender, totalOut);\n        TransferLib.pushFunds(createStreamMessage.outSupplyToken, address(stream), totalOut);\n\n        // Initialize the cloned stream\n        stream.initialize(createStreamMessage, address(positionStorage));\n\n        emit StreamCreated(\n            address(this),\n            createStreamMessage.outSupplyToken,\n            createStreamMessage.inSupplyToken,\n            address(stream),\n            createStreamMessage.creator,\n            address(positionStorage),\n            createStreamMessage.streamOutAmount,\n            createStreamMessage.bootstrappingStartTime,\n            createStreamMessage.streamStartTime,\n            createStreamMessage.streamEndTime,\n            createStreamMessage.threshold,\n            createStreamMessage.metadata.ipfsHash,\n            params.tosVersion,\n            streamId\n        );\n    }\n\n    // ============ Parameter Management ============\n\n    /**\n     * @dev Updates the stream creation fee\n     * @param streamCreationFee New creation fee amount\n     */\n    function updateStreamCreationFee(uint256 streamCreationFee) external onlyAdmin {\n        params.streamCreationFee = streamCreationFee;\n        emit ParamsUpdated(\n            address(this),\n            streamCreationFee,\n            params.exitFeeRatio.value,\n            params.minWaitingDuration,\n            params.minBootstrappingDuration,\n            params.minStreamDuration,\n            params.tosVersion\n        );\n    }\n\n    /**\n     * @dev Updates the stream creation fee token\n     * @param streamCreationFeeToken New fee token address\n     */\n    function updateStreamCreationFeeToken(address streamCreationFeeToken) external onlyAdmin {\n        // Allow zero address for native token support\n        // if (streamCreationFeeToken == address(0)) revert InvalidStreamCreationFeeToken();\n        params.streamCreationFeeToken = streamCreationFeeToken;\n        emit ParamsUpdated(\n            address(this),\n            params.streamCreationFee,\n            params.exitFeeRatio.value,\n            params.minWaitingDuration,\n            params.minBootstrappingDuration,\n            params.minStreamDuration,\n            params.tosVersion\n        );\n    }\n\n    /**\n     * @dev Updates the exit fee ratio\n     * @param exitFeeRatio New exit fee ratio\n     */\n    function updateExitFeeRatio(Decimal memory exitFeeRatio) external onlyAdmin {\n        if (DecimalMath.gt(exitFeeRatio, DecimalMath.fromNumber(1))) revert InvalidExitFeeRatio();\n        params.exitFeeRatio = exitFeeRatio;\n        emit ParamsUpdated(\n            address(this),\n            params.streamCreationFee,\n            exitFeeRatio.value,\n            params.minWaitingDuration,\n            params.minBootstrappingDuration,\n            params.minStreamDuration,\n            params.tosVersion\n        );\n    }\n\n    /**\n     * @dev Updates the minimum waiting duration\n     * @param minWaitingDuration New minimum waiting duration\n     */\n    function updateMinWaitingDuration(uint256 minWaitingDuration) external onlyAdmin {\n        params.minWaitingDuration = minWaitingDuration;\n        emit ParamsUpdated(\n            address(this),\n            params.streamCreationFee,\n            params.exitFeeRatio.value,\n            minWaitingDuration,\n            params.minBootstrappingDuration,\n            params.minStreamDuration,\n            params.tosVersion\n        );\n    }\n\n    /**\n     * @dev Updates the minimum bootstrapping duration\n     * @param minBootstrappingDuration New minimum bootstrapping duration\n     */\n    function updateMinBootstrappingDuration(uint256 minBootstrappingDuration) external onlyAdmin {\n        params.minBootstrappingDuration = minBootstrappingDuration;\n        emit ParamsUpdated(\n            address(this),\n            params.streamCreationFee,\n            params.exitFeeRatio.value,\n            params.minWaitingDuration,\n            minBootstrappingDuration,\n            params.minStreamDuration,\n            params.tosVersion\n        );\n    }\n\n    /**\n     * @dev Updates the minimum stream duration\n     * @param minStreamDuration New minimum stream duration\n     */\n    function updateMinStreamDuration(uint256 minStreamDuration) external onlyAdmin {\n        params.minStreamDuration = minStreamDuration;\n        emit ParamsUpdated(\n            address(this),\n            params.streamCreationFee,\n            params.exitFeeRatio.value,\n            params.minWaitingDuration,\n            params.minBootstrappingDuration,\n            minStreamDuration,\n            params.tosVersion\n        );\n    }\n\n    /**\n     * @dev Updates the TOS version\n     * @param tosVersion New TOS version\n     */\n    function updateTosVersion(string memory tosVersion) external onlyAdmin {\n        params.tosVersion = tosVersion;\n        emit ParamsUpdated(\n            address(this),\n            params.streamCreationFee,\n            params.exitFeeRatio.value,\n            params.minWaitingDuration,\n            params.minBootstrappingDuration,\n            params.minStreamDuration,\n            tosVersion\n        );\n    }\n\n    /**\n     * @dev Updates the fee collector address\n     * @param feeCollector New fee collector address\n     */\n    function updateFeeCollector(address feeCollector) external onlyAdmin {\n        if (feeCollector == address(0)) revert InvalidFeeCollector();\n        params.feeCollector = feeCollector;\n        emit FeeCollectorUpdated(address(this), feeCollector);\n    }\n\n    /**\n     * @dev Updates the protocol admin address\n     * @param protocolAdmin New protocol admin address\n     */\n    function updateProtocolAdmin(address protocolAdmin) external onlyAdmin {\n        if (protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        params.protocolAdmin = protocolAdmin;\n        emit ProtocolAdminUpdated(address(this), protocolAdmin);\n    }\n\n    /**\n     * @dev Updates the pool wrapper address\n     * @param poolWrapper New pool wrapper address\n     */\n    function updatePoolWrapper(address poolWrapper) external onlyAdmin {\n        if (poolWrapper == address(0)) revert InvalidPoolWrapper();\n        params.poolWrapperAddress = poolWrapper;\n        emit PoolWrapperUpdated(address(this), poolWrapper);\n    }\n\n    /**\n     * @dev Updates the stream implementation address\n     * @param implementation New stream implementation address\n     */\n    function updateStreamImplementation(address implementation) external onlyAdmin {\n        if (implementation == address(0)) revert InvalidImplementationAddress();\n        params.streamImplementationAddress = implementation;\n        emit ParamsUpdated(\n            address(this),\n            params.streamCreationFee,\n            params.exitFeeRatio.value,\n            params.minWaitingDuration,\n            params.minBootstrappingDuration,\n            params.minStreamDuration,\n            params.tosVersion\n        );\n    }\n\n    // ============ Token Management ============\n\n    /**\n     * @dev Updates the list of accepted input supply tokens\n     * @param tokensToAdd Array of token addresses to add\n     * @param tokensToRemove Array of token addresses to remove\n     */\n    function updateAcceptedTokens(\n        address[] calldata tokensToAdd,\n        address[] calldata tokensToRemove\n    ) external onlyAdmin {\n        for (uint256 i = 0; i < tokensToAdd.length; i++) {\n            acceptedInSupplyTokens[tokensToAdd[i]] = true;\n        }\n        for (uint256 i = 0; i < tokensToRemove.length; i++) {\n            acceptedInSupplyTokens[tokensToRemove[i]] = false;\n        }\n        emit AcceptedTokensUpdated(address(this), tokensToAdd, tokensToRemove);\n    }\n\n    // ============ Factory Management ============\n\n    /**\n     * @dev Sets the frozen state of the factory\n     * @param isFrozen Whether the factory should be frozen\n     */\n    function setFrozen(bool isFrozen) external onlyAdmin {\n        frozen = isFrozen;\n        emit FrozenStateUpdated(address(this), isFrozen);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @dev Get all stream addresses\n     * @return Array of stream addresses\n     */\n    function getStreams() external view returns (address[] memory) {\n        address[] memory streams = new address[](currentStreamId);\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            streams[i] = streamAddresses[i];\n        }\n        return streams;\n    }\n\n    /**\n     * @dev Get stream address by ID\n     * @param streamId Stream ID\n     * @return Stream address\n     */\n    function getStream(uint16 streamId) external view returns (address) {\n        return streamAddresses[streamId];\n    }\n\n    /**\n     * @dev Check if an address is a stream created by this factory\n     * @param streamAddress Address to check\n     * @return True if the address is a stream\n     */\n    function isStream(address streamAddress) external view returns (bool) {\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            if (streamAddresses[i] == streamAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Get factory parameters\n     * @return Factory parameters\n     */\n    function getParams() external view returns (StreamFactoryTypes.Params memory) {\n        return params;\n    }\n\n    /**\n     * @dev Check if a token is accepted as input supply token\n     * @param token Token address to check\n     * @return True if the token is accepted\n     */\n    function isAcceptedInSupplyToken(address token) public view returns (bool) {\n        return acceptedInSupplyTokens[token];\n    }\n\n    /**\n     * @dev Get all accepted input supply tokens\n     * @return Array of accepted token addresses\n     */\n    function getAcceptedInSupplyTokens() external view returns (address[] memory) {\n        address[] memory tokens = new address[](currentStreamId);\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            if (acceptedInSupplyTokens[streamAddresses[i]]) {\n                tokens[i] = streamAddresses[i];\n            }\n        }\n        return tokens;\n    }\n\n    // ============ Internal Functions ============\n\n    /**\n     * @dev Validates stream timing parameters\n     * @param nowTime Current timestamp\n     * @param bootstrappingStartTime Bootstrapping start time\n     * @param startTime Stream start time\n     * @param endTime Stream end time\n     */\n    function validateStreamTimes(\n        uint256 nowTime,\n        uint256 bootstrappingStartTime,\n        uint256 startTime,\n        uint256 endTime\n    ) internal view {\n        if (nowTime > bootstrappingStartTime) revert InvalidBootstrappingStartTime();\n        if (bootstrappingStartTime > startTime) revert InvalidStreamStartTime();\n        if (startTime > endTime) revert InvalidStreamEndTime();\n        if (endTime - startTime < params.minStreamDuration) revert StreamDurationTooShort();\n        if (startTime - bootstrappingStartTime < params.minBootstrappingDuration)\n            revert BootstrappingDurationTooShort();\n        if (bootstrappingStartTime - nowTime < params.minWaitingDuration) revert WaitingDurationTooShort();\n    }\n\n    /**\n     * @dev Validates vesting configurations\n     * @param vesting Vesting configuration to validate\n     */\n    function validateVesting(StreamTypes.VestingInfo memory vesting) internal pure {\n        if (vesting.isVestingEnabled && vesting.vestingDuration == 0) {\n            revert InvalidVestingDuration();\n        }\n    }\n}\n"
    },
    "src/types/PoolWrapperTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nlibrary PoolWrapperTypes {\n    struct CreatePoolMsg {\n        address token0;\n        address token1;\n        uint256 amount0;\n        uint256 amount1;\n    }\n\n    struct CreatedPoolInfo {\n        address poolAddress;\n        address token0;\n        address token1;\n    }\n}\n"
    },
    "src/types/PositionTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\nlibrary PositionTypes {\n    struct Position {\n        uint256 inBalance;\n        uint256 shares;\n        Decimal index;\n        uint256 lastUpdateTime;\n        Decimal pendingReward;\n        uint256 spentIn;\n        uint256 purchased;\n        uint256 exitDate;\n    }\n}\n"
    },
    "src/types/StreamFactoryTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\nlibrary StreamFactoryTypes {\n    struct Params {\n        uint256 streamCreationFee;\n        address streamCreationFeeToken;\n        Decimal exitFeeRatio;\n        uint256 minWaitingDuration;\n        uint256 minBootstrappingDuration;\n        uint256 minStreamDuration;\n        address feeCollector;\n        address protocolAdmin;\n        string tosVersion;\n        address vestingFactoryAddress;\n        address poolWrapperAddress;\n        address streamImplementationAddress;\n    }\n\n    struct InitializeStreamMessage {\n        uint256 streamCreationFee;\n        address streamCreationFeeToken;\n        Decimal exitFeeRatio;\n        uint256 minWaitingDuration;\n        uint256 minBootstrappingDuration;\n        uint256 minStreamDuration;\n        address feeCollector;\n        address protocolAdmin;\n        string tosVersion;\n        address poolWrapperAddress;\n        address streamImplementationAddress;\n        address[] acceptedInSupplyTokens;\n    }\n}\n"
    },
    "src/types/StreamTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Decimal } from \"../lib/math/DecimalMath.sol\";\n\nlibrary StreamTypes {\n    enum Status {\n        Waiting,\n        Bootstrapping,\n        Active,\n        Ended,\n        FinalizedRefunded,\n        FinalizedStreamed,\n        Cancelled\n    }\n\n    struct CreateStreamMessage {\n        address creator;\n        address inSupplyToken;\n        address outSupplyToken;\n        uint256 streamOutAmount;\n        uint256 threshold;\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n        StreamMetadata metadata;\n        VestingInfo creatorVesting;\n        VestingInfo beneficiaryVesting;\n        PoolInfo poolInfo;\n        string tosVersion;\n    }\n    struct StreamTimes {\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n    }\n\n    struct StreamMetadata {\n        string ipfsHash;\n    }\n\n    struct StreamState {\n        uint256 outRemaining;\n        Decimal distIndex;\n        uint256 spentIn;\n        uint256 shares;\n        Decimal currentStreamedPrice;\n        uint256 threshold;\n        uint256 inSupply;\n        uint256 outSupply;\n        uint256 lastUpdated;\n    }\n\n    struct StreamTokens {\n        address inSupplyToken;\n        address outSupplyToken;\n    }\n\n    struct VestingInfo {\n        bool isVestingEnabled;\n        uint64 vestingDuration;\n    }\n\n    struct PoolInfo {\n        uint256 poolOutSupplyAmount;\n    }\n\n    struct PostStreamActions {\n        PoolInfo poolInfo;\n        VestingInfo creatorVesting;\n        VestingInfo beneficiaryVesting;\n    }\n}\n"
    },
    "src/VestingFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title VestingFactory\n * @author Adnan Deniz Corlu (@Ninjatosba)\n * @notice Factory for creating OpenZeppelin VestingWallet instances for stream participants\n * @dev This contract creates vesting wallets for post-stream token distribution:\n *      - Creates VestingWallet instances using OpenZeppelin's audited implementation\n *      - Handles token transfers to newly created vesting contracts\n *      - Used for both creator and beneficiary vesting scenarios\n *      - Ensures secure and standardized vesting functionality\n */\n\nimport { VestingWallet } from \"@openzeppelin/contracts/finance/VestingWallet.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title VestingFactory\n * @dev Factory contract for creating OpenZeppelin VestingWallet instances\n */\ncontract VestingFactory {\n    using SafeERC20 for IERC20;\n\n    // Custom errors\n    error InvalidBeneficiary();\n    error InvalidStartTime();\n    error InvalidDuration();\n    error InvalidToken();\n    error InvalidAmount();\n    error TokenTransferFailed();\n\n    event VestingWalletCreated(\n        address indexed beneficiary,\n        address indexed vestingWallet,\n        uint64 startTime,\n        uint64 duration,\n        address token,\n        uint256 amount\n    );\n\n    /**\n     * @dev Creates a VestingWallet and transfers tokens to it in one transaction\n     * @param beneficiary address of the beneficiary\n     * @param startTime the time (as Unix time) at which point vesting begins\n     * @param duration duration in seconds of the period in which the tokens will vest\n     * @param token the ERC20 token to transfer to the vesting wallet\n     * @param amount the amount of tokens to transfer\n     * @return vestingWallet the address of the created VestingWallet\n     */\n    function createVestingWalletWithTokens(\n        address beneficiary,\n        uint64 startTime,\n        uint64 duration,\n        address token,\n        uint256 amount\n    ) external returns (address vestingWallet) {\n        if (beneficiary == address(0)) revert InvalidBeneficiary();\n        if (startTime == 0) revert InvalidStartTime();\n        if (startTime < block.timestamp) revert InvalidStartTime();\n        if (duration == 0) revert InvalidDuration();\n        if (token == address(0)) revert InvalidToken();\n        if (amount == 0) revert InvalidAmount();\n\n        // Create the vesting wallet\n        vestingWallet = address(new VestingWallet(beneficiary, startTime, duration));\n\n        // Transfer tokens to the vesting wallet\n        IERC20(token).safeTransferFrom(msg.sender, vestingWallet, amount);\n\n        emit VestingWalletCreated(beneficiary, vestingWallet, startTime, duration, token, amount);\n        return vestingWallet;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}