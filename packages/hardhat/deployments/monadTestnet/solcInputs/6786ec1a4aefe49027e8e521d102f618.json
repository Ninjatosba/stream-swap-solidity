{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev A clone instance deployment failed.\n     */\n    error ERC1167FailedCreateClone();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IPoolWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../types/PoolWrapperTypes.sol\";\n\ninterface IPoolWrapper {\n    function createPool(\n        PoolWrapperTypes.CreatePoolMsg calldata createPoolMsg\n    ) external returns (PoolWrapperTypes.CreatedPoolInfo memory);\n\n    function getPoolInfo(address stream) external view returns (PoolWrapperTypes.CreatedPoolInfo memory);\n}\n"
    },
    "contracts/interfaces/IPositionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../types/PositionTypes.sol\";\nimport \"../lib/math/DecimalMath.sol\";\n\ninterface IPositionStorage {\n    function getPosition(address _owner) external view returns (PositionTypes.Position memory);\n\n    function createPosition(address owner, uint256 inBalance, uint256 shares, Decimal memory index) external;\n\n    function updatePosition(address owner, PositionTypes.Position memory position) external;\n\n    function setExitDate(address owner, uint256 exitDate) external;\n}\n"
    },
    "contracts/interfaces/IStream.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../types/StreamTypes.sol\";\nimport \"../types/PositionTypes.sol\";\n\ninterface IStream {\n    function initialize(\n        StreamTypes.createStreamMessage memory createStreamMessage,\n        address positionStorageAddress\n    ) external;\n\n    function withdraw(uint256 cap) external;\n\n    function subscribe(uint256 amountIn) external payable;\n\n    function exitStream() external;\n\n    function finalizeStream() external;\n\n    function syncStreamExternal() external;\n\n    function syncPosition(address user) external;\n\n    function cancelStream() external;\n\n    function cancelWithAdmin() external;\n\n    // View functions\n    function getStreamStatus() external view returns (StreamTypes.Status);\n\n    function getStreamState() external view returns (StreamTypes.StreamState memory);\n\n    function getPosition(address user) external view returns (PositionTypes.Position memory);\n\n    // State variables getters (since they're public)\n    function creator() external view returns (address);\n\n    function positionStorageAddress() external view returns (address);\n\n    function streamFactoryAddress() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IStreamErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IStreamErrors {\n    // Stream errors\n    error InsufficientTokenPayment(uint256 requiredTokenAmount, uint256 tokenBalance);\n    error InvalidOutSupplyToken();\n    error InvalidInSupplyToken();\n    error PaymentFailed();\n    error OperationNotAllowed();\n    error Unauthorized();\n    error InvalidWithdrawAmount();\n    error WithdrawAmountExceedsBalance(uint256 cap);\n    error InsufficientOutAmount();\n    error InvalidPosition();\n    error InvalidExitCondition();\n    error InvalidVestingDuration();\n    error InvalidVestingCliffDuration();\n    error InvalidAmount();\n    error StreamFactoryAddressAlreadySet();\n    error InvalidStreamFactoryAddress();\n    error InvalidImplementationAddress();\n}\n"
    },
    "contracts/interfaces/IStreamEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../types/StreamTypes.sol\";\nimport \"../lib/math/DecimalMath.sol\";\n\ninterface IStreamEvents {\n    event StreamCreated(\n        address indexed streamOutToken,\n        address indexed streamInToken,\n        address indexed streamFactoryAddress,\n        uint256 streamOutAmount,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 threshold,\n        string streamName,\n        string tosVersion,\n        address streamAddress,\n        uint16 streamId\n    );\n\n    event StreamSynced(address indexed streamAddress, StreamTypes.Status mainStatus, uint256 lastUpdated);\n\n    event Subscribed(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 amountIn,\n        uint256 newShares,\n        uint256 totalSharesAfter,\n        uint256 totalInSupplyAfter\n    );\n\n    event StreamSynced(\n        address indexed streamAddress,\n        uint256 lastUpdated,\n        uint8 newStatus,\n        Decimal distIndex,\n        uint256 outRemaining,\n        uint256 inSupply,\n        uint256 spentIn,\n        Decimal currentStreamedPrice\n    );\n\n    event PositionSynced(address indexed streamAddress, address indexed subscriber, uint256 inBalance, uint256 shares);\n\n    event Withdrawn(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 remainingInBalance,\n        uint256 remainingShares,\n        uint256 totalInSupply,\n        uint256 totalShares\n    );\n\n    event ExitRefunded(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 refundedAmount,\n        uint256 exitTimestamp\n    );\n    event ExitStreamed(\n        address indexed streamAddress,\n        address indexed subscriber,\n        uint256 purchased,\n        uint256 spentIn,\n        uint256 exitTimestamp\n    );\n\n    event FinalizedStreamed(\n        address indexed streamAddress,\n        address indexed creator,\n        uint256 creatorRevenue,\n        uint256 exitFeeAmount,\n        uint256 refundedOutAmount,\n        StreamTypes.Status status\n    );\n\n    event FinalizedRefunded(\n        address indexed streamAddress,\n        address indexed creator,\n        uint256 refundedOutAmount,\n        StreamTypes.Status status\n    );\n\n    event ParamsUpdated(\n        address indexed factory,\n        uint256 streamCreationFee,\n        uint256 exitFeeRatio,\n        uint256 minWaitingDuration,\n        uint256 minBootstrappingDuration,\n        uint256 minStreamDuration,\n        string tosVersion\n    );\n\n    event FeeCollectorUpdated(address indexed factory, address newFeeCollector);\n\n    event ProtocolAdminUpdated(address indexed factory, address newProtocolAdmin);\n\n    event FrozenStateUpdated(address indexed factory, bool frozen);\n\n    event AcceptedTokensUpdated(address indexed factory, address[] tokensAdded, address[] tokensRemoved);\n\n    event StreamCancelled(address indexed streamAddress, address creator, uint256 outSupply, StreamTypes.Status status);\n\n    event VestingContractDeployed(address indexed factoryAddress, address vestingContract);\n\n    event PoolWrapperUpdated(address indexed factoryAddress, address poolWrapper);\n}\n"
    },
    "contracts/interfaces/IStreamFactoryErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// StreamFactory errors\ninterface IStreamFactoryErrors {\n    // StreamFactory errors\n    error InvalidBootstrappingStartTime();\n    error InvalidStreamStartTime();\n    error InvalidStreamEndTime();\n    error StreamDurationTooShort();\n    error BootstrappingDurationTooShort();\n    error WaitingDurationTooShort();\n    error ContractFrozen();\n    error InvalidExitFeeRatio();\n    error ZeroOutSupplyNotAllowed();\n    error StreamInputTokenNotAccepted();\n    error InvalidBootstrappingTime();\n    error StreamStartMustBeAfterBootstrapping();\n    error StreamEndMustBeAfterStart();\n    error InvalidToSVersion();\n    error InsufficientNativeToken();\n    error FeeTransferFailed();\n    error TokenTransferFailed();\n    error StreamAddressPredictionFailed();\n    error InvalidFeeCollector();\n    error InvalidProtocolAdmin();\n    error NotAdmin();\n    error InvalidPoolWrapper();\n    error InvalidImplementationAddress();\n}\n"
    },
    "contracts/interfaces/IVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title IVesting\n * @dev Interface for the Vesting contract that manages token vesting schedules\n */\ninterface IVesting {\n    /**\n     * @dev Struct representing a vesting schedule for a beneficiary\n     */\n    struct VestingSchedule {\n        uint256 cliffTime; // Timestamp when cliff period ends\n        uint256 endTime; // Timestamp when vesting period ends\n        uint256 totalAmount; // Total amount to be vested\n        uint256 releasedAmount; // Amount already released to beneficiary\n    }\n\n    /**\n     * @dev Stakes funds for vesting to a beneficiary\n     * @param beneficiary Address that will receive the vested tokens\n     * @param tokenAddress Address of the token being vested\n     * @param cliffTime Timestamp after which the first tokens can be withdrawn\n     * @param endTime Timestamp when all tokens will be vested\n     * @param totalAmount Total amount of tokens to vest\n     */\n    function stakeFunds(\n        address beneficiary,\n        address tokenAddress,\n        uint256 cliffTime,\n        uint256 endTime,\n        uint256 totalAmount\n    ) external;\n\n    /**\n     * @dev Withdraws available vested funds for the caller\n     * @param tokenAddress Address of the token to withdraw\n     * @param scheduleIndex Index of the vesting schedule to withdraw from\n     */\n    function withdrawFunds(address tokenAddress, uint256 scheduleIndex) external;\n\n    /**\n     * @dev Retrieves all vesting schedules for a beneficiary for a specific token\n     * @param beneficiary Address of the beneficiary\n     * @param tokenAddress Address of the token\n     * @return Array of vesting schedules\n     */\n    function getStakesForBeneficiary(\n        address beneficiary,\n        address tokenAddress\n    ) external view returns (VestingSchedule[] memory);\n\n    /**\n     * @dev Calculates the amount available for withdrawal from a vesting schedule\n     * @param vestingSchedule The vesting schedule to check\n     * @return The withdrawable amount\n     */\n    function calculateWithdrawableAmount(VestingSchedule memory vestingSchedule) external view returns (uint256);\n}\n"
    },
    "contracts/lib/helpers/TokenHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IStreamErrors.sol\";\n\nlibrary TokenHelpers {\n    /**\n     * @dev Checks if an address is a valid ERC20 token\n     * @param tokenAddress The token address to validate\n     * @param testAccount The account to use for testing the token interface\n     * @return isValid True if the address implements the ERC20 interface\n     */\n    function isValidERC20(address tokenAddress, address testAccount) internal view returns (bool isValid) {\n        if (tokenAddress == address(0)) {\n            return false;\n        }\n\n        try IERC20(tokenAddress).balanceOf(testAccount) returns (uint256) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Checks if an account has sufficient token balance\n     * @param tokenAddress The ERC20 token address\n     * @param account The account to check balance for\n     * @param requiredAmount The minimum required balance\n     * @return hasEnoughBalance True if the account has sufficient balance\n     */\n    function hasEnoughBalance(\n        address tokenAddress,\n        address account,\n        uint256 requiredAmount\n    ) internal view returns (bool) {\n        try IERC20(tokenAddress).balanceOf(account) returns (uint256 balance) {\n            return balance >= requiredAmount;\n        } catch Error(string memory) {\n            return false;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Safely transfers tokens from the contract to a recipient\n     * @param tokenAddress Address of the token to transfer\n     * @param recipient Address of the recipient\n     * @param amount Amount of tokens to transfer\n     * @return bool True if the transfer was successful\n     */\n    function safeTokenTransfer(address tokenAddress, address recipient, uint256 amount) internal returns (bool) {\n        if (amount == 0 || recipient == address(0)) {\n            return true;\n        }\n\n        IERC20 token = IERC20(tokenAddress);\n        bool success = token.transfer(recipient, amount);\n        if (!success) {\n            revert IStreamErrors.PaymentFailed();\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/lib/math/DecimalMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title Decimal type and math operations\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\n\nstruct Decimal {\n    uint256 value; // Value scaled by DECIMAL_PRECISION\n}\n\n/**\n * @title DecimalMath\n * @dev Library for handling decimal math operations with fixed-point arithmetic\n */\nlibrary DecimalMath {\n    // We'll use 6 decimal places for precision\n    uint256 public constant DECIMAL_PRECISION = 1e6;\n\n    // Convert a regular number to a Decimal\n    function fromNumber(uint256 value) internal pure returns (Decimal memory) {\n        return Decimal({ value: value * DECIMAL_PRECISION });\n    }\n\n    // Convert a Decimal to a regular number while keeping the remainder\n    function toNumber(Decimal memory d) internal pure returns (uint256, Decimal memory) {\n        return (d.value / DECIMAL_PRECISION, Decimal({ value: d.value % DECIMAL_PRECISION }));\n    }\n\n    // Floor division for Decimal\n    function floor(Decimal memory d) internal pure returns (uint256) {\n        return d.value / DECIMAL_PRECISION;\n    }\n\n    // Ceiling division for Decimal\n    function ceil(Decimal memory d) internal pure returns (uint256) {\n        return (d.value + DECIMAL_PRECISION - 1) / DECIMAL_PRECISION;\n    }\n\n    // Multiply two Decimals\n    function mul(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: (a.value * b.value) / DECIMAL_PRECISION });\n    }\n\n    // Multiply Decimal by a scalar\n    function mulScalar(Decimal memory a, uint256 scalar) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value * scalar });\n    }\n\n    // Divide two Decimals\n    function div(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: (a.value * DECIMAL_PRECISION) / b.value });\n    }\n\n    // Divide Decimal by a scalar\n    function divScalar(Decimal memory a, uint256 scalar) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value / scalar });\n    }\n\n    // Add two Decimals\n    function add(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value + b.value });\n    }\n\n    // Subtract two Decimals\n    function sub(Decimal memory a, Decimal memory b) internal pure returns (Decimal memory) {\n        return Decimal({ value: a.value - b.value });\n    }\n\n    // From ratio to Decimal\n    function fromRatio(uint256 num, uint256 denom) internal pure returns (Decimal memory) {\n        return Decimal({ value: (num * DECIMAL_PRECISION) / denom });\n    }\n\n    // > operator for Decimals\n    function gt(Decimal memory a, Decimal memory b) internal pure returns (bool) {\n        return a.value > b.value;\n    }\n\n    // < operator for Decimals\n    function lt(Decimal memory a, Decimal memory b) internal pure returns (bool) {\n        return a.value < b.value;\n    }\n}\n"
    },
    "contracts/lib/math/StreamMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../types/StreamTypes.sol\";\nimport \"./DecimalMath.sol\";\nimport \"../../types/PositionTypes.sol\";\n\nimport \"hardhat/console.sol\";\n\nlibrary StreamMathLib {\n    /**\n     * @dev Calculates the time difference ratio between current time and last updated time\n     * @param currentTimestamp Current timestamp\n     * @param streamStartTime Timestamp when the stream starts\n     * @param streamEndTime Timestamp when the stream ends\n     * @param lastUpdated Timestamp when the stream was last updated\n     * @return The ratio of time elapsed since last update compared to total remaining time (scaled by 1e18)\n     */\n    function calculateDiff(\n        uint256 currentTimestamp,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 lastUpdated\n    ) internal pure returns (Decimal memory) {\n        // If the stream is not started yet or already ended, return 0\n        if (currentTimestamp < streamStartTime || lastUpdated >= streamEndTime) {\n            return DecimalMath.fromNumber(0);\n        }\n\n        // If lastUpdated is before start time, set it to start time\n        uint256 effectiveLastUpdated = lastUpdated;\n        if (effectiveLastUpdated < streamStartTime) {\n            effectiveLastUpdated = streamStartTime;\n        }\n\n        // If current time is past end time, use end time instead\n        uint256 effectiveNow = currentTimestamp;\n        if (effectiveNow > streamEndTime) {\n            effectiveNow = streamEndTime;\n        }\n\n        uint256 numerator = effectiveNow - effectiveLastUpdated;\n        uint256 denominator = streamEndTime - effectiveLastUpdated;\n\n        if (denominator == 0 || numerator == 0) {\n            return DecimalMath.fromNumber(0);\n        }\n        // Return ratio of time elapsed since last update compared to total remaining time\n        return DecimalMath.fromRatio(numerator, denominator);\n    }\n\n    /**\n     * @dev Calculates the stream status based on the current state and timestamp\n     * @param currentStatus Current status of the stream\n     * @param currentTime Current timestamp to check against\n     * @param bootstrappingStartTime Timestamp when bootstrapping phase starts\n     * @param streamStartTime Timestamp when active streaming starts\n     * @param streamEndTime Timestamp when streaming ends\n     * @return IStreamTypes.Status The calculated stream status\n     */\n    function calculateStreamStatus(\n        StreamTypes.Status currentStatus,\n        uint256 currentTime,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime\n    ) internal pure returns (StreamTypes.Status) {\n        // Don't update if stream is in a final state\n        if (\n            currentStatus == StreamTypes.Status.Cancelled ||\n            currentStatus == StreamTypes.Status.FinalizedRefunded ||\n            currentStatus == StreamTypes.Status.FinalizedStreamed\n        ) {\n            return currentStatus;\n        }\n\n        // Update status based on current timestamp\n        if (currentTime < bootstrappingStartTime) {\n            return StreamTypes.Status.Waiting;\n        } else if (currentTime >= bootstrappingStartTime && currentTime < streamStartTime) {\n            return StreamTypes.Status.Bootstrapping;\n        } else if (currentTime >= streamStartTime && currentTime < streamEndTime) {\n            return StreamTypes.Status.Active;\n        } else if (currentTime >= streamEndTime) {\n            return StreamTypes.Status.Ended;\n        }\n\n        // This should never be reached, but return current status as fallback\n        return currentStatus;\n    }\n\n    /**\n     * @dev Calculates updated stream state based on time difference\n     * @param state Current stream state\n     * @param diff Time difference in seconds\n     * @return Updated stream state\n     */\n    function calculateUpdatedState(\n        StreamTypes.StreamState memory state,\n        Decimal memory diff\n    ) internal pure returns (StreamTypes.StreamState memory) {\n        // Create a copy of the state to avoid modifying the input\n        StreamTypes.StreamState memory newState = state;\n\n        if (newState.shares > 0 && diff.value > 0) {\n            // Calculate new distribution balance and spent in amount\n            Decimal memory newDecimalDistributionBalance = DecimalMath.mul(\n                DecimalMath.fromNumber(newState.outRemaining),\n                diff\n            );\n            uint256 newDistributionBalance = DecimalMath.floor(newDecimalDistributionBalance);\n\n            Decimal memory newDecimalSpentIn = DecimalMath.mul(DecimalMath.fromNumber(newState.inSupply), diff);\n            uint256 spentIn = DecimalMath.floor(newDecimalSpentIn);\n\n            // Update state variables\n            newState.spentIn += spentIn;\n            newState.inSupply -= spentIn;\n\n            if (newDistributionBalance > 0) {\n                newState.outRemaining -= newDistributionBalance;\n                // Increment distribution index\n                Decimal memory distIndexIncrementAmount = DecimalMath.fromRatio(\n                    newDistributionBalance,\n                    newState.shares\n                );\n                newState.distIndex = DecimalMath.add(newState.distIndex, distIndexIncrementAmount);\n                // Update current streamed price\n                newState.currentStreamedPrice = DecimalMath.fromRatio(spentIn, newDistributionBalance);\n            }\n        }\n        return newState;\n    }\n\n    function computeSharesAmount(\n        uint256 amountIn,\n        bool roundUp,\n        uint256 inSupply,\n        uint256 totalShares\n    ) internal pure returns (uint256) {\n        if (totalShares == 0 || amountIn == 0) {\n            return amountIn;\n        }\n\n        uint256 totalSharesIn = totalShares * amountIn;\n        if (roundUp) {\n            return (totalSharesIn + inSupply - 1) / inSupply;\n        } else {\n            return totalSharesIn / inSupply;\n        }\n    }\n\n    /**\n     * @dev Calculates the exit fee amount based on the spent in amount\n     * @param spentInAmount Amount of tokens spent in the stream\n     * @return exitFeeAmount The calculated fee amount\n     * @return remainingAmount The remaining amount after fee deduction\n     */\n    function calculateExitFee(\n        uint256 spentInAmount,\n        Decimal memory exitFeeRatio\n    ) internal pure returns (uint256 exitFeeAmount, uint256 remainingAmount) {\n        Decimal memory decimalSpentIn = DecimalMath.fromNumber(spentInAmount);\n\n        // Calculate exit fee amount using DecimalMath\n        Decimal memory decimalExitFeeAmount = DecimalMath.mul(decimalSpentIn, exitFeeRatio);\n        exitFeeAmount = DecimalMath.floor(decimalExitFeeAmount);\n        remainingAmount = spentInAmount - exitFeeAmount;\n\n        return (exitFeeAmount, remainingAmount);\n    }\n\n    function calculatePoolAmount(uint256 creatorRevenue, Decimal memory poolRatio) internal pure returns (uint256) {\n        Decimal memory decimalCreatorRevenue = DecimalMath.fromNumber(creatorRevenue);\n        Decimal memory decimalPoolAmount = DecimalMath.mul(decimalCreatorRevenue, poolRatio);\n        return DecimalMath.floor(decimalPoolAmount);\n    }\n\n    function syncPosition(\n        PositionTypes.Position memory position,\n        Decimal memory distIndex,\n        uint256 totalShares,\n        uint256 inSupply,\n        uint256 nowTime\n    ) internal pure returns (PositionTypes.Position memory) {\n        // Create a new position in memory to store the updated values\n        PositionTypes.Position memory updatedPosition = PositionTypes.Position({\n            inBalance: position.inBalance,\n            shares: position.shares,\n            index: position.index,\n            lastUpdateTime: position.lastUpdateTime,\n            pendingReward: position.pendingReward,\n            spentIn: position.spentIn,\n            purchased: position.purchased,\n            exitDate: position.exitDate\n        });\n\n        // Calculate index difference for distributions since last update\n        Decimal memory indexDiff = DecimalMath.sub(distIndex, updatedPosition.index);\n        uint256 spent = 0;\n        uint256 purchased = 0;\n\n        // Only process if there are shares in the stream\n        if (totalShares > 0) {\n            // Calculate purchased amount based on position shares and index difference\n            Decimal memory positionSharesDecimal = DecimalMath.fromNumber(updatedPosition.shares);\n            Decimal memory purchasedDecimal = DecimalMath.add(\n                DecimalMath.mul(positionSharesDecimal, indexDiff),\n                updatedPosition.pendingReward\n            );\n            (purchased, purchasedDecimal) = DecimalMath.toNumber(purchasedDecimal);\n            updatedPosition.purchased += purchased;\n            updatedPosition.pendingReward = purchasedDecimal;\n\n            // Calculate remaining balance based on current shares ratio\n            uint256 inRemaining = (inSupply * updatedPosition.shares) / totalShares;\n            // Calculate spent amount\n            spent = updatedPosition.inBalance - inRemaining;\n            updatedPosition.spentIn += spent;\n            updatedPosition.inBalance = inRemaining;\n        }\n\n        // Update position tracking\n        updatedPosition.index = distIndex;\n        updatedPosition.lastUpdateTime = nowTime;\n\n        return updatedPosition;\n    }\n\n    function calculateVestingSchedule(\n        uint256 nowTime,\n        uint256 cliffDuration,\n        uint256 vestingDuration\n    ) internal pure returns (uint256 cliffTime, uint256 endTime) {\n        cliffTime = nowTime + cliffDuration;\n        endTime = nowTime + vestingDuration;\n        return (cliffTime, endTime);\n    }\n}\n"
    },
    "contracts/mock/StreamMathLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../lib/math/StreamMathLib.sol\";\nimport \"../types/StreamTypes.sol\";\nimport \"../types/PositionTypes.sol\";\nimport \"../lib/math/DecimalMath.sol\";\n\ncontract StreamMathLibMock {\n    function calculateDiff(\n        uint256 currentTimestamp,\n        uint256 streamStartTime,\n        uint256 streamEndTime,\n        uint256 lastUpdated\n    ) external pure returns (Decimal memory) {\n        return StreamMathLib.calculateDiff(currentTimestamp, streamStartTime, streamEndTime, lastUpdated);\n    }\n\n    function calculateStreamStatus(\n        StreamTypes.Status currentStatus,\n        uint256 currentTime,\n        uint256 bootstrappingStartTime,\n        uint256 streamStartTime,\n        uint256 streamEndTime\n    ) external pure returns (StreamTypes.Status) {\n        return\n            StreamMathLib.calculateStreamStatus(\n                currentStatus,\n                currentTime,\n                bootstrappingStartTime,\n                streamStartTime,\n                streamEndTime\n            );\n    }\n\n    function calculateUpdatedState(\n        StreamTypes.StreamState memory state,\n        Decimal memory diff\n    ) external pure returns (StreamTypes.StreamState memory) {\n        return StreamMathLib.calculateUpdatedState(state, diff);\n    }\n\n    function computeSharesAmount(\n        uint256 amountIn,\n        bool roundUp,\n        uint256 inSupply,\n        uint256 totalShares\n    ) external pure returns (uint256) {\n        return StreamMathLib.computeSharesAmount(amountIn, roundUp, inSupply, totalShares);\n    }\n\n    function calculateExitFee(\n        uint256 spentInAmount,\n        Decimal memory ExitFeeRatio\n    ) external pure returns (uint256 feeAmount, uint256 remainingAmount) {\n        return StreamMathLib.calculateExitFee(spentInAmount, ExitFeeRatio);\n    }\n\n    function syncPosition(\n        PositionTypes.Position memory position,\n        Decimal memory distIndex,\n        uint256 shares,\n        uint256 inSupply,\n        uint256 nowTime\n    ) external pure returns (PositionTypes.Position memory) {\n        return StreamMathLib.syncPosition(position, distIndex, shares, inSupply, nowTime);\n    }\n}\n"
    },
    "contracts/storage/PositionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../types/PositionTypes.sol\";\nimport \"../lib/math/DecimalMath.sol\";\n\ncontract PositionStorage {\n    using PositionTypes for PositionTypes.Position;\n\n    mapping(address => PositionTypes.Position) private positions;\n    address public immutable streamContractAddress;\n\n    constructor(address _streamContractAddress) {\n        streamContractAddress = _streamContractAddress;\n    }\n\n    function getPosition(address _owner) external view returns (PositionTypes.Position memory) {\n        return positions[_owner];\n    }\n\n    modifier onlyStreamContract() {\n        require(msg.sender == streamContractAddress, \"Position can only be set by the stream contract\");\n        _;\n    }\n\n    function createPosition(\n        address owner,\n        uint256 inBalance,\n        uint256 shares,\n        Decimal memory index\n    ) external onlyStreamContract {\n        positions[owner] = PositionTypes.Position(\n            inBalance,\n            shares,\n            index,\n            block.timestamp,\n            DecimalMath.fromNumber(0),\n            0,\n            0,\n            0\n        );\n    }\n\n    function updatePosition(address owner, PositionTypes.Position memory position) external onlyStreamContract {\n        positions[owner] = position;\n    }\n\n    function setExitDate(address owner, uint256 exitDate) external onlyStreamContract {\n        positions[owner].exitDate = exitDate;\n    }\n}\n"
    },
    "contracts/Stream.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./interfaces/IPositionStorage.sol\";\nimport \"./types/PositionTypes.sol\";\nimport \"./interfaces/IStreamEvents.sol\";\nimport \"./interfaces/IStreamErrors.sol\";\nimport \"./types/StreamTypes.sol\";\nimport \"./StreamFactory.sol\";\nimport \"./types/StreamFactoryTypes.sol\";\nimport \"./lib/math/DecimalMath.sol\";\nimport \"./lib/math/StreamMathLib.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/helpers/TokenHelpers.sol\";\nimport \"./interfaces/IPoolWrapper.sol\";\nimport \"./interfaces/IVesting.sol\";\nimport \"./types/PoolWrapperTypes.sol\";\n\ncontract Stream is IStreamErrors, IStreamEvents {\n    address public creator;\n    address immutable streamFactoryAddress;\n    address public positionStorageAddress;\n    bool private initialized;\n\n    StreamTypes.StreamState public streamState;\n    StreamTypes.StreamTokens public streamTokens;\n    StreamTypes.StreamMetadata public streamMetadata;\n    StreamTypes.Status public streamStatus;\n    StreamTypes.StreamTimes public streamTimes;\n    StreamTypes.PostStreamActions public postStreamActions;\n\n    modifier onlyOnce() {\n        if (initialized) revert Unauthorized();\n        _;\n        initialized = true;\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != streamFactoryAddress) revert Unauthorized();\n        _;\n    }\n\n    constructor(address _streamFactoryAddress) {\n        streamFactoryAddress = _streamFactoryAddress;\n    }\n\n    function initialize(\n        StreamTypes.createStreamMessage memory createStreamMessage,\n        address _positionStorageAddress\n    ) external onlyOnce onlyAdmin {\n        // Validate that output token is a valid ERC20\n        if (!TokenHelpers.isValidERC20(createStreamMessage.outSupplyToken, msg.sender)) {\n            revert InvalidOutSupplyToken();\n        }\n        // Check if the contract has enough balance of output token\n        uint256 totalRequiredAmount = createStreamMessage.streamOutAmount +\n            createStreamMessage.poolInfo.poolOutSupplyAmount;\n        if (!TokenHelpers.hasEnoughBalance(createStreamMessage.outSupplyToken, address(this), totalRequiredAmount)) {\n            revert InsufficientOutAmount();\n        }\n        // Validate that in token is a valid ERC20\n        if (!TokenHelpers.isValidERC20(createStreamMessage.inSupplyToken, msg.sender)) {\n            revert InvalidInSupplyToken();\n        }\n        // Validate and set creator vesting info\n        if (createStreamMessage.creatorVesting.isVestingEnabled) {\n            // Validate vesting duration\n            if (createStreamMessage.creatorVesting.vestingDuration == 0) {\n                revert InvalidVestingDuration();\n            }\n            if (createStreamMessage.creatorVesting.cliffDuration == 0) {\n                revert InvalidVestingCliffDuration();\n            }\n            if (\n                createStreamMessage.creatorVesting.cliffDuration >= createStreamMessage.creatorVesting.vestingDuration\n            ) {\n                revert InvalidVestingCliffDuration();\n            }\n            // set vesting info\n            postStreamActions.creatorVesting = createStreamMessage.creatorVesting;\n        }\n        // Validate and set beneficiary vesting info\n        if (createStreamMessage.beneficiaryVesting.isVestingEnabled) {\n            // Validate vesting duration\n            if (createStreamMessage.beneficiaryVesting.vestingDuration == 0) {\n                revert InvalidVestingDuration();\n            }\n            if (createStreamMessage.beneficiaryVesting.cliffDuration == 0) {\n                revert InvalidVestingCliffDuration();\n            }\n            if (\n                createStreamMessage.beneficiaryVesting.cliffDuration >=\n                createStreamMessage.beneficiaryVesting.vestingDuration\n            ) {\n                revert InvalidVestingCliffDuration();\n            }\n            // set vesting info\n            postStreamActions.beneficiaryVesting = createStreamMessage.beneficiaryVesting;\n        }\n        // Validate pool config\n        if (createStreamMessage.poolInfo.poolOutSupplyAmount > 0) {\n            // Validate pool amount is less than or equal to out amount\n            if (createStreamMessage.poolInfo.poolOutSupplyAmount > createStreamMessage.streamOutAmount) {\n                revert InvalidAmount();\n            }\n            postStreamActions.poolInfo = createStreamMessage.poolInfo;\n        }\n        // Save position storage address\n        positionStorageAddress = _positionStorageAddress;\n        // Set creator\n        creator = createStreamMessage.creator;\n        // Initialize stream state\n        streamState = StreamTypes.StreamState({\n            distIndex: DecimalMath.fromNumber(0),\n            outRemaining: createStreamMessage.streamOutAmount,\n            inSupply: 0,\n            spentIn: 0,\n            shares: 0,\n            currentStreamedPrice: DecimalMath.fromNumber(0),\n            threshold: createStreamMessage.threshold,\n            outSupply: createStreamMessage.streamOutAmount,\n            lastUpdated: block.timestamp\n        });\n        // Initialize stream tokens\n        streamTokens = StreamTypes.StreamTokens({\n            inSupplyToken: createStreamMessage.inSupplyToken,\n            outSupplyToken: createStreamMessage.outSupplyToken\n        });\n        // Initialize stream metadata\n        streamMetadata = StreamTypes.StreamMetadata({ name: createStreamMessage.name });\n        // Initialize stream status\n        streamStatus = StreamTypes.Status.Waiting;\n        // Initialize stream times\n        streamTimes = StreamTypes.StreamTimes({\n            bootstrappingStartTime: createStreamMessage.bootstrappingStartTime,\n            streamStartTime: createStreamMessage.streamStartTime,\n            streamEndTime: createStreamMessage.streamEndTime\n        });\n    }\n\n    function syncStream(\n        StreamTypes.StreamState memory state,\n        StreamTypes.StreamTimes memory times,\n        uint256 nowTime\n    ) internal pure returns (StreamTypes.StreamState memory) {\n        Decimal memory diff = StreamMathLib.calculateDiff(\n            nowTime,\n            times.streamStartTime,\n            times.streamEndTime,\n            state.lastUpdated\n        );\n        state.lastUpdated = nowTime;\n\n        if (diff.value == 0) {\n            return state;\n        }\n\n        StreamTypes.StreamState memory updatedState = StreamMathLib.calculateUpdatedState(state, diff);\n        return updatedState;\n    }\n\n    function saveStreamState(StreamTypes.StreamState memory state) internal {\n        streamState = state;\n    }\n\n    function loadStreamState() internal view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    /**\n     * @dev Validates if an operation is allowed based on the current stream status\n     * @param allowedStatuses Array of allowed statuses for the operation\n     */\n    function isOperationAllowed(\n        StreamTypes.Status currentStatus,\n        StreamTypes.Status[] memory allowedStatuses\n    ) internal pure {\n        for (uint256 i = 0; i < allowedStatuses.length; i++) {\n            if (currentStatus == allowedStatuses[i]) {\n                return;\n            }\n        }\n        revert OperationNotAllowed();\n    }\n\n    /**\n     * @dev Checks if the threshold has been reached for stream finalization\n     * @return bool True if the threshold has been reached, false otherwise\n     */\n    function isThresholdReached(StreamTypes.StreamState memory state) internal pure returns (bool) {\n        return state.spentIn >= state.threshold;\n    }\n\n    /**\n     * @dev Validates a position exists and is active\n     * @param position The position to validate\n     * @return bool True if the position is valid and active\n     */\n    function isValidActivePosition(PositionTypes.Position memory position) internal pure returns (bool) {\n        return position.shares > 0 && position.exitDate == 0;\n    }\n\n    function withdraw(uint256 cap) external {\n        assertAmountNotZero(cap);\n        // Load position once\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n\n        // Check if position is valid and active\n        if (!isValidActivePosition(position)) {\n            revert InvalidPosition();\n        }\n\n        // load stream times\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        StreamTypes.Status[] memory allowedStatuses = new StreamTypes.Status[](2);\n        allowedStatuses[0] = StreamTypes.Status.Active;\n        allowedStatuses[1] = StreamTypes.Status.Bootstrapping;\n        isOperationAllowed(status, allowedStatuses);\n\n        // Save the updated status\n        saveStreamStatus(status);\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state, times, block.timestamp);\n\n        // Sync position with the updated state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // Check if withdrawal amount exceeds position balance\n        if (cap > position.inBalance) {\n            revert WithdrawAmountExceedsBalance(cap);\n        }\n\n        uint256 shareDeduction = 0;\n\n        if (cap == position.inBalance) {\n            shareDeduction = position.shares;\n        } else {\n            shareDeduction = StreamMathLib.computeSharesAmount(cap, true, state.inSupply, position.shares);\n        }\n\n        // Update position\n        position.shares = position.shares - shareDeduction;\n        position.inBalance = position.inBalance - cap;\n\n        // Update stream state\n        state.inSupply = state.inSupply - cap;\n        state.shares = state.shares - shareDeduction;\n\n        // Save everything at the end\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        // Token transfer\n        TokenHelpers.safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, cap);\n        emit Withdrawn(address(this), msg.sender, position.inBalance, position.shares, state.inSupply, state.shares);\n    }\n\n    function subscribe(uint256 amountIn) external payable {\n        assertAmountNotZero(amountIn);\n        // Load status once\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        // Update the loaded status\n        status = syncStreamStatus(status, times, block.timestamp);\n        // Check if operation is allowed with the updated status\n        StreamTypes.Status[] memory allowedStatuses = new StreamTypes.Status[](2);\n        allowedStatuses[0] = StreamTypes.Status.Bootstrapping;\n        allowedStatuses[1] = StreamTypes.Status.Active;\n        isOperationAllowed(status, allowedStatuses);\n        // Save the updated status\n        saveStreamStatus(status);\n\n        // Validate if sender has enough tokens\n        IERC20 streamInToken = IERC20(streamTokens.inSupplyToken);\n        uint256 streamInTokenBalance = streamInToken.balanceOf(msg.sender);\n        if (streamInTokenBalance < amountIn) {\n            revert InsufficientTokenPayment(amountIn, streamInTokenBalance);\n        }\n\n        // Transfer tokens from sender to this contract\n        bool success = streamInToken.transferFrom(msg.sender, address(this), amountIn);\n        if (!success) {\n            revert PaymentFailed();\n        }\n        // Load position once\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n\n        // Load stream state once\n        StreamTypes.StreamState memory state = loadStream();\n\n        // Update the stream state\n        state = syncStream(state);\n\n        uint256 newShares = 0;\n\n        if (position.shares == 0) {\n            // New position case\n            newShares = StreamMathLib.computeSharesAmount(amountIn, false, state.inSupply, state.shares);\n            position = PositionTypes.Position({\n                inBalance: amountIn,\n                shares: newShares,\n                index: state.distIndex,\n                lastUpdateTime: block.timestamp,\n                pendingReward: DecimalMath.fromNumber(0),\n                spentIn: 0,\n                purchased: 0,\n                exitDate: 0\n            });\n        } else {\n            // Update existing position\n            newShares = StreamMathLib.computeSharesAmount(amountIn, false, state.inSupply, state.shares);\n            position = StreamMathLib.syncPosition(\n                position,\n                state.distIndex,\n                state.shares,\n                state.inSupply,\n                block.timestamp\n            );\n            position.inBalance += amountIn;\n            position.shares += newShares;\n        }\n\n        // Update StreamState\n        state.inSupply += amountIn;\n        state.shares += newShares;\n\n        // Save everything once we're done modifying\n        savePosition(msg.sender, position);\n        saveStream(state);\n\n        // Emit event\n        emit Subscribed(address(this), msg.sender, amountIn, newShares, state.inSupply, state.shares);\n    }\n\n    function exitStream() external {\n        // Load position\n        PositionTypes.Position memory position = loadPosition(msg.sender);\n\n        // Check if position is valid and active\n        if (!isValidActivePosition(position)) {\n            revert InvalidPosition();\n        }\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state);\n\n        // Sync position with updated state\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        bool thresholdReached = isThresholdReached(state);\n\n        // Handle token distributions based on exit scenario\n        handleExitDistribution(status, thresholdReached, position, postStreamActions.beneficiaryVesting);\n\n        // Set exit date\n        position.exitDate = block.timestamp;\n\n        // Save everything\n        saveStreamStatus(status);\n        saveStream(state);\n        savePosition(msg.sender, position);\n    }\n\n    function handleExitDistribution(\n        StreamTypes.Status status,\n        bool thresholdReached,\n        PositionTypes.Position memory position,\n        StreamTypes.VestingInfo memory vestingInfo\n    ) internal {\n        // Case 1: Successful stream completion\n        if (isSuccessfulExit(status, thresholdReached)) {\n            // Return any unused input tokens\n            if (position.inBalance > 0) {\n                TokenHelpers.safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, position.inBalance);\n            }\n            if (vestingInfo.isVestingEnabled) {\n                // Distribute earned output tokens\n                uint256 amountToDistribute = position.purchased;\n                // Load factory params\n                StreamFactory factoryContract = StreamFactory(streamFactoryAddress);\n                StreamFactoryTypes.Params memory params = factoryContract.getParams();\n                address vestingContractAddress = params.vestingAddress;\n                IVesting vestingContract = IVesting(vestingContractAddress);\n                // Create vesting schedule\n                (uint256 cliffTime, uint256 endTime) = StreamMathLib.calculateVestingSchedule(\n                    block.timestamp,\n                    vestingInfo.cliffDuration,\n                    vestingInfo.vestingDuration\n                );\n                // Transfer tokens to vesting contract\n                TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, vestingContractAddress, amountToDistribute);\n                // Create vesting schedule\n                vestingContract.stakeFunds(\n                    msg.sender,\n                    streamTokens.outSupplyToken,\n                    cliffTime,\n                    endTime,\n                    amountToDistribute\n                );\n            } else {\n                // Direct transfer if vesting is not enabled\n                TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, msg.sender, position.purchased);\n            }\n            emit ExitStreamed(address(this), msg.sender, position.purchased, position.spentIn, block.timestamp);\n            return;\n        }\n\n        // Case 2: Refund scenario\n        if (isRefundExit(status, thresholdReached)) {\n            // Full refund of all input tokens (both spent and unspent)\n            uint256 totalRefund = position.inBalance + position.spentIn;\n            TokenHelpers.safeTokenTransfer(streamTokens.inSupplyToken, msg.sender, totalRefund);\n            emit ExitRefunded(address(this), msg.sender, totalRefund, block.timestamp);\n            return;\n        }\n\n        // If neither condition is met, the exit is not allowed\n        revert InvalidExitCondition();\n    }\n\n    function isSuccessfulExit(StreamTypes.Status status, bool thresholdReached) internal pure returns (bool) {\n        return\n            (status == StreamTypes.Status.Ended && thresholdReached) ||\n            (status == StreamTypes.Status.FinalizedStreamed);\n    }\n\n    function isRefundExit(StreamTypes.Status status, bool thresholdReached) internal pure returns (bool) {\n        return\n            status == StreamTypes.Status.Cancelled ||\n            status == StreamTypes.Status.FinalizedRefunded ||\n            (status == StreamTypes.Status.Ended && !thresholdReached);\n    }\n\n    function deductExitFee(\n        Decimal memory exitFeeRatio,\n        address tokenAddress,\n        address feeCollector,\n        uint256 spentIn\n    ) internal returns (uint256, uint256) {\n        // Calculate exit fee\n        (uint256 feeAmount, uint256 creatorRevenue) = StreamMathLib.calculateExitFee(spentIn, exitFeeRatio);\n\n        // Transfer fee to fee collector if needed\n        if (feeAmount > 0) {\n            TokenHelpers.safeTokenTransfer(tokenAddress, feeCollector, feeAmount);\n        }\n        return (creatorRevenue, feeAmount);\n    }\n\n    function finalizeStream() external {\n        assertIsCreator();\n\n        // Get factory params\n        StreamFactory factoryContract = StreamFactory(streamFactoryAddress);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        StreamTypes.Status[] memory allowedStatuses = new StreamTypes.Status[](1);\n        allowedStatuses[0] = StreamTypes.Status.Ended;\n        isOperationAllowed(status, allowedStatuses);\n\n        // Load and update stream state\n        StreamTypes.StreamState memory state = loadStream();\n        state = syncStream(state, times, block.timestamp);\n\n        bool thresholdReached = isThresholdReached(state);\n\n        if (thresholdReached) {\n            address feeCollector = params.feeCollector;\n            Decimal memory exitFeeRatio = params.exitFeeRatio;\n\n            // Calculate exit fee\n            (uint256 creatorRevenue, uint256 feeAmount) = deductExitFee(\n                exitFeeRatio,\n                streamTokens.inSupplyToken,\n                feeCollector,\n                state.spentIn\n            );\n\n            // Handle pool creation if configured\n            if (postStreamActions.poolInfo.poolOutSupplyAmount > 0) {\n                // Calculate pool ratio\n                Decimal memory poolRatio = DecimalMath.div(\n                    DecimalMath.fromNumber(postStreamActions.poolInfo.poolOutSupplyAmount),\n                    DecimalMath.fromNumber(streamState.outSupply)\n                );\n\n                uint256 poolInSupplyAmount = StreamMathLib.calculatePoolAmount(creatorRevenue, poolRatio);\n                uint256 poolOutSupplyAmount = postStreamActions.poolInfo.poolOutSupplyAmount;\n                // Calculate remaining revenue\n                creatorRevenue = creatorRevenue - poolInSupplyAmount;\n\n                // Create pool and add liquidity\n                createPoolAndAddLiquidity(\n                    streamTokens.inSupplyToken,\n                    streamTokens.outSupplyToken,\n                    poolInSupplyAmount,\n                    poolOutSupplyAmount\n                );\n            }\n\n            // Handle vesting if enabled\n            if (postStreamActions.creatorVesting.isVestingEnabled) {\n                // Create vesting schedule\n                (uint256 cliffTime, uint256 endTime) = StreamMathLib.calculateVestingSchedule(\n                    block.timestamp,\n                    postStreamActions.creatorVesting.cliffDuration,\n                    postStreamActions.creatorVesting.vestingDuration\n                );\n                createVesting(\n                    streamTokens.inSupplyToken,\n                    creator,\n                    params.vestingAddress,\n                    creatorRevenue,\n                    cliffTime,\n                    endTime\n                );\n            } else {\n                // Transfer creator revenue to creator\n                TokenHelpers.safeTokenTransfer(streamTokens.inSupplyToken, creator, creatorRevenue);\n            }\n\n            // Update status\n            status = StreamTypes.Status.FinalizedStreamed;\n\n            // Refund out tokens to creator if left any\n            if (state.outRemaining > 0) {\n                TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, creator, state.outRemaining);\n            }\n\n            emit FinalizedStreamed(address(this), creator, creatorRevenue, feeAmount, state.outRemaining, status);\n        } else {\n            // Update status\n            status = StreamTypes.Status.FinalizedRefunded;\n\n            // Refund out tokens to creator\n            TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, creator, state.outSupply);\n\n            emit FinalizedRefunded(address(this), creator, state.outSupply, status);\n        }\n\n        // Save everything\n        saveStreamStatus(status);\n        saveStream(state);\n    }\n\n    function syncStreamExternal() external {\n        // Load, update and save stream state\n        StreamTypes.StreamState memory state = loadStream();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        state = syncStream(state, times, block.timestamp);\n        saveStream(state);\n\n        // Load, update and save status\n        StreamTypes.Status status = loadStreamStatus();\n        status = syncStreamStatus(status, times, block.timestamp);\n        saveStreamStatus(status);\n\n        emit StreamSynced(\n            address(this),\n            state.lastUpdated,\n            uint8(status),\n            state.distIndex,\n            state.outRemaining,\n            state.inSupply,\n            state.spentIn,\n            state.currentStreamedPrice\n        );\n    }\n\n    function syncPosition(address user) external {\n        PositionTypes.Position memory position = loadPosition(user);\n        StreamTypes.StreamState memory state = loadStream();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        state = syncStream(state, times, block.timestamp);\n        position = StreamMathLib.syncPosition(position, state.distIndex, state.shares, state.inSupply, block.timestamp);\n        savePosition(user, position);\n        saveStream(state);\n        emit PositionSynced(address(this), user, position.inBalance, position.shares);\n    }\n\n    function cancelStream() external {\n        assertIsCreator();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        StreamTypes.Status[] memory allowedStatuses = new StreamTypes.Status[](1);\n        allowedStatuses[0] = StreamTypes.Status.Waiting;\n        isOperationAllowed(status, allowedStatuses);\n\n        // Refund out tokens to creator\n        TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, creator, streamState.outSupply);\n\n        // Update status\n        status = StreamTypes.Status.Cancelled;\n        saveStreamStatus(status);\n\n        emit StreamCancelled(address(this), creator, streamState.outSupply, status);\n    }\n\n    function cancelWithAdmin() external {\n        assertIsProtocolAdmin();\n\n        // Load and update status\n        StreamTypes.Status status = loadStreamStatus();\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n        status = syncStreamStatus(status, times, block.timestamp);\n\n        // Check if operation is allowed\n        StreamTypes.Status[] memory allowedStatuses = new StreamTypes.Status[](3);\n        allowedStatuses[0] = StreamTypes.Status.Waiting;\n        allowedStatuses[1] = StreamTypes.Status.Bootstrapping;\n        allowedStatuses[2] = StreamTypes.Status.Active;\n        isOperationAllowed(status, allowedStatuses);\n\n        // Refund out tokens to creator\n        TokenHelpers.safeTokenTransfer(streamTokens.outSupplyToken, creator, streamState.outSupply);\n\n        // Update status\n        status = StreamTypes.Status.Cancelled;\n        saveStreamStatus(status);\n\n        emit StreamCancelled(address(this), creator, streamState.outSupply, status);\n    }\n\n    // Load helpers\n    function loadStream() internal view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    function loadStreamStatus() internal view returns (StreamTypes.Status) {\n        return streamStatus;\n    }\n\n    function loadPosition(address user) internal view returns (PositionTypes.Position memory) {\n        PositionStorage positionStorage = PositionStorage(positionStorageAddress);\n        return positionStorage.getPosition(user);\n    }\n\n    function loadStreamTimes() internal view returns (StreamTypes.StreamTimes memory) {\n        return streamTimes;\n    }\n\n    // Save helpers\n    function saveStream(StreamTypes.StreamState memory state) internal {\n        streamState = state;\n    }\n\n    function saveStreamStatus(StreamTypes.Status status) internal {\n        streamStatus = status;\n    }\n\n    function savePosition(address user, PositionTypes.Position memory position) internal {\n        PositionStorage positionStorage = PositionStorage(positionStorageAddress);\n        positionStorage.updatePosition(user, position);\n    }\n\n    // Refactored syncStream to work directly with a provided memory object\n    function syncStream(StreamTypes.StreamState memory state) internal view returns (StreamTypes.StreamState memory) {\n        StreamTypes.StreamTimes memory times = loadStreamTimes();\n\n        Decimal memory diff = StreamMathLib.calculateDiff(\n            block.timestamp,\n            times.streamStartTime,\n            times.streamEndTime,\n            state.lastUpdated\n        );\n\n        if (diff.value > 0) {\n            state = StreamMathLib.calculateUpdatedState(state, diff);\n            state.lastUpdated = block.timestamp;\n        }\n\n        return state;\n    }\n\n    function createPoolAndAddLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    ) internal {\n        StreamFactory factoryContract = StreamFactory(streamFactoryAddress);\n        StreamFactoryTypes.Params memory params = factoryContract.getParams();\n\n        address poolWrapperAddress = params.poolWrapperAddress;\n        IPoolWrapper poolWrapper = IPoolWrapper(poolWrapperAddress);\n\n        PoolWrapperTypes.CreatePoolMsg memory createPoolMsg = PoolWrapperTypes.CreatePoolMsg({\n            token0: tokenA,\n            token1: tokenB,\n            amount0: amountADesired,\n            amount1: amountBDesired\n        });\n        poolWrapper.createPool(createPoolMsg);\n\n        // Transfer pool tokens to stream\n        TokenHelpers.safeTokenTransfer(tokenA, poolWrapperAddress, amountADesired);\n        TokenHelpers.safeTokenTransfer(tokenB, poolWrapperAddress, amountBDesired);\n    }\n\n    function createVesting(\n        address token,\n        address beneficiary,\n        address vestingAddress,\n        uint256 amount,\n        uint256 cliffDuration,\n        uint256 vestingDuration\n    ) internal {\n        IVesting vesting = IVesting(vestingAddress);\n        vesting.stakeFunds(token, beneficiary, cliffDuration, vestingDuration, amount);\n    }\n\n    // Refactored syncStreamStatus to work directly with a provided memory object\n    function syncStreamStatus(\n        StreamTypes.Status status,\n        StreamTypes.StreamTimes memory times,\n        uint256 nowTime\n    ) internal pure returns (StreamTypes.Status) {\n        status = StreamMathLib.calculateStreamStatus(\n            status,\n            nowTime,\n            times.bootstrappingStartTime,\n            times.streamStartTime,\n            times.streamEndTime\n        );\n\n        return status;\n    }\n\n    /**\n     * @dev Ensure value is non-zero\n     * @param value The value to check\n     * @param errorMessage The error message to revert with\n     */\n    function assertNonZero(uint256 value, string memory errorMessage) internal pure {\n        if (value == 0) revert(errorMessage);\n    }\n\n    /**\n     * @dev Ensure sender is the creator\n     */\n    function assertIsCreator() internal view {\n        if (msg.sender != creator) revert Unauthorized();\n    }\n\n    /**\n     * @dev Ensure sender is the protocol admin\n     */\n    function assertIsProtocolAdmin() internal view {\n        StreamFactory factoryContract = StreamFactory(streamFactoryAddress);\n        address protocolAdmin = factoryContract.getParams().protocolAdmin;\n        if (msg.sender != protocolAdmin) revert Unauthorized();\n    }\n\n    /**\n     * @dev Ensure status matches expected value\n     * @param status Current status to check\n     * @param expectedStatus Status that is expected\n     */\n    function assertStatus(StreamTypes.Status status, StreamTypes.Status expectedStatus) internal pure {\n        if (status != expectedStatus) revert OperationNotAllowed();\n    }\n\n    /**\n     * @dev Ensure amount is not zero\n     * @param amount Amount to check\n     */\n    function assertAmountNotZero(uint256 amount) internal pure {\n        if (amount == 0) revert InvalidAmount();\n    }\n\n    /**\n     * @dev Assert that the cap does not exceed balance\n     * @param cap Amount to withdraw\n     * @param balance Available balance\n     */\n    function assertWithinBalance(uint256 cap, uint256 balance) internal pure {\n        if (cap > balance) revert WithdrawAmountExceedsBalance(cap);\n    }\n\n    /**\n     * @dev Get the current stream status\n     * @return The current stream status\n     */\n    function getStreamStatus() external view returns (StreamTypes.Status) {\n        return streamStatus;\n    }\n\n    /**\n     * @dev Get the current stream state\n     * @return The current stream state\n     */\n    function getStreamState() external view returns (StreamTypes.StreamState memory) {\n        return streamState;\n    }\n\n    function getPosition(address user) external view returns (PositionTypes.Position memory) {\n        PositionStorage positionStorage = PositionStorage(positionStorageAddress);\n        return positionStorage.getPosition(user);\n    }\n}\n"
    },
    "contracts/StreamFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\nimport \"./interfaces/IStreamEvents.sol\";\nimport \"./interfaces/IStreamFactoryErrors.sol\";\nimport \"./Vesting.sol\";\nimport \"./types/StreamTypes.sol\";\nimport \"./interfaces/IStream.sol\";\nimport \"hardhat/console.sol\";\nimport \"./types/StreamFactoryTypes.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./storage/PositionStorage.sol\";\n\ncontract StreamFactory is IStreamEvents, IStreamFactoryErrors {\n    mapping(address => bool) public acceptedInSupplyTokens;\n\n    address public constant NATIVE_TOKEN = address(0);\n\n    uint16 public currentStreamId;\n\n    StreamFactoryTypes.Params public params;\n    mapping(uint16 => address) public streamAddresses;\n\n    bool public frozen;\n    bool public initialized;\n\n    constructor(address _protocolAdmin) {\n        if (_protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        params.protocolAdmin = _protocolAdmin;\n    }\n\n    // Only once\n    modifier onlyOnce() {\n        require(!initialized, \"Already initialized\");\n        _;\n        initialized = true;\n    }\n\n    function initialize(\n        StreamFactoryTypes.initializeStreamMessage memory initializeStreamMessage\n    ) external onlyAdmin onlyOnce {\n        if (DecimalMath.gt(initializeStreamMessage.exitFeeRatio, DecimalMath.fromNumber(1)))\n            revert InvalidExitFeeRatio();\n\n        // Deploy vesting contract\n        Vesting vesting = new Vesting();\n        emit VestingContractDeployed(address(this), address(vesting));\n\n        params.streamCreationFee = initializeStreamMessage.streamCreationFee;\n        params.streamCreationFeeToken = initializeStreamMessage.streamCreationFeeToken;\n        params.exitFeeRatio = initializeStreamMessage.exitFeeRatio;\n        params.minWaitingDuration = initializeStreamMessage.minWaitingDuration;\n        params.minBootstrappingDuration = initializeStreamMessage.minBootstrappingDuration;\n        params.minStreamDuration = initializeStreamMessage.minStreamDuration;\n        params.feeCollector = initializeStreamMessage.feeCollector;\n        params.tosVersion = initializeStreamMessage.tosVersion;\n        params.vestingAddress = address(vesting);\n        params.poolWrapperAddress = initializeStreamMessage.poolWrapperAddress;\n        params.streamImplementationAddress = initializeStreamMessage.streamImplementationAddress;\n        // Set accepted tokens\n        for (uint i = 0; i < initializeStreamMessage.acceptedInSupplyTokens.length; i++) {\n            acceptedInSupplyTokens[initializeStreamMessage.acceptedInSupplyTokens[i]] = true;\n        }\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != params.protocolAdmin) revert NotAdmin();\n        _;\n    }\n\n    function updateParams(\n        uint256 _streamCreationFee,\n        Decimal memory _exitFeeRatio,\n        uint256 _minWaitingDuration,\n        uint256 _minBootstrappingDuration,\n        uint256 _minStreamDuration,\n        string memory _tosVersion\n    ) external onlyAdmin {\n        params.streamCreationFee = _streamCreationFee;\n        params.exitFeeRatio = _exitFeeRatio;\n        params.minWaitingDuration = _minWaitingDuration;\n        params.minBootstrappingDuration = _minBootstrappingDuration;\n        params.minStreamDuration = _minStreamDuration;\n        params.tosVersion = _tosVersion;\n\n        emit ParamsUpdated(\n            address(this),\n            _streamCreationFee,\n            _exitFeeRatio.value,\n            _minWaitingDuration,\n            _minBootstrappingDuration,\n            _minStreamDuration,\n            _tosVersion\n        );\n    }\n\n    function updateFeeCollector(address _feeCollector) external onlyAdmin {\n        if (_feeCollector == address(0)) revert InvalidFeeCollector();\n        params.feeCollector = _feeCollector;\n        emit FeeCollectorUpdated(address(this), _feeCollector);\n    }\n\n    function updateProtocolAdmin(address _protocolAdmin) external onlyAdmin {\n        if (_protocolAdmin == address(0)) revert InvalidProtocolAdmin();\n        params.protocolAdmin = _protocolAdmin;\n        emit ProtocolAdminUpdated(address(this), _protocolAdmin);\n    }\n\n    function updateAcceptedTokens(\n        address[] calldata tokens_to_add,\n        address[] calldata tokens_to_remove\n    ) external onlyAdmin {\n        for (uint i = 0; i < tokens_to_add.length; i++) {\n            acceptedInSupplyTokens[tokens_to_add[i]] = true;\n        }\n        for (uint i = 0; i < tokens_to_remove.length; i++) {\n            acceptedInSupplyTokens[tokens_to_remove[i]] = false;\n        }\n        emit AcceptedTokensUpdated(address(this), tokens_to_add, tokens_to_remove);\n    }\n\n    function updatePoolWrapper(address _poolWrapper) external onlyAdmin {\n        if (_poolWrapper == address(0)) revert InvalidPoolWrapper();\n        params.poolWrapperAddress = _poolWrapper;\n        emit PoolWrapperUpdated(address(this), _poolWrapper);\n    }\n\n    function createStream(StreamTypes.createStreamMessage memory createStreamMessage) external payable {\n        // Check if contract is accepting new streams (not frozen)\n        if (frozen) revert ContractFrozen();\n        // Validate input parameters\n        if (createStreamMessage.streamOutAmount == 0) revert ZeroOutSupplyNotAllowed();\n        if (!acceptedInSupplyTokens[createStreamMessage.inSupplyToken]) revert StreamInputTokenNotAccepted();\n\n        // Validate time parameters using validateStreamTimes\n        validateStreamTimes(\n            block.timestamp,\n            createStreamMessage.bootstrappingStartTime,\n            createStreamMessage.streamStartTime,\n            createStreamMessage.streamEndTime\n        );\n\n        // Validate TOS version\n        if (\n            keccak256(abi.encodePacked(createStreamMessage.tosVersion)) !=\n            keccak256(abi.encodePacked(params.tosVersion))\n        ) revert InvalidToSVersion();\n\n        // Load creation fee\n        uint256 creationFee = params.streamCreationFee;\n        if (creationFee > 0) {\n            if (params.streamCreationFeeToken == address(0)) {\n                // Native token\n                if (msg.value < creationFee) revert InsufficientNativeToken();\n                // Transfer fee to fee collector\n                if (!payable(params.feeCollector).send(creationFee)) revert FeeTransferFailed();\n            } else {\n                // ERC20 token\n                if (\n                    !IERC20(params.streamCreationFeeToken).transferFrom(\n                        msg.sender,\n                        address(params.feeCollector),\n                        creationFee\n                    )\n                ) revert TokenTransferFailed();\n            }\n        }\n\n        // Clone stream contract\n        address clone = Clones.clone(params.streamImplementationAddress);\n        IStream stream = IStream(clone);\n\n        // Deploy PositionStorage\n        PositionStorage positionStorage = new PositionStorage(address(stream));\n\n        // Transfer tokens before initialization\n        if (\n            !IERC20(createStreamMessage.outSupplyToken).transferFrom(\n                msg.sender,\n                address(stream),\n                createStreamMessage.streamOutAmount + createStreamMessage.poolInfo.poolOutSupplyAmount\n            )\n        ) revert TokenTransferFailed();\n\n        // Initialize the cloned stream\n        stream.initialize(createStreamMessage, address(positionStorage));\n\n        // Store stream address\n        streamAddresses[currentStreamId] = address(stream);\n\n        emit StreamCreated(\n            createStreamMessage.outSupplyToken,\n            createStreamMessage.inSupplyToken,\n            address(this),\n            createStreamMessage.streamOutAmount,\n            createStreamMessage.bootstrappingStartTime,\n            createStreamMessage.streamStartTime,\n            createStreamMessage.streamEndTime,\n            createStreamMessage.threshold,\n            createStreamMessage.name,\n            params.tosVersion,\n            address(stream),\n            currentStreamId\n        );\n        currentStreamId++;\n    }\n\n    function getStreams() external view returns (address[] memory) {\n        address[] memory streams = new address[](currentStreamId);\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            streams[i] = streamAddresses[i];\n        }\n        return streams;\n    }\n\n    function getStream(uint16 _streamId) external view returns (address) {\n        return streamAddresses[_streamId];\n    }\n\n    function isStream(address _streamAddress) external view returns (bool) {\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            if (streamAddresses[i] == _streamAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getParams() external view returns (StreamFactoryTypes.Params memory) {\n        return params;\n    }\n\n    function isAcceptedInSupplyToken(address token) public view returns (bool) {\n        return acceptedInSupplyTokens[token];\n    }\n\n    function getAcceptedInSupplyTokens() external view returns (address[] memory) {\n        address[] memory tokens = new address[](currentStreamId);\n        for (uint16 i = 0; i < currentStreamId; i++) {\n            if (acceptedInSupplyTokens[streamAddresses[i]]) {\n                tokens[i] = streamAddresses[i];\n            }\n        }\n        return tokens;\n    }\n\n    function setFrozen(bool _frozen) external onlyAdmin {\n        frozen = _frozen;\n        emit FrozenStateUpdated(address(this), _frozen);\n    }\n\n    function validateStreamTimes(\n        uint256 nowTime,\n        uint256 _bootstrappingStartTime,\n        uint256 _startTime,\n        uint256 _endTime\n    ) internal view {\n        if (nowTime > _bootstrappingStartTime) revert InvalidBootstrappingStartTime();\n        if (_bootstrappingStartTime > _startTime) revert InvalidStreamStartTime();\n        if (_startTime > _endTime) revert InvalidStreamEndTime();\n        if (_endTime - _startTime < params.minStreamDuration) revert StreamDurationTooShort();\n        if (_startTime - _bootstrappingStartTime < params.minBootstrappingDuration)\n            revert BootstrappingDurationTooShort();\n        if (_bootstrappingStartTime - nowTime < params.minWaitingDuration) revert WaitingDurationTooShort();\n    }\n\n    function setImplementation(address _implementation) external onlyAdmin {\n        if (_implementation == address(0)) revert InvalidImplementationAddress();\n\n        params.streamImplementationAddress = _implementation;\n    }\n\n    function setStreamCreationFee(uint256 _fee) external onlyAdmin {\n        params.streamCreationFee = _fee;\n    }\n\n    function setStreamCreationFeeToken(address _token) external onlyAdmin {\n        params.streamCreationFeeToken = _token;\n    }\n\n    function setExitFeeRatio(Decimal memory _ratio) external onlyAdmin {\n        if (DecimalMath.gt(_ratio, DecimalMath.fromNumber(1))) revert InvalidExitFeeRatio();\n        params.exitFeeRatio = _ratio;\n    }\n}\n"
    },
    "contracts/types/PoolWrapperTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nlibrary PoolWrapperTypes {\n    struct CreatePoolMsg {\n        address token0;\n        address token1;\n        uint256 amount0;\n        uint256 amount1;\n    }\n\n    struct CreatedPoolInfo {\n        address poolAddress;\n        address token0;\n        address token1;\n    }\n}\n"
    },
    "contracts/types/PositionTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../lib/math/DecimalMath.sol\";\n\nlibrary PositionTypes {\n    struct Position {\n        uint256 inBalance;\n        uint256 shares;\n        Decimal index;\n        uint256 lastUpdateTime;\n        Decimal pendingReward;\n        uint256 spentIn;\n        uint256 purchased;\n        uint256 exitDate;\n    }\n}\n"
    },
    "contracts/types/StreamFactoryTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../lib/math/DecimalMath.sol\";\n\nlibrary StreamFactoryTypes {\n    struct Params {\n        uint256 streamCreationFee;\n        address streamCreationFeeToken;\n        Decimal exitFeeRatio;\n        uint256 minWaitingDuration;\n        uint256 minBootstrappingDuration;\n        uint256 minStreamDuration;\n        address feeCollector;\n        address protocolAdmin;\n        string tosVersion;\n        address vestingAddress;\n        address poolWrapperAddress;\n        address streamImplementationAddress;\n    }\n\n    struct initializeStreamMessage {\n        uint256 streamCreationFee;\n        address streamCreationFeeToken;\n        Decimal exitFeeRatio;\n        uint256 minWaitingDuration;\n        uint256 minBootstrappingDuration;\n        uint256 minStreamDuration;\n        address feeCollector;\n        address protocolAdmin;\n        string tosVersion;\n        address poolWrapperAddress;\n        address[] acceptedInSupplyTokens;\n        address streamImplementationAddress;\n    }\n}\n"
    },
    "contracts/types/StreamTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../lib/math/DecimalMath.sol\";\n\nlibrary StreamTypes {\n    enum Status {\n        Waiting,\n        Bootstrapping,\n        Active,\n        Ended,\n        FinalizedRefunded,\n        FinalizedStreamed,\n        Cancelled\n    }\n\n    struct createStreamMessage {\n        uint256 streamOutAmount;\n        address outSupplyToken;\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n        uint256 threshold;\n        string name;\n        address inSupplyToken;\n        address creator;\n        VestingInfo creatorVesting;\n        VestingInfo beneficiaryVesting;\n        PoolInfo poolInfo;\n        bytes32 salt;\n        string tosVersion;\n    }\n    struct StreamTimes {\n        uint256 bootstrappingStartTime;\n        uint256 streamStartTime;\n        uint256 streamEndTime;\n    }\n\n    struct StreamMetadata {\n        string name;\n    }\n\n    struct StreamState {\n        uint256 outRemaining;\n        Decimal distIndex;\n        uint256 spentIn;\n        uint256 shares;\n        Decimal currentStreamedPrice;\n        uint256 threshold;\n        uint256 inSupply;\n        uint256 outSupply;\n        uint256 lastUpdated;\n    }\n\n    struct StreamTokens {\n        address inSupplyToken;\n        address outSupplyToken;\n    }\n\n    struct VestingInfo {\n        bool isVestingEnabled;\n        uint16 vestingDuration;\n        uint16 cliffDuration;\n    }\n\n    struct PoolInfo {\n        uint256 poolOutSupplyAmount;\n    }\n\n    struct PostStreamActions {\n        PoolInfo poolInfo;\n        VestingInfo creatorVesting;\n        VestingInfo beneficiaryVesting;\n    }\n}\n"
    },
    "contracts/Vesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./interfaces/IERC20.sol\";\n\ncontract Vesting {\n    struct VestingSchedule {\n        uint256 cliffTime;\n        uint256 endTime;\n        uint256 totalAmount;\n        uint256 releasedAmount;\n    }\n\n    mapping(address => mapping(address => VestingSchedule[])) private tokenVestings;\n\n    event FundsStaked(\n        address indexed beneficiary,\n        address indexed token,\n        uint256 totalAmount,\n        uint256 cliffTime,\n        uint256 endTime\n    );\n\n    event FundsWithdrawn(address indexed beneficiary, address indexed token, uint256 scheduleIndex, uint256 amount);\n\n    function stakeFunds(\n        address beneficiary,\n        address tokenAddress,\n        uint256 cliffTime,\n        uint256 endTime,\n        uint256 totalAmount\n    ) external {\n        require(cliffTime >= block.timestamp, \"Cliff time must be in the future\");\n        require(endTime > cliffTime, \"End time must be after cliff time\");\n        require(totalAmount > 0, \"Total amount must be greater than zero\");\n\n        require(IERC20(tokenAddress).transferFrom(msg.sender, address(this), totalAmount), \"Token transfer failed\");\n\n        VestingSchedule[] storage vestingSchedules = tokenVestings[beneficiary][tokenAddress];\n        vestingSchedules.push(VestingSchedule(cliffTime, endTime, totalAmount, 0));\n\n        emit FundsStaked(beneficiary, tokenAddress, totalAmount, cliffTime, endTime);\n    }\n\n    function withdrawFunds(address tokenAddress, uint256 scheduleIndex) external {\n        VestingSchedule[] storage vestingSchedules = tokenVestings[msg.sender][tokenAddress];\n        require(scheduleIndex < vestingSchedules.length, \"Invalid schedule index\");\n\n        VestingSchedule storage vestingSchedule = vestingSchedules[scheduleIndex];\n        require(vestingSchedule.cliffTime <= block.timestamp, \"Funds are still in the cliff period\");\n\n        uint256 withdrawableAmount = calculateWithdrawableAmount(vestingSchedule);\n        require(withdrawableAmount > 0, \"No funds available for withdrawal\");\n\n        vestingSchedule.releasedAmount += withdrawableAmount;\n\n        require(IERC20(tokenAddress).transfer(msg.sender, withdrawableAmount), \"Token transfer failed\");\n\n        emit FundsWithdrawn(msg.sender, tokenAddress, scheduleIndex, withdrawableAmount);\n\n        if (vestingSchedule.releasedAmount == vestingSchedule.totalAmount) {\n            delete vestingSchedules[scheduleIndex];\n        }\n    }\n\n    function getStakesForBeneficiary(\n        address beneficiary,\n        address tokenAddress\n    ) external view returns (VestingSchedule[] memory) {\n        return tokenVestings[beneficiary][tokenAddress];\n    }\n\n    function calculateWithdrawableAmount(VestingSchedule storage vestingSchedule) private view returns (uint256) {\n        uint256 elapsedTime = block.timestamp - vestingSchedule.cliffTime;\n\n        if (elapsedTime >= vestingSchedule.endTime - vestingSchedule.cliffTime) {\n            // Can now access all of the funds minus any that have already been claimed\n            return vestingSchedule.totalAmount - vestingSchedule.releasedAmount;\n        } else {\n            // Calculate what proportion of funds is now available and only return that amount\n\n            // How long is the unlock period\n            uint256 totalUnlockPeriod = vestingSchedule.endTime - vestingSchedule.cliffTime;\n\n            // How much should have been unlocked so far\n            uint256 totalAmountAccessible = (vestingSchedule.totalAmount / totalUnlockPeriod) * elapsedTime;\n\n            // Amount available to withdraw is the currently unlocked amount minus anything\n            // that has already been claimed to prevent repeat counting funds\n            uint256 actualAccessible = totalAmountAccessible - vestingSchedule.releasedAmount;\n\n            return actualAccessible;\n        }\n    }\n\n    function getBlockTime() external view returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}